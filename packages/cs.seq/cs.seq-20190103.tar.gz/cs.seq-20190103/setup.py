#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.seq',
  description = 'Stuff to do with counters, sequences and iterables.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20190103',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 (GPLv3)'],
  install_requires = ['cs.logutils'],
  keywords = ['python2', 'python3'],
  long_description = "Stuff to do with counters, sequences and iterables.\n\nNote that any function accepting an iterable\nwill consume some or all of the derived iterator\nin the course of its function.\n\n## Function `first(iterable)`\n\nReturn the first item from an iterable; raise IndexError on empty iterables.\n\n## Function `get0(iterable, default=None)`\n\nReturn first element of an iterable, or the default.\n\n## Function `imerge(*iters, **kw)`\n\nMerge an iterable of ordered iterables in order.\n\nParameters:\n* `iters`: an iterable of iterators\n* `reverse`: keyword parameter: if true, yield items in reverse order.\n  This requires the iterables themselves to also be in\n  reversed order.\n\nThis function relies on the source iterables being ordered\nand their elements being comparable, through slightly misordered\niterables (for example, as extracted from web server logs)\nwill produce only slightly misordered results, as the merging\nis done on the basis of the front elements of each iterable.\n\n## Function `isordered(s, reverse=False, strict=False)`\n\nTest whether an iterable is ordered.\nNote that the iterable is iterated, so this is a destructive\ntest for nonsequences.\n\n## Function `last(iterable)`\n\nReturn the last item from an iterable; raise IndexError on empty iterables.\n\n## Function `onetomany(func)`\n\nA decorator for a method of a sequence to merge the results of\npassing every element of the sequence to the function, expecting\nmultiple values back.\n\nExample:\n\n      class X(list):\n            @onetomany\n            def chars(self, item):\n                  return item\n      strs = X(['Abc', 'Def'])\n      all_chars = X.chars()\n\n## Function `onetoone(func)`\n\nA decorator for a method of a sequence to merge the results of\npassing every element of the sequence to the function, expecting a\nsingle value back.\n\nExample:\n\n      class X(list):\n            @onetoone\n            def lower(self, item):\n                  return item.lower()\n      strs = X(['Abc', 'Def'])\n      lower_strs = X.lower()\n\n## Class `Seq`\n\nA thread safe wrapper for itertools.count().\n\n## Function `seq()`\n\nReturn a new sequential value.\n\n## Class `StatefulIterator`\n\nA trivial iterator which wraps another iterator to expose some tracking state.\n\nThis has 2 attributes:\n* `.it`: the internal iterator which should yield `(item,new_state)`\n* `.state`: the last state value from the internal iterator\n\nThe originating use case is resuse of an iterator by independent\ncalls that are typically sequential, specificly the .read\nmethod of file like objects. Naive sequential reads require\nthe underlying storage to locate the data on every call, even\nthough the previous call has just performed this task for the\nprevious read. Saving the iterator used from the preceeding\ncall allows the iterator to pick up directly if the file\noffset hasn't been fiddled in the meantime.\n\n## Function `tee(iterable, *Qs)`\n\nA generator yielding the items from an iterable\nwhich also copies those items to a series of queues.\n\nParameters:\n* `iterable`: the iterable to copy\n* `Qs`: the queues, objects accepting a `.put` method.\n\nNote: the item is `.put` onto every queue\nbefore being yielded from this generator.\n\n## Function `the(iterable, context=None)`\n\nReturns the first element of an iterable, but requires there to be\nexactly one.\n\n## Class `TrackingCounter`\n\nA wrapper for a counter which can be incremented and decremented.\n\nA facility is provided to wait for the counter to reach a specific value.\nThe .inc and .dec methods also accept a `tag` argument to keep\nindividual counts based on the tag to aid debugging.\n\nTODO: add `strict` option to error and abort if any counter tries\nto go below zero.",
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.seq'],
)
