#!/usr/bin/env python
"""
find-spcgrp: Find the space group of a crystal structure
"""

import math
import numpy as np
import spglib
import fileUtil

def symmetry_map(poslist, numlist, rot, trans, pbc, prec = 1.0e-5):

    natom = len(poslist)
    nop = len(rot)
    sym_map = np.full((natom, nop), -1, dtype=int)
    for i0 in range(natom):
        p0 = poslist[i0]
        n0 = numlist[i0]
        for iop in range(nop):
            p1 = rot[iop].dot(p0) + trans[iop]
            for i2 in range(natom):
                n2 = numlist[i2]
                if n2 == n0:
                    p2 = poslist[i2]
                    dp = p1 - p2
                    dp = reduced_vector(dp, pbc)
                    dist = np.linalg.norm(dp)
                    if dist < prec:
                        sym_map[i0,iop] = i2+1
                        break

    return sym_map

def get_primitive_cell(mol, prec = 1.0e-5):
    """
    Find the primitive cell
    """
    cell = mol.get_spglib_cell()
    pcell = spglib.find_primitive(cell, symprec = prec)
    print('primitive cell=', pcell)
    pmol = mol.from_spglib_cell(pcell)
    pmol.name = 'Primitive cell of ' + mol.name
    pmol.info = 'Primitive cell generated by spglib.find_primitive()'
    return pmol

def reduced_vector(vec, pbc):
    """
    Reduced vector with components in the range (-0.5, 0.5]
    """
    return np.array([reduced_number(v1,pbc1)
                     for (v1,pbc1) in zip(vec, pbc)]).reshape(vec.shape)

def reduced_number(v1, pbc1):
    """
    Reduced number in the range (-0.5, 0.5]
    """
    if pbc1:
        return v1 - math.ceil(v1-0.5)
    else:
        return v1

class show_symmetry:

    def __init__(self):

        pass

    def run(self, args):

        # banner
        print('===================')
        print('   SHOW SYMMETRY   ')
        print('===================')

        # read input file
        mol = fileUtil.read(args.infile)
        mol.report()

        # cell from a molecule
        cell = mol.get_spglib_cell()
        print('cell=', cell)
        dataset = spglib.get_symmetry_dataset(cell, symprec = args.prec)

        print('\nSpace Group: {} {}'.format(
            dataset['number'],
            dataset['international']
        ))
        print('Precision =', args.prec)
        print('Transformation matrix to the standardized basis vectors:')
        for vec in dataset['transformation_matrix']:
            print('  {:>10.6f} {:>10.6f} {:>10.6f} '
                  .format(vec[0], vec[1], vec[2]))
        shift = dataset['origin_shift']
        print('Origin: {:>10.6f} {:>10.6f} {:>10.6f} '
              .format(shift[0], shift[1], shift[2]))
        equivat = dataset['equivalent_atoms']
        # symmetry operations
        rot = dataset['rotations']
        trans = dataset['translations']
        sym_map = symmetry_map(cell[1], cell[2], rot, trans,
                               mol.unitcell.pbc, args.prec)
        print('Symmetry operations: ', len(rot))
        print('----------------------------------------------------------')
        print('  OP    ROT[1]     ROT[2]     ROT[3]          TRANS       ')
        print('----- ---------- ---------- ---------- -------------------')
        for iop, (r, t) in enumerate(zip(rot, trans)):
            print('{:>4}:'.format(iop+1), end=' ')
            print('({:>2} {:>2} {:>2})'
                  .format(r[0][0], r[0][1], r[0][2]), end=' ')
            print('({:>2} {:>2} {:>2})'
                  .format(r[1][0], r[1][1], r[1][2]), end=' ')
            print('({:>2} {:>2} {:>2})'
                  .format(r[2][0], r[2][1], r[2][2]), end=' ')
            print('({:>7.4f} {:>7.4f} {:>7.4f})'
                  .format(t[0], t[1], t[2]))
        # set multiplicity
        multipl = np.zeros(len(equivat), dtype=np.int)
        for ia in range(len(equivat)):
            multipl[equivat[ia]] += 1
        for ia in range(len(equivat)):
            multipl[ia] = multipl[equivat[ia]]
        wyckoff = dataset['wyckoffs']
        print('---------------------------------------------------', end='')
        print('----'*len(rot))
        print('INDX SYMB    x        y        z     EQAT MULT WYKO', end='')
        for iop in range(len(rot)):
            print(' {:>3}'.format(iop+1), end='')
        print()
        print('---- ---- -------- -------- -------- ---- ---- ----', end='')
        print('----'*len(rot))
        for ia, atom in enumerate(mol.atomlist):
            print('{:>4}'.format(ia+1), end=' ')
            print('{:>4}'.format(atom.type), end=' ')
            print('{:>8.4f}'.format(atom.fpos[0]), end=' ')
            print('{:>8.4f}'.format(atom.fpos[1]), end=' ')
            print('{:>8.4f}'.format(atom.fpos[2]), end=' ')
            print('{:>4}'.format(equivat[ia]+1), end=' ')
            print('{:>4}'.format(multipl[ia]), end=' ')
            print('{:>4}'.format(wyckoff[ia]), end='')
            for iop in range(len(rot)):
                print(' {:>3}'.format(sym_map[ia,iop]), end='')
            print()
        print('---------------------------------------------------', end='')
        print('----'*len(rot))

        # primitive cell
        pc = get_primitive_cell(mol, args.prec)
        print('\n=== Primitive cell ===')
        pc.report()
        if args.pcfile != None:
            fileUtil.write(pc, args.pcfile, coord="frac")
            print('Primitive cell written to "{}"'.format(args.pcfile))

if __name__ == "__main__":
    # stand-alone mode
    import argparse
    parser = argparse.ArgumentParser(
        description='Find the space group of a crystal structure')
    parser.add_argument('--reportlevel', type=int, default=4,
                        help='Report level index (0-5)')
    parser.add_argument('--prec', type=float, default=1.0e-4,
                        help='Precision for symmetry checking (1e-4)')
    parser.add_argument('infile',
                        help='Input molecule file')
    parser.add_argument('--pcfile',
                        help='Output file for primitive cell')

    args = parser.parse_args()

    app = show_symmetry()
    app.run(args)
