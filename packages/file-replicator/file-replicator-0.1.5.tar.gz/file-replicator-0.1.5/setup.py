# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['file_replicator']

package_data = \
{'': ['*']}

install_requires = \
['click>=7.0,<8.0', 'inotify>=0.2.10,<0.3.0']

entry_points = \
{'console_scripts': ['file-replicator = file_replicator.cli:main']}

setup_kwargs = {
    'name': 'file-replicator',
    'version': '0.1.5',
    'description': 'Replicate files to another computer for remote development',
    'long_description': '# File Replicator\n\nReplicate files one-way to another computer e.g. for remote development.\n\nA key use-case is to keep in sync a directory of development files from a computer on which\nthe files are edited with a copy of those files in a docker container running on a remote docker host.\n\nDependencies are:\n* Python and some Python packages on the development machine.\n* Ability to run bash on the remote machine with connected `stdin`.\n* The tar utility (the full version, not the busybox version) on both machines.\n\nNothing is installed remotely.\n\nTested and known to work between two Linux machines. Support for developing on macOS coming...\n\n# How it works\n\nThe approach is to run a small bash program on the remote end which is able to add/update new files in\n(potentially) new directories. It receives these programs using the `tar` format.\n\nThe controlling (source) end then simply sends files over to the `stdin` of the receiving bash\nprogram, which pipes them through `tar` to unpack them again.\n\nEstablishing the connection to the remote end is outside the remit of this tool, but `file-replicator`\nrequires as an argument the command to make such a connection. See examples below.\n\nOnce a connection has been made, two phases of operation occur:\n\n1. first, recursively walk a source tree of files and sending all of them over the wire to the destination\n2. then, watch for changes or new files and directories before sending them over the wire to the destination\n\nSo there is no "difference algorithm" like rsync, no attempt to compress, the connection is made\nentirely using standard means like ssh and docker, no ports to open, and even the bash program\non the remote end is sent over every time so nothing is installed remotely.\n\nThis is sufficient for editing code on a local computer and automatically replicating to a remote server\nor docker container.\n\n# Usage and examples\n\nSee help with `file-replicate --help`:\n\n    Usage: file-replicator [OPTIONS] SRC_DIR DEST_PARENT_DIR\n                           [CONNECTION_COMMAND]...\n\n      Replicate files to another computer e.g. for remote development.\n\n      SRC_DIR is the source directory on this machine.\n\n      DEST_PARENT_DIR is the (absolute) destination parent directory on the\n      remote machine accessed using the CONNECTION_COMMAND.\n\n      The CONNECTION_COMMAND must result in a running instance of bash ready to\n      receive commands on stdin.\n\n      Example CONNECTION_COMMANDS include:\n\n          ssh some.host.com bash\n\n          docker exec -i my_container bash\n\n          docker-compose exec -T my_container bash\n\n      So a full use of the tool might look like:\n\n          file-replicator my_code_dir /home/code -- docker exec -i a_container bash\n\n      (the use of "--" prevents any further processing of command line arguments\n      by file-replicator, leaving them all for docker)\n\n      Initially, all files and required directories are recursively copied. Then\n      it waits for changes before copying each modified or new file. This can be\n      modified with the switches.\n\n      Note that empty directories are not replicated until they contain a file.\n\n      Lastly, the only time the tool deletes files or directories is if called\n      with the optional --clean-out-first switch.\n\n    Options:\n      --clean-out-first               Optionally start by cleaning out the\n                                      destination directory.\n      --with-initial-replication / --no-initial-replication\n                                      Perform (or not) an initial replication of\n                                      all files.\n      --replicate-on-change / --no-replicate-on-change\n                                      Perform (or not) a wait-for-change-and-\n                                      replicate cycle.\n      --version                       Show the version and exit.\n      --help                          Show this message and exit.\n\nFor example, to replicate files from local directory `my_project_dir` to directory\n`/home/code/my_project_dir` on remote machine called `my.server.com`:\n\n    file-replicator my_project_dir /home/code ssh my.server.com bash\n\nAs another example, to replicate files from local directory `my_project_dir` to directory\n`/home/code/my_project_dir` in a running docker container called `my_container` on a potentially\nremote host (depending upon the `DOCKER*` environment variables e.g. as set by `docker-machine eval`):\n\n    file-replicator my_project_dir /home/code -- docker exec -i my_container bash\n\nOr to do the same but using `docker-compose` instead:\n\n    file-replicator my_project_dir /home/code -- docker-compose exec -T my_container bash\n\nLastly, as a degenerate example which doesn\'t actually connect to a remote machine at all\nbut replicates into the local `/tmp/my_project_dir`:\n\n    file-replicator my_project_dir /tmp bash\n\nThe unit tests use this degenerate approach to test the tool.\n\n# Limitations\n\nDue to limitations with inotify (race conditions around watching for changes in newly created directories), it\nis possible that the watching-for-changes phase becomes out of step. In which case, just restart the whole program.\n(the tool includes some self-restarting behaviour, but ultimately a full restart may sometimes be needed).\n\nInformation printed to stdout indicates when this happens.\n\n# Tests\n\n    ============================= test session starts ==============================\n    platform linux -- Python 3.6.7, pytest-3.10.1, py-1.7.0, pluggy-0.8.0 -- /home/tcorbettclark/.cache/pypoetry/virtualenvs/file-replicator-py3.6/bin/python\n    cachedir: .pytest_cache\n    rootdir: /home/tcorbettclark/code/file-replicator, inifile:\n    collecting ... collected 8 items\n    tests/test_lib.py::test_empty_directories_are_copied PASSED                [ 12%]\n    tests/test_lib.py::test_copy_one_file PASSED                               [ 25%]\n    tests/test_lib.py::test_copy_file_with_unusual_characters_in_name PASSED   [ 37%]\n    tests/test_lib.py::test_make_missing_parent_directories PASSED             [ 50%]\n    tests/test_lib.py::test_replicate_all_files PASSED                         [ 62%]\n    tests/test_lib.py::test_detect_and_copy_new_file PASSED                    [ 75%]\n    tests/test_lib.py::test_detect_and_copy_modified_file PASSED               [ 87%]\n    tests/test_lib.py::test_detect_and_copy_new_file_in_new_directories PASSED [100%]\n    =========================== 8 passed in 3.94 seconds ===========================\n\n# Contributions\n\nPull-requests are welcome! Please consider including tests and updating docs at the same time.\n\nThe package is maintained using poetry (https://poetry.eustace.io) and pyenv (https://github.com/pyenv/pyenv).\n\nThe code is formatted using black (https://black.readthedocs.io/en/stable) and isort (https://github.com/timothycrosley/isort).\n\nIt is tested using pytest (https://pytest.org).\n\n# Commit checklist\n\n1. check version both in `pyproject.toml` and `file_replicator/__init__.py`\n1. `git tag`\n1. `isort -rc .`\n1. `black .`\n1. `pytest -v`\n1. update this README.md with the latest output from the tests\n1. update this README.md with the latest output from the --help option\n',
    'author': 'Timothy Corbett-Clark',
    'author_email': 'timothy.corbettclark@gmail.com',
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
