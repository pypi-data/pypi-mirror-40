
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Writing new cytoflow modules</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="next" title="Spinning a new release" href="RELEASE.html" />
    <link rel="prev" title="Project Structure" href="design.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="writing-new-cytoflow-modules">
<span id="new-modules"></span><h1>Writing new <code class="docutils literal notranslate"><span class="pre">cytoflow</span></code> modules</h1>
<p>Creating a new module in <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> ranges from easy (for simple things)
to quite involved.  I like to think that <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> follows the Perl
philosophy of making the easy jobs easy and the hard jobs possible.</p>
<p>With that in mind, let’s look at the process of creating a new module,
progressing from easy to involved.</p>
<div class="section" id="basics">
<h2>Basics</h2>
<p>All the APIs (both public and internal) are built using
<a class="reference external" href="http://docs.enthought.com/traits/">Traits</a>.  For operations and views in
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> package, basic working knowledge of <code class="xref py py-mod docutils literal notranslate"><span class="pre">traits</span></code> is sufficient.
For GUI work, trait notification is used extensively.</p>
<p>The GUI wrappers also use <a class="reference external" href="http://docs/enthought.com/traitsui/">TraitsUI</a>
because it makes wrapping traits with UI elements easy.  Have a look at views,
handlers, and of course the trait editors.</p>
<p>Finally, there are some principles that I expect new modules contributed to this
codebase to follow:</p>
<ul class="simple">
<li><strong>Check for pathological errors and fail early</strong>.  I really dislike the
tendency of a number of libraries to fail with cryptic errors.  (I’m looking at
you, <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/index.html#module-pandas" title="(in pandas v0.23.4)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas</span></code></a>.)  Check for obvious errors and raise a <code class="xref py py-class docutils literal notranslate"><span class="pre">CytoflowOpError</span></code>
or <code class="xref py py-class docutils literal notranslate"><span class="pre">CytoflowViewError</span></code>).  If the problem is non-fatal, warn with
<code class="xref py py-class docutils literal notranslate"><span class="pre">CytoflowOpWarning</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CytoflowViewWarning</span></code>.  The GUI will
also know how to handle these gracefully.</li>
<li><strong>Separate experimental data from module state.</strong>  There are workflow that
require estimating parameters with one data set, then applying those
operations to another.  Make sure your module supports them.</li>
<li><strong>Estimate slow but apply fast.</strong>  The GUI re-runs modules’
<code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> methods automatically when parameters change.
That means that the <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> method must run very quickly.</li>
<li><strong>Write tests.</strong>  I hate writing unit tests, but they are indispensible for
catching bugs.  Even in a view’s tests are just smoke tests (“It plots something
and doesn’t crash”), that’s better than nothing.</li>
</ul>
</div>
<div class="section" id="new-operations">
<span id="new-operation"></span><h2>New operations</h2>
<p>The base operation API is fairly simple:</p>
<ul>
<li><p class="first"><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code> - a required <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Constant</span></code> containing the UID of the operation</p>
</li>
<li><p class="first"><code class="xref py py-attr docutils literal notranslate"><span class="pre">friendly_id</span></code> - a required <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Constant</span></code> containing a human-readable name</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> - takes an <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code> and returns a new
<code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code> with the operation applied.  <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code>
should <code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code> the old experiment, then modify and return the
clone.  Don’t forget to add the operation to the new <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">history</span></code>.  A good example of a simple operation is
<code class="xref py py-class docutils literal notranslate"><span class="pre">RatioOp</span></code>.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code> - You may also wish to estimate
the operation’s parameters from a data set. Crucially, this
<em>may not be the data set you are eventually applying the operation to.</em>  If
your operation relies on estimating parameters, implement the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code> function.  This may involve selecting a subset
of the data in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>, or it may involve loading in an
an additional FCS file. A good example of the former is <code class="xref py py-class docutils literal notranslate"><span class="pre">KMeansOp</span></code>;
a good example of the latter is <code class="xref py py-class docutils literal notranslate"><span class="pre">AutofluorescenceOp</span></code>.</p>
<p>You may also find that you wish to estimate different parameter sets for
different sub-populations (as encoded in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">conditions</span></code>.)  By convention, the conditions that you
want to estimate different parameters for are passed using a trait named
<code class="xref py py-attr docutils literal notranslate"><span class="pre">by</span></code>, which takes a list of conditions and groups the data by unique
combinations of those conditions’ values before estimating a paramater set
for each.  Look at <code class="xref py py-class docutils literal notranslate"><span class="pre">KMeansOp</span></code> for an example of this behavior.</p>
</li>
<li><p class="first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_view()</span></code> - for some operations, you may want to
provide a default view.  This view may just be a base view parameterized in
a particular way (like the <code class="xref py py-class docutils literal notranslate"><span class="pre">HistogramView</span></code> that is the default view of
<code class="xref py py-class docutils literal notranslate"><span class="pre">BinningOp</span></code>), or it may be a visualization of the parameters estimated
by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code> function (like the default view of
<code class="xref py py-class docutils literal notranslate"><span class="pre">AutofluorescenceOp</span></code>.)  In many cases, the view returned by this
function is linked back to the operation that produced it.</p>
</li>
</ul>
</div>
<div class="section" id="new-views">
<span id="new-view"></span><h2>New views</h2>
<p>The base view API is very simple:</p>
<ul class="simple">
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">id</span></code> - a required <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Constant</span></code> containing the UID of the operation</li>
<li><code class="xref py py-attr docutils literal notranslate"><span class="pre">friendly_id</span></code> - a required <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Constant</span></code> containing a human-readable name</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code> - plots <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>.</li>
</ul>
<p>As I wrote more views, however, I noticed a significant amount of code
duplication, which led to bugs and lost time.  So, I refactored the view code
to use a short hierarchy of classes for particular types of views.  You can
take advantage of this functionality when writing a new module, or you can
simply derive your new view from <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.HasTraits</span></code> and implement the
simple API above.</p>
<p>The view base classes are:</p>
<ul class="simple">
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseView</span></code> – implements a view with row, column and hue facets.
After setting up the facet grid, it calls the derived class’s
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_grid_plot()</span></code> to actually do the plotting.  <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code> also
has parameters to set the plot style, legend, axis labels, etc.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseDataView</span></code> – implements a view that plots an <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>’s
data (as opposed to a statistic.)  Includes functionality for subsetting
the data before plotting, and determining axis limits and scales.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">Base1DView</span></code> – implements a 1-dimensional data view.  See
<code class="xref py py-class docutils literal notranslate"><span class="pre">HistogramView</span></code> for an example.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">Base2DView</span></code> – implements a 2-dimensional data view.  See
<code class="xref py py-class docutils literal notranslate"><span class="pre">ScatterplotView</span></code> for an example.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseNDView</span></code> – implements an N-dimensional data view.  See
<code class="xref py py-class docutils literal notranslate"><span class="pre">RadvizView</span></code> for an example.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseStatisticsView</span></code> – implements a view that plots a statistic from
an <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code> (as opposed to the underlying data.)  These views
have a “primary” <code class="xref py py-attr docutils literal notranslate"><span class="pre">variable</span></code>, and can be subset
as well.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">Base1DStatisticsView</span></code> – implements a view that plots one dimension
of a statistic.  See <code class="xref py py-class docutils literal notranslate"><span class="pre">BarChartView</span></code> for an example.</li>
<li><code class="xref py py-class docutils literal notranslate"><span class="pre">Base2DStatisticsView</span></code> – implements a view that plots two dimensions
of a statistic.  See <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats2DView</span></code> for an example.</li>
</ul>
</div>
<div class="section" id="new-gui-operations">
<span id="new-operation-plugin"></span><h2>New GUI operations</h2>
<p>Wrapping an operation for the GUI sometimes feels like it requires more work
than writing the operation in the first place.  A new operation requires at
least five things:</p>
<ul class="simple">
<li>A plugin class implementing <code class="xref py py-class docutils literal notranslate"><span class="pre">IOperationPlugin</span></code>.  It should
also derive from <code class="xref py py-class docutils literal notranslate"><span class="pre">PluginHelpMixin</span></code>, which adds support for online help.</li>
<li>A class derived from the underlying <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> operation.  The derived
operation should:<ul>
<li>Inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">PluginOpMixin</span></code> to add support for various GUI
event-handling bits</li>
<li>Override attributes in the underlying <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> class to add
metadata that tells the GUI how to react to changes.  (See the
<code class="xref py py-class docutils literal notranslate"><span class="pre">PluginOpMixin</span></code> docstring for details.)</li>
<li>Override the <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_factory</span></code> attribute to be a callable that returns
an <code class="xref py py-class docutils literal notranslate"><span class="pre">OpHandlerMixin</span></code> instance.</li>
<li>Provide an implementation of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_notebook_code()</span></code>, to
support exporting to Jupyter notebook.</li>
<li>If the module has an <code class="xref py py-meth docutils literal notranslate"><span class="pre">estimate()</span></code> method, then implement
<code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_estimate()</span></code> to clear those parameters.</li>
<li>If the module has a <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_view()</span></code> method, it should be overridden
to return a GUI-enabled view class (see below.)</li>
<li>Optionally, override <code class="xref py py-meth docutils literal notranslate"><span class="pre">should_apply()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">should_clear_estimate()</span></code> to only do expensive operations
when necessary.</li>
</ul>
</li>
<li>A handler class that defines the default <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.View</span></code> and provides
supporting logic.  This class should be derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">OpHandlerMixin</span></code>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Controller</span></code>.</li>
<li>Serialization logic.  <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> uses <code class="xref py py-mod docutils literal notranslate"><span class="pre">camel</span></code> for sane YAML
serialization; a dumper and loader for the class must save and load the
operation’s parameters.</li>
<li>Tests.  Because of <a class="reference internal" href="cytoflowgui.html#module-cytoflowgui" title="cytoflowgui"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflowgui</span></code></a>’s split between processes, testing
GUI logic for modules can be kind of a synchronization nightmare.  This is
by design – because the same synchronization issues are present when
running the software.  See the <code class="docutils literal notranslate"><span class="pre">cytoflowgui/tests</span></code> directory for (many)
examples.</li>
<li>(Optionally) default view implementations.  If the operation has a default
view, you should wrap it as well (in the operation plugin module.)  See the
next section for details.</li>
</ul>
</div>
<div class="section" id="new-gui-views">
<span id="new-view-plugin"></span><h2>New GUI views</h2>
<p>A new view operation requires at least five things:</p>
<ul class="simple">
<li>A plugin class implementing either <code class="xref py py-class docutils literal notranslate"><span class="pre">IViewPlugin</span></code>.  It should
also derive from <code class="xref py py-class docutils literal notranslate"><span class="pre">PluginHelpMixin</span></code>, which adds support for online help.</li>
<li>A class derived from the underlying <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> view.  The derived
view should:<ul>
<li>Inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">PluginViewMixin</span></code> to add support for various GUI
event-handling bits</li>
<li>Override attributes in the underlying <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> class to add
metadata that tells the GUI how to react to changes.  (See the
<code class="xref py py-class docutils literal notranslate"><span class="pre">PluginViewMixin</span></code> docstring for details.)</li>
<li>Override the <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_factory</span></code> attribute to be a
callable that returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">ViewHandlerMixin</span></code> instance.</li>
<li>Provide an implementation of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_notebook_code()</span></code>, to
support exporting to Jupyter notebook.</li>
<li>Override the <code class="xref py py-attr docutils literal notranslate"><span class="pre">plot_params</span></code> attribute with an instance
of an object containing plot parameters (see below).</li>
<li>Optionally, override <code class="xref py py-meth docutils literal notranslate"><span class="pre">should_plot()</span></code> to only plot when
necessary.</li>
<li>Optionally, overide <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_wi()</span></code> to change whether
<code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code> is called on the current <code class="xref py py-class docutils literal notranslate"><span class="pre">WorkflowItem</span></code>’s result or
the previous one’s.</li>
</ul>
</li>
<li>A handler class that defines the default <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.View</span></code> and provides
supporting logic.  This class should be derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">ViewHandlerMixin</span></code>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.Controller</span></code>.</li>
<li>Serialization logic.  <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> uses <code class="xref py py-mod docutils literal notranslate"><span class="pre">camel</span></code> for sane YAML
serialization; a dumper and loader for the class must save and load the
operation’s parameters.</li>
<li>Plot parameters.  The parameters to a view’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code> method are stored
in an object that derives from <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePlotParams</span></code> or one of its
decendants.  Choose data types that are appropriate for the view, and
include a default view.  Set it as the class type for the view’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">plot_params</span></code>
attribute.  Don’t forget to write serialization code for it as well!</li>
<li>Tests.  Because of <a class="reference internal" href="cytoflowgui.html#module-cytoflowgui" title="cytoflowgui"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflowgui</span></code></a>’s split between processes, testing
GUI logic for modules can be kind of a synchronization nightmare.  This is
by design – because the same synchronization issues are present when
running the software.  See the <code class="docutils literal notranslate"><span class="pre">cytoflowgui/tests</span></code> directory for (many)
examples.  In the case of a view, most of these are “smoke tests”, testing
that the view doesn’t crash with various sets of parameters.</li>
</ul>
</div>
</div>


          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
    </div>

    

    
  </body>
</html>