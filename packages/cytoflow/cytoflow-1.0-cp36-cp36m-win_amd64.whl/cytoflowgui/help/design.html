
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Project Structure</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="next" title="Writing new cytoflow modules" href="new_modules.html" />
    <link rel="prev" title="Installation notes" href="INSTALL.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="project-structure">
<span id="design"></span><h1>Project Structure</h1>
<p>The source is organized into two main components.</p>
<ul class="simple">
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> package.  This package contains the actual tools for
operating on cytometry data.  Key modules and subpackages:<ul>
<li>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code> class is the primary container for cytometry data. See
the module docstrings for its use.  Modify this class’s API only with care,
please!</li>
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow.operations</span></code> subpackage.  This is where operations on data go, like
transformations and gates.  Adding a new operation is quite straightforward:
see the documentation for <a class="reference internal" href="new_modules.html#new-operation"><span class="std std-ref">adding a new operation</span></a>.</li>
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow.views</span></code> subpackage.  This is where visualizations go.  These can be
traditional visualizations (dotplots, histograms); or statistical summary
views (bar plots of population means).  There is a significant amount of
class hierarchy here – see the documentation for <a class="reference internal" href="new_modules.html#new-view"><span class="std std-ref">adding a new view</span></a>.</li>
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow.utility</span></code> subpackage.  Useful functions and classes, like
<code class="xref py py-meth docutils literal notranslate"><span class="pre">geom_mean()</span></code>.</li>
</ul>
</li>
<li>The <a class="reference internal" href="cytoflowgui.html#module-cytoflowgui" title="cytoflowgui"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflowgui</span></code></a> package.  Implements the GUI.<ul>
<li>The <a class="reference internal" href="cytoflowgui.op_plugins.html#module-cytoflowgui.op_plugins" title="cytoflowgui.op_plugins"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflowgui.op_plugins</span></code></a> subpackage.  Contains instances of
<code class="xref py py-class docutils literal notranslate"><span class="pre">envisage.Plugin</span></code> that wrap the operations.  See the documentation
for <a class="reference internal" href="new_modules.html#new-operation-plugin"><span class="std std-ref">adding a new operation GUI plugin</span></a>.</li>
<li>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflowgui.op_views</span></code> subpackage.  Contains instances of
<code class="xref py py-class docutils literal notranslate"><span class="pre">envisage.Plugin</span></code> that wrap the views.  See the documentation if you
want to <a class="reference internal" href="new_modules.html#new-view-plugin"><span class="std std-ref">add a new view GUI plugin</span></a>.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="design-decisions-justifications">
<h1>Design decisions &amp; justifications</h1>
<ul>
<li><p class="first">Cytometry analysis as a workflow – an analysis is a set of operations
applied sequentially to a dataset.  I think this is kind of obvious; it just
formalizes the way of doing things that everyone else pretty much already
uses.</p>
</li>
<li><p class="first">Instead of keeping “tubes” or “wells” as first-class objects, represent all
the events from all the samples as a big long <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v0.23.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a>,
distinguishing events from different tubes via their varying experimental conditions.  Most
of my flow analysis experience is with the R Bioconductor package’s flowCore,
which treats tubes as first-class objects akin to separate microarrays.
That’s fine if you’ve got just a few tubes (or a few microarrays), but it
rapidly gets cumbersome if you’ve got multiple plates of samples, each plate
of which has two or three experimental variables; I ended up spending more
time and code specifying metadata than I did actually doing analysis.</p>
<p>Cytoflow pushes the metadata down to the event level, doing away entirely
with the concept of tubes or wells (after you get your data imported, of
course.)  This hews much more closely to Hadley Wickham’s concept of <a class="reference external" href="http://vita.had.co.nz/papers/tidy-data.pdf">Tidy
Data</a>, and is also (!) much
easier to vectorize computations on using <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/index.html#module-pandas" title="(in pandas v0.23.4)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas</span></code></a> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> and
<code class="xref py py-mod docutils literal notranslate"><span class="pre">numexpr</span></code>. Now, you can access all the events that are, say
Dox-induced, by just saying <code class="docutils literal notranslate"><span class="pre">experiment['Dox']</span></code> without having to keep
track of which tubes are induced and which weren’t.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you have tubes that are replicates, just add another experimental
condition, perhaps called “replicate”.  You can specify that condition to the
statistics views to get a standard error.</p>
</div>
</li>
<li><p class="first">Gates don’t actually subset data (delete or copy it); they just add metadata.
I struggled for a long time with the question of how to store and manipulate
different subsets of data after gating.  Again, my own experience is with
Bioconductor’s <code class="docutils literal notranslate"><span class="pre">flowCore</span></code>, which defines a tree structure by data that is
included or excluded by gates; if a node is a gate, then its children are the
subpopulations produced by that gate. Navigating that tree, though, is really
difficult, especially if you want to re-combine data after gating (for
plotting, for example.)</p>
<p>Then there was the issue of how to track and manipulate this structure as
additional operations were performed.  Keep just a single copy and operate on
it in-place?  Or copy the output of one operation for the input of the next,
with the space penalties that implies?</p>
<p>I finally realized I didn’t have to choose; when you copy a
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v0.23.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a>, you get a “shallow” copy, with the actual data just
linked to by reference.  This was perfect; if I needed to transform the data
from one copy to another, I could just replace the transformed channels; and
“gating” events didn’t have to create new subsets or containers, it could
just add another column specifying the gate membership of each event.</p>
</li>
<li><p class="first"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code> discourages wholesale transformation of the underlying data, ie.
taking the log of the data set.  This is of a part with <code class="xref py py-mod docutils literal notranslate"><span class="pre">cytoflow</span></code>
enabling <em>quantitative</em> analysis – if you want a measure of center of data
that is log-normal, you should use the geometric mean instead of log-transforming
and taking the arithmetic mean.  It is frequently useful to transform data
before viewing it, or gating it, etc – those transformations can be passed
as parameters to the view modules.</p>
<p>The obvious exceptions here, of course, are things like bleedthrough
correction and calibration using beads. These operations transform the data,
but they don’t cause the same sorts of shift in data <em>structure</em> you see with
a log transform.  Data that is distributed log-normally before bleedthrough
correction, will be distributed log-normally after.</p>
</li>
<li><p class="first">Easy computation and plotting of summary statistics.  The
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChannelStatisticOp</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">FrameStatisticOp</span></code> operations create
new statistics and add them to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Experiment.statistics</span></code>; and
<code class="xref py py-class docutils literal notranslate"><span class="pre">BarChartView</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats1DView</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats2DView</span></code> make
it easy to plot them.  (A statistic is just a <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html#pandas.Series" title="(in pandas v0.23.4)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code></a> with a
hierarchical index that encodes data subsets and the value of a summary
statistic for each group.)  This may be more useful in the GUI, because
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby" title="(in pandas v0.23.4)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby()</span></code></a> provides similar functionality in a
notebook setting.</p>
</li>
<li><p class="first">As is made pretty clear in the example Jupyter notebooks, the semantics for
views and operations are</p>
<ol class="arabic simple">
<li>Instantiate a new operation or view</li>
<li>Parameterize the operation or view (possibly by estimating parameters from
a provided data set).</li>
<li>Apply the operation or view to an <code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code>.
If applying an operation, <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> returns a new Experiment.</li>
</ol>
<p>The justification for these semantics is that it makes the <em>state</em> of the
interacting objects really obvious.  An operation or view’s state doesn’t
depend on the data it’s applied to; if its parameters do depend on data,
those parameters’ estimation is a separate operation.</p>
<p>It also allows for ready separation of the workflow from the data it’s
applied to, allowing for easy sharing of workflows.</p>
</li>
<li><p class="first">The module attributes have been replaced by Traits.  See the <a class="reference external" href="http://docs.enthought.com/traits/">Traits
documentation</a> for a good overview, but
in short they give Python some of the benefits of statically typed languages
like Java, without much of the mess that a fully statically typed language
incurs.  Their power doesn’t see a whole lot of use internal to the cytoflow
package, but they make writing the GUI layer a <strong>whole</strong> lot easier.</p>
</li>
<li><p class="first">The design of the views are strongly influenced by best-in-class statistics
visualization packages from R: <code class="docutils literal notranslate"><span class="pre">lattice</span></code> and <code class="docutils literal notranslate"><span class="pre">ggplot</span></code>.  If your data is
<a class="reference external" href="http://vita.had.co.nz/papers/tidy-data.pdf">tidy</a>, then each experimental
variable you want to plot differently so you can compare them is called a
“facet”. For example, a facet might be a timepoint or an inducer level (ie an
experimental condition); it might also be some metadata added by an operation
(ie gate membership or bin).  Then, you plot the dataset broken down in
various ways by its facets: for example, each timepoint might be put on its
own subplot, while each Dox level might be represented by a different color.
(Check out <a class="reference external" href="https://github.com/bpteague/cytoflow/blob/master/docs/examples-basic/Basic%20Cytometry.ipynb">the example Jupyter notebook</a>
if this is confusing.</p>
</li>
</ul>
</div>


          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      
      
    </div>

    

    
  </body>
</html>