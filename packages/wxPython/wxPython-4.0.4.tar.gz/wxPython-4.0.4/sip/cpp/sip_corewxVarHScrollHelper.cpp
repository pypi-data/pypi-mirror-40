/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/vscroll.h>

        #include <wx/window.h>
    #include <wxPython/wxpy_api.h>


class sipwxVarHScrollHelper : public  ::wxVarHScrollHelper
{
public:
    sipwxVarHScrollHelper( ::wxWindow*);
    sipwxVarHScrollHelper(const  ::wxVarHScrollHelper&);
    virtual ~sipwxVarHScrollHelper();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::wxCoord sipProtectVirt_EstimateTotalWidth(bool) const;
    void sipProtectVirt_OnGetColumnsWidthHint(bool, ::size_t, ::size_t) const;
     ::wxCoord sipProtect_OnGetColumnWidth( ::size_t) const;
    void sipProtectVirt_OnGetUnitsSizeHint(bool, ::size_t, ::size_t) const;
     ::wxCoord sipProtectVirt_EstimateTotalSize(bool) const;
    int sipProtectVirt_GetNonOrientationTargetSize(bool) const;
     ::wxOrientation sipProtectVirt_GetOrientation(bool) const;
    int sipProtectVirt_GetOrientationTargetSize(bool) const;
     ::wxCoord sipProtectVirt_OnGetUnitSize(bool, ::size_t) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::wxCoord OnGetColumnWidth( ::size_t) const;
    void OnGetColumnsWidthHint( ::size_t, ::size_t) const;
     ::wxCoord EstimateTotalWidth() const;
    bool ScrollColumns(int);
    bool ScrollColumnPages(int);
    void RefreshColumns( ::size_t, ::size_t);
    void RefreshColumn( ::size_t);
    int GetNonOrientationTargetSize() const;
     ::wxOrientation GetOrientation() const;
    int GetOrientationTargetSize() const;
    void OnGetUnitsSizeHint( ::size_t, ::size_t) const;
     ::wxCoord EstimateTotalSize() const;
     ::wxCoord OnGetUnitSize( ::size_t) const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxVarHScrollHelper(const sipwxVarHScrollHelper &);
    sipwxVarHScrollHelper &operator = (const sipwxVarHScrollHelper &);

    char sipPyMethods[13];
};

sipwxVarHScrollHelper::sipwxVarHScrollHelper( ::wxWindow*winToScroll):  ::wxVarHScrollHelper(winToScroll), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxVarHScrollHelper::sipwxVarHScrollHelper(const  ::wxVarHScrollHelper& a0):  ::wxVarHScrollHelper(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxVarHScrollHelper::~sipwxVarHScrollHelper()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

 ::wxCoord sipwxVarHScrollHelper::OnGetColumnWidth( ::size_t column) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,sipName_VarHScrollHelper,sipName_OnGetColumnWidth);

    if (!sipMeth)
        return 0;

    extern  ::wxCoord sipVH__core_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    return sipVH__core_134(sipGILState, 0, sipPySelf, sipMeth, column);
}

void sipwxVarHScrollHelper::OnGetColumnsWidthHint( ::size_t columnMin, ::size_t columnMax) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_OnGetColumnsWidthHint);

    if (!sipMeth)
    {
         ::wxVarHScrollHelper::OnGetColumnsWidthHint(columnMin,columnMax);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, columnMin, columnMax);
}

 ::wxCoord sipwxVarHScrollHelper::EstimateTotalWidth() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,NULL,sipName_EstimateTotalWidth);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::EstimateTotalWidth();

    extern  ::wxCoord sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxVarHScrollHelper::ScrollColumns(int columns)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_ScrollColumns);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::ScrollColumns(columns);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, columns);
}

bool sipwxVarHScrollHelper::ScrollColumnPages(int pages)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_ScrollColumnPages);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::ScrollColumnPages(pages);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, pages);
}

void sipwxVarHScrollHelper::RefreshColumns( ::size_t from_, ::size_t to_)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_RefreshColumns);

    if (!sipMeth)
    {
         ::wxVarHScrollHelper::RefreshColumns(from_,to_);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

void sipwxVarHScrollHelper::RefreshColumn( ::size_t column)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_RefreshColumn);

    if (!sipMeth)
    {
         ::wxVarHScrollHelper::RefreshColumn(column);
        return;
    }

    extern void sipVH__core_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    sipVH__core_135(sipGILState, 0, sipPySelf, sipMeth, column);
}

int sipwxVarHScrollHelper::GetNonOrientationTargetSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,NULL,sipName_GetNonOrientationTargetSize);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::GetNonOrientationTargetSize();

    extern int sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxOrientation sipwxVarHScrollHelper::GetOrientation() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[8]),sipPySelf,NULL,sipName_GetOrientation);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::GetOrientation();

    extern  ::wxOrientation sipVH__core_132(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_132(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxVarHScrollHelper::GetOrientationTargetSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[9]),sipPySelf,NULL,sipName_GetOrientationTargetSize);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::GetOrientationTargetSize();

    extern int sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxVarHScrollHelper::OnGetUnitsSizeHint( ::size_t unitMin, ::size_t unitMax) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[10]),sipPySelf,NULL,sipName_OnGetUnitsSizeHint);

    if (!sipMeth)
    {
         ::wxVarHScrollHelper::OnGetUnitsSizeHint(unitMin,unitMax);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, unitMin, unitMax);
}

 ::wxCoord sipwxVarHScrollHelper::EstimateTotalSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[11]),sipPySelf,NULL,sipName_EstimateTotalSize);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::EstimateTotalSize();

    extern  ::wxCoord sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxCoord sipwxVarHScrollHelper::OnGetUnitSize( ::size_t unit) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[12]),sipPySelf,NULL,sipName_OnGetUnitSize);

    if (!sipMeth)
        return  ::wxVarHScrollHelper::OnGetUnitSize(unit);

    extern  ::wxCoord sipVH__core_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    return sipVH__core_134(sipGILState, 0, sipPySelf, sipMeth, unit);
}

 ::wxCoord sipwxVarHScrollHelper::sipProtectVirt_EstimateTotalWidth(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::EstimateTotalWidth() : EstimateTotalWidth());
}

void sipwxVarHScrollHelper::sipProtectVirt_OnGetColumnsWidthHint(bool sipSelfWasArg, ::size_t columnMin, ::size_t columnMax) const
{
    (sipSelfWasArg ?  ::wxVarHScrollHelper::OnGetColumnsWidthHint(columnMin,columnMax) : OnGetColumnsWidthHint(columnMin,columnMax));
}

 ::wxCoord sipwxVarHScrollHelper::sipProtect_OnGetColumnWidth( ::size_t column) const
{
    return OnGetColumnWidth(column);
}

void sipwxVarHScrollHelper::sipProtectVirt_OnGetUnitsSizeHint(bool sipSelfWasArg, ::size_t unitMin, ::size_t unitMax) const
{
    (sipSelfWasArg ?  ::wxVarHScrollHelper::OnGetUnitsSizeHint(unitMin,unitMax) : OnGetUnitsSizeHint(unitMin,unitMax));
}

 ::wxCoord sipwxVarHScrollHelper::sipProtectVirt_EstimateTotalSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::EstimateTotalSize() : EstimateTotalSize());
}

int sipwxVarHScrollHelper::sipProtectVirt_GetNonOrientationTargetSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::GetNonOrientationTargetSize() : GetNonOrientationTargetSize());
}

 ::wxOrientation sipwxVarHScrollHelper::sipProtectVirt_GetOrientation(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::GetOrientation() : GetOrientation());
}

int sipwxVarHScrollHelper::sipProtectVirt_GetOrientationTargetSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::GetOrientationTargetSize() : GetOrientationTargetSize());
}

 ::wxCoord sipwxVarHScrollHelper::sipProtectVirt_OnGetUnitSize(bool sipSelfWasArg, ::size_t unit) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::OnGetUnitSize(unit) : OnGetUnitSize(unit));
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetColumnCount, "GetColumnCount() -> size_t\n"
"\n"
"Returns the number of columns the target window contains.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetColumnCount(PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetColumnCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetColumnCount());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetColumnCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetVisibleColumnsBegin, "GetVisibleColumnsBegin() -> size_t\n"
"\n"
"Returns the index of the first visible column based on the scroll\n"
"position.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetVisibleColumnsBegin(PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetVisibleColumnsBegin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetVisibleColumnsBegin());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetVisibleColumnsBegin, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetVisibleColumnsEnd, "GetVisibleColumnsEnd() -> size_t\n"
"\n"
"Returns the index of the last visible column based on the scroll\n"
"position.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetVisibleColumnsEnd(PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetVisibleColumnsEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetVisibleColumnsEnd());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetVisibleColumnsEnd, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_IsColumnVisible, "IsColumnVisible(column) -> bool\n"
"\n"
"Returns true if the given column is currently visible (even if only\n"
"partially visible) or false otherwise.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_IsColumnVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_IsColumnVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* column;
        int columnState = 0;
        const  ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&column, &columnState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsColumnVisible(*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_IsColumnVisible, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_RefreshColumn, "RefreshColumn(column)\n"
"\n"
"Triggers a refresh for just the given column's area of the window if\n"
"it's visible.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_RefreshColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_RefreshColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* column;
        int columnState = 0;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&column, &columnState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHScrollHelper::RefreshColumn(*column) : sipCpp->RefreshColumn(*column));
            Py_END_ALLOW_THREADS
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_RefreshColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_RefreshColumns, "RefreshColumns(from_, to_)\n"
"\n"
"Triggers a refresh for the area between the specified range of columns\n"
"given (inclusively).");

extern "C" {static PyObject *meth_wxVarHScrollHelper_RefreshColumns(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_RefreshColumns(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* from_;
        int from_State = 0;
         ::size_t* to_;
        int to_State = 0;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from_,
            sipName_to_,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&from_, &from_State, sipType_size_t,&to_, &to_State))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHScrollHelper::RefreshColumns(*from_,*to_) : sipCpp->RefreshColumns(*from_,*to_));
            Py_END_ALLOW_THREADS
            sipReleaseType(from_,sipType_size_t,from_State);
            sipReleaseType(to_,sipType_size_t,to_State);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_RefreshColumns, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_ScrollColumnPages, "ScrollColumnPages(pages) -> bool\n"
"\n"
"Scroll by the specified number of pages which may be positive (to\n"
"scroll right) or negative (to scroll left).");

extern "C" {static PyObject *meth_wxVarHScrollHelper_ScrollColumnPages(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_ScrollColumnPages(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int pages;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pages,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, &pages))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxVarHScrollHelper::ScrollColumnPages(pages) : sipCpp->ScrollColumnPages(pages));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_ScrollColumnPages, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_ScrollColumns, "ScrollColumns(columns) -> bool\n"
"\n"
"Scroll by the specified number of columns which may be positive (to\n"
"scroll right) or negative (to scroll left).");

extern "C" {static PyObject *meth_wxVarHScrollHelper_ScrollColumns(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_ScrollColumns(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int columns;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_columns,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, &columns))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxVarHScrollHelper::ScrollColumns(columns) : sipCpp->ScrollColumns(columns));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_ScrollColumns, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_ScrollToColumn, "ScrollToColumn(column) -> bool\n"
"\n"
"Scroll to the specified column.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_ScrollToColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_ScrollToColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* column;
        int columnState = 0;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&column, &columnState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollToColumn(*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_ScrollToColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_SetColumnCount, "SetColumnCount(columnCount)\n"
"\n"
"Set the number of columns the window contains.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_SetColumnCount(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_SetColumnCount(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* columnCount;
        int columnCountState = 0;
         ::wxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_columnCount,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&columnCount, &columnCountState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColumnCount(*columnCount);
            Py_END_ALLOW_THREADS
            sipReleaseType(columnCount,sipType_size_t,columnCountState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_SetColumnCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_EstimateTotalWidth, "EstimateTotalWidth() -> Coord\n"
"\n"
"This class forwards calls from EstimateTotalSize() to this function so\n"
"derived classes can override either just the height or the width\n"
"estimation, or just estimate both differently if desired in any\n"
"wxHVScrolledWindow derived class.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_EstimateTotalWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_EstimateTotalWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_EstimateTotalWidth(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_EstimateTotalWidth, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_OnGetColumnsWidthHint, "OnGetColumnsWidthHint(columnMin, columnMax)\n"
"\n"
"This function doesn't have to be overridden but it may be useful to do\n"
"so if calculating the columns' sizes is a relatively expensive\n"
"operation as it gives your code a chance to calculate several of them\n"
"at once and cache the result if necessary.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_OnGetColumnsWidthHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_OnGetColumnsWidthHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* columnMin;
        int columnMinState = 0;
         ::size_t* columnMax;
        int columnMaxState = 0;
        const sipwxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_columnMin,
            sipName_columnMax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&columnMin, &columnMinState, sipType_size_t,&columnMax, &columnMaxState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_OnGetColumnsWidthHint(sipSelfWasArg,*columnMin,*columnMax);
            Py_END_ALLOW_THREADS
            sipReleaseType(columnMin,sipType_size_t,columnMinState);
            sipReleaseType(columnMax,sipType_size_t,columnMaxState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_OnGetColumnsWidthHint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_OnGetColumnWidth, "OnGetColumnWidth(column) -> Coord\n"
"\n"
"This function must be overridden in the derived class, and should\n"
"return the width of the given column in pixels.");

extern "C" {static PyObject *meth_wxVarHScrollHelper_OnGetColumnWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_OnGetColumnWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::size_t* column;
        int columnState = 0;
        const sipwxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&column, &columnState))
        {
             ::wxCoord sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_VarHScrollHelper, sipName_OnGetColumnWidth);
                return NULL;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_OnGetColumnWidth(*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_OnGetColumnWidth, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_OnGetUnitsSizeHint, "OnGetUnitsSizeHint(self, unitMin: object, unitMax: object)");

extern "C" {static PyObject *meth_wxVarHScrollHelper_OnGetUnitsSizeHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_OnGetUnitsSizeHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* unitMin;
        int unitMinState = 0;
         ::size_t* unitMax;
        int unitMaxState = 0;
        const sipwxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_unitMin,
            sipName_unitMax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&unitMin, &unitMinState, sipType_size_t,&unitMax, &unitMaxState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_OnGetUnitsSizeHint(sipSelfWasArg,*unitMin,*unitMax);
            Py_END_ALLOW_THREADS
            sipReleaseType(unitMin,sipType_size_t,unitMinState);
            sipReleaseType(unitMax,sipType_size_t,unitMaxState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_OnGetUnitsSizeHint, doc_wxVarHScrollHelper_OnGetUnitsSizeHint);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_EstimateTotalSize, "EstimateTotalSize(self) -> int");

extern "C" {static PyObject *meth_wxVarHScrollHelper_EstimateTotalSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_EstimateTotalSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_EstimateTotalSize(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_EstimateTotalSize, doc_wxVarHScrollHelper_EstimateTotalSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetNonOrientationTargetSize, "GetNonOrientationTargetSize(self) -> int");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetNonOrientationTargetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetNonOrientationTargetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetNonOrientationTargetSize(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetNonOrientationTargetSize, doc_wxVarHScrollHelper_GetNonOrientationTargetSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetOrientation, "GetOrientation(self) -> Orientation");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetOrientation(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetOrientation(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
             ::wxOrientation sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetOrientation(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxOrientation);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetOrientation, doc_wxVarHScrollHelper_GetOrientation);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_GetOrientationTargetSize, "GetOrientationTargetSize(self) -> int");

extern "C" {static PyObject *meth_wxVarHScrollHelper_GetOrientationTargetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_GetOrientationTargetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetOrientationTargetSize(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_GetOrientationTargetSize, doc_wxVarHScrollHelper_GetOrientationTargetSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHScrollHelper_OnGetUnitSize, "OnGetUnitSize(self, unit: object) -> int");

extern "C" {static PyObject *meth_wxVarHScrollHelper_OnGetUnitSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHScrollHelper_OnGetUnitSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* unit;
        int unitState = 0;
        const sipwxVarHScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_unit,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHScrollHelper, &sipCpp, sipType_size_t,&unit, &unitState))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_OnGetUnitSize(sipSelfWasArg,*unit);
            Py_END_ALLOW_THREADS
            sipReleaseType(unit,sipType_size_t,unitState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHScrollHelper, sipName_OnGetUnitSize, doc_wxVarHScrollHelper_OnGetUnitSize);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxVarHScrollHelper(void *, const sipTypeDef *);}
static void *cast_wxVarHScrollHelper(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxVarHScrollHelper *sipCpp = reinterpret_cast< ::wxVarHScrollHelper *>(sipCppV);

    if (targetType == sipType_wxVarScrollHelperBase)
        return static_cast< ::wxVarScrollHelperBase *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxVarHScrollHelper(void *, int);}
static void release_wxVarHScrollHelper(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxVarHScrollHelper *>(sipCppV);
    else
        delete reinterpret_cast< ::wxVarHScrollHelper *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxVarHScrollHelper(sipSimpleWrapper *);}
static void dealloc_wxVarHScrollHelper(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxVarHScrollHelper *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxVarHScrollHelper(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxVarHScrollHelper(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxVarHScrollHelper(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxVarHScrollHelper *sipCpp = 0;

    {
         ::wxWindow* winToScroll;

        static const char *sipKwdList[] = {
            sipName_winToScroll,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8", sipType_wxWindow, &winToScroll))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxVarHScrollHelper(winToScroll);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::wxVarHScrollHelper* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_wxVarHScrollHelper, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxVarHScrollHelper(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxVarHScrollHelper[] = {{563, 255, 1}};


static PyMethodDef methods_wxVarHScrollHelper[] = {
    {SIP_MLNAME_CAST(sipName_EstimateTotalSize), (PyCFunction)meth_wxVarHScrollHelper_EstimateTotalSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_EstimateTotalSize)},
    {SIP_MLNAME_CAST(sipName_EstimateTotalWidth), (PyCFunction)meth_wxVarHScrollHelper_EstimateTotalWidth, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_EstimateTotalWidth)},
    {SIP_MLNAME_CAST(sipName_GetColumnCount), meth_wxVarHScrollHelper_GetColumnCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetColumnCount)},
    {SIP_MLNAME_CAST(sipName_GetNonOrientationTargetSize), (PyCFunction)meth_wxVarHScrollHelper_GetNonOrientationTargetSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetNonOrientationTargetSize)},
    {SIP_MLNAME_CAST(sipName_GetOrientation), (PyCFunction)meth_wxVarHScrollHelper_GetOrientation, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetOrientation)},
    {SIP_MLNAME_CAST(sipName_GetOrientationTargetSize), (PyCFunction)meth_wxVarHScrollHelper_GetOrientationTargetSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetOrientationTargetSize)},
    {SIP_MLNAME_CAST(sipName_GetVisibleColumnsBegin), meth_wxVarHScrollHelper_GetVisibleColumnsBegin, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetVisibleColumnsBegin)},
    {SIP_MLNAME_CAST(sipName_GetVisibleColumnsEnd), meth_wxVarHScrollHelper_GetVisibleColumnsEnd, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_GetVisibleColumnsEnd)},
    {SIP_MLNAME_CAST(sipName_IsColumnVisible), (PyCFunction)meth_wxVarHScrollHelper_IsColumnVisible, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_IsColumnVisible)},
    {SIP_MLNAME_CAST(sipName_OnGetColumnWidth), (PyCFunction)meth_wxVarHScrollHelper_OnGetColumnWidth, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_OnGetColumnWidth)},
    {SIP_MLNAME_CAST(sipName_OnGetColumnsWidthHint), (PyCFunction)meth_wxVarHScrollHelper_OnGetColumnsWidthHint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_OnGetColumnsWidthHint)},
    {SIP_MLNAME_CAST(sipName_OnGetUnitSize), (PyCFunction)meth_wxVarHScrollHelper_OnGetUnitSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_OnGetUnitSize)},
    {SIP_MLNAME_CAST(sipName_OnGetUnitsSizeHint), (PyCFunction)meth_wxVarHScrollHelper_OnGetUnitsSizeHint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_OnGetUnitsSizeHint)},
    {SIP_MLNAME_CAST(sipName_RefreshColumn), (PyCFunction)meth_wxVarHScrollHelper_RefreshColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_RefreshColumn)},
    {SIP_MLNAME_CAST(sipName_RefreshColumns), (PyCFunction)meth_wxVarHScrollHelper_RefreshColumns, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_RefreshColumns)},
    {SIP_MLNAME_CAST(sipName_ScrollColumnPages), (PyCFunction)meth_wxVarHScrollHelper_ScrollColumnPages, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_ScrollColumnPages)},
    {SIP_MLNAME_CAST(sipName_ScrollColumns), (PyCFunction)meth_wxVarHScrollHelper_ScrollColumns, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_ScrollColumns)},
    {SIP_MLNAME_CAST(sipName_ScrollToColumn), (PyCFunction)meth_wxVarHScrollHelper_ScrollToColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_ScrollToColumn)},
    {SIP_MLNAME_CAST(sipName_SetColumnCount), (PyCFunction)meth_wxVarHScrollHelper_SetColumnCount, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHScrollHelper_SetColumnCount)}
};

sipVariableDef variables_wxVarHScrollHelper[] = {
    {PropertyVariable, sipName_VisibleColumnsEnd, &methods_wxVarHScrollHelper[7], NULL, NULL, NULL},
    {PropertyVariable, sipName_VisibleColumnsBegin, &methods_wxVarHScrollHelper[6], NULL, NULL, NULL},
    {PropertyVariable, sipName_ColumnCount, &methods_wxVarHScrollHelper[2], &methods_wxVarHScrollHelper[18], NULL, NULL},
};

PyDoc_STRVAR(doc_wxVarHScrollHelper, "VarHScrollHelper(winToScroll)\n"
"\n"
"This class provides functions wrapping the wxVarScrollHelperBase\n"
"class, targeted for horizontal-specific scrolling.");


sipClassTypeDef sipTypeDef__core_wxVarHScrollHelper = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_wxVarHScrollHelper,
        {0},
        0
    },
    {
        sipNameNr_VarHScrollHelper,
        {0, 0, 1},
        19, methods_wxVarHScrollHelper,
        0, 0,
        3, variables_wxVarHScrollHelper,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxVarHScrollHelper,
    -1,
    -1,
    supers_wxVarHScrollHelper,
    0,
    init_type_wxVarHScrollHelper,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxVarHScrollHelper,
    0,
    0,
    0,
    release_wxVarHScrollHelper,
    cast_wxVarHScrollHelper,
    0,
    0,
    0,
    0,
    0,
    0
};
