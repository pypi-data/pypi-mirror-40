/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/menu.h>

        #include <wx/menuitem.h>
        #include <wx/menu.h>
        #include <wx/window.h>
        #include <wx/event.h>
    #include <wxPython/wxpy_api.h>
        
        #include <wx/event.h>
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    wxMenuItem* _wxMenu_FindItemById(const wxMenu* self, int id)
    {
        return self->FindItem(id);
    }


class sipwxMenu : public  ::wxMenu
{
public:
    sipwxMenu();
    sipwxMenu(long);
    sipwxMenu(const  ::wxString&,long);
    virtual ~sipwxMenu();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool ProcessEvent( ::wxEvent&);
    bool TryBefore( ::wxEvent&);
    bool TryAfter( ::wxEvent&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxMenu(const sipwxMenu &);
    sipwxMenu &operator = (const sipwxMenu &);

    char sipPyMethods[3];
};

sipwxMenu::sipwxMenu():  ::wxMenu(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxMenu::sipwxMenu(long style):  ::wxMenu(style), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxMenu::sipwxMenu(const  ::wxString& title,long style):  ::wxMenu(title,style), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxMenu::~sipwxMenu()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipwxMenu::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxMenu::ProcessEvent(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenu::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_TryBefore);

    if (!sipMeth)
        return  ::wxMenu::TryBefore(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenu::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_TryAfter);

    if (!sipMeth)
        return  ::wxMenu::TryAfter(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenu::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxEvtHandler::TryBefore(event) : TryBefore(event));
}

bool sipwxMenu::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxEvtHandler::TryAfter(event) : TryAfter(event));
}


PyDoc_STRVAR(doc_wxMenu_TryBefore, "TryBefore(event) -> bool\n"
"\n"
"Method called by ProcessEvent() before examining this object event\n"
"tables.");

extern "C" {static PyObject *meth_wxMenu_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_TryBefore, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_TryAfter, "TryAfter(event) -> bool\n"
"\n"
"Method called by ProcessEvent() as last resort.");

extern "C" {static PyObject *meth_wxMenu_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_TryAfter, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetMenuItems, "GetMenuItems() -> MenuItemList\n"
"\n"
"Returns the list of items in the menu.");

extern "C" {static PyObject *meth_wxMenu_GetMenuItems(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetMenuItems(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxMenuItemList*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetMenuItems();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItemList,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetMenuItems, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Append, "Append(id, item=EmptyString, helpString=EmptyString, kind=ITEM_NORMAL) -> MenuItem\n"
"Append(id, item, subMenu, helpString=EmptyString) -> MenuItem\n"
"Append(menuItem) -> MenuItem\n"
"\n"
"Adds a menu item.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxMenu_Append(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Append(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString& itemdef = wxEmptyString;
        const  ::wxString* item = &itemdef;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxItemKind kind = wxITEM_NORMAL;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_helpString,
            sipName_kind,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi|J1J1E", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState, sipType_wxItemKind, &kind))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Append(id,*item,*helpString,kind);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
        int id;
        const  ::wxString* item;
        int itemState = 0;
         ::wxMenu* subMenu;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_subMenu,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1J:|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxMenu, &subMenu, sipType_wxString,&helpString, &helpStringState))
        {
             ::wxMenuItem*sipRes;

            if (sipDeprecated(sipName_Menu,sipName_Append) < 0)
                return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Append(id,*item,subMenu,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
         ::wxMenuItem* menuItem;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menuItem,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuItem, &menuItem))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Append(menuItem);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Append, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_AppendCheckItem, "AppendCheckItem(id, item, help=EmptyString) -> MenuItem\n"
"\n"
"Adds a checkable item to the end of the menu.");

extern "C" {static PyObject *meth_wxMenu_AppendCheckItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_AppendCheckItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpdef = wxEmptyString;
        const  ::wxString* help = &helpdef;
        int helpState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_help,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&help, &helpState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendCheckItem(id,*item,*help);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(help),sipType_wxString,helpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_AppendCheckItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_AppendRadioItem, "AppendRadioItem(id, item, help=EmptyString) -> MenuItem\n"
"\n"
"Adds a radio item to the end of the menu.");

extern "C" {static PyObject *meth_wxMenu_AppendRadioItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_AppendRadioItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpdef = wxEmptyString;
        const  ::wxString* help = &helpdef;
        int helpState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_help,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&help, &helpState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendRadioItem(id,*item,*help);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(help),sipType_wxString,helpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_AppendRadioItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_AppendSeparator, "AppendSeparator() -> MenuItem\n"
"\n"
"Adds a separator to the end of the menu.");

extern "C" {static PyObject *meth_wxMenu_AppendSeparator(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_AppendSeparator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendSeparator();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_AppendSeparator, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_AppendSubMenu, "AppendSubMenu(submenu, text, help=EmptyString) -> MenuItem\n"
"\n"
"Adds the given submenu to this menu.");

extern "C" {static PyObject *meth_wxMenu_AppendSubMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_AppendSubMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu* submenu;
        const  ::wxString* text;
        int textState = 0;
        const  ::wxString& helpdef = wxEmptyString;
        const  ::wxString* help = &helpdef;
        int helpState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_submenu,
            sipName_text,
            sipName_help,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:J1|J1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenu, &submenu, sipType_wxString,&text, &textState, sipType_wxString,&help, &helpState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AppendSubMenu(submenu,*text,*help);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text),sipType_wxString,textState);
            sipReleaseType(const_cast< ::wxString *>(help),sipType_wxString,helpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_AppendSubMenu, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Break, "Break()\n"
"\n"
"Inserts a break in a menu, causing the next appended item to appear in\n"
"a new column.");

extern "C" {static PyObject *meth_wxMenu_Break(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Break(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Break();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Break, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Check, "Check(id, check)\n"
"\n"
"Checks or unchecks the menu item.");

extern "C" {static PyObject *meth_wxMenu_Check(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Check(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        bool check;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_check,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bib", &sipSelf, sipType_wxMenu, &sipCpp, &id, &check))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Check(id,check);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Check, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Delete, "Delete(id) -> bool\n"
"Delete(item) -> bool\n"
"\n"
"Deletes the menu item from the menu.\n"
"");

extern "C" {static PyObject *meth_wxMenu_Delete(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Delete(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Delete(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxMenuItem* item;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuItem, &item))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Delete(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Delete, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_DestroyItem, "DestroyItem(id) -> bool\n"
"DestroyItem(item) -> bool\n"
"\n"
"Deletes the menu item from the menu.\n"
"");

extern "C" {static PyObject *meth_wxMenu_DestroyItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_DestroyItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Destroy(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxMenuItem* item;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuItem, &item))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Destroy(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_DestroyItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Enable, "Enable(id, enable)\n"
"\n"
"Enables or disables (greys out) a menu item.");

extern "C" {static PyObject *meth_wxMenu_Enable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Enable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        bool enable;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bib", &sipSelf, sipType_wxMenu, &sipCpp, &id, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Enable(id,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Enable, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_FindChildItem, "FindChildItem(id) -> (MenuItem, pos)\n"
"\n"
"Finds the menu item object associated with the given menu item\n"
"identifier and, optionally, the position of the item in the menu.");

extern "C" {static PyObject *meth_wxMenu_FindChildItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_FindChildItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
         ::size_t* pos;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes;
            pos = new  ::size_t();

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindChildItem(id,pos);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
            return sipBuildResult(0,"(RN)",sipResObj,pos,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_FindChildItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_FindItem, "FindItem(itemString) -> int\n"
"FindItem(id) -> (MenuItem, menu)\n"
"\n"
"Finds the menu id for a menu item string.\n"
"");

extern "C" {static PyObject *meth_wxMenu_FindItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_FindItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxString* itemString;
        int itemStringState = 0;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_itemString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxString,&itemString, &itemStringState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindItem(*itemString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(itemString),sipType_wxString,itemStringState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    {
        int id;
         ::wxMenu* menu;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindItem(id,&menu);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
            return sipBuildResult(0,"(RD)",sipResObj,menu,sipType_wxMenu,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_FindItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_FindItemByPosition, "FindItemByPosition(position) -> MenuItem\n"
"\n"
"Returns the wxMenuItem given a position in the menu.");

extern "C" {static PyObject *meth_wxMenu_FindItemByPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_FindItemByPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* position;
        int positionState = 0;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_position,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&position, &positionState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindItemByPosition(*position);
            Py_END_ALLOW_THREADS
            sipReleaseType(position,sipType_size_t,positionState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_FindItemByPosition, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetHelpString, "GetHelpString(id) -> String\n"
"\n"
"Returns the help string associated with a menu item.");

extern "C" {static PyObject *meth_wxMenu_GetHelpString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetHelpString(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHelpString(id));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetHelpString, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetLabel, "GetLabel(id) -> String\n"
"\n"
"Returns a menu item label.");

extern "C" {static PyObject *meth_wxMenu_GetLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabel(id));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetLabelText, "GetLabelText(id) -> String\n"
"\n"
"Returns a menu item label, without any of the original mnemonics and\n"
"accelerators.");

extern "C" {static PyObject *meth_wxMenu_GetLabelText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetLabelText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabelText(id));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetLabelText, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetMenuItemCount, "GetMenuItemCount() -> size_t\n"
"\n"
"Returns the number of items in the menu.");

extern "C" {static PyObject *meth_wxMenu_GetMenuItemCount(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetMenuItemCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetMenuItemCount());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetMenuItemCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetTitle, "GetTitle() -> String\n"
"\n"
"Returns the title of the menu.");

extern "C" {static PyObject *meth_wxMenu_GetTitle(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetTitle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetTitle());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetTitle, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Insert, "Insert(pos, menuItem) -> MenuItem\n"
"Insert(pos, id, item=EmptyString, helpString=EmptyString, kind=ITEM_NORMAL) -> MenuItem\n"
"Insert(pos, id, text, submenu, help=EmptyString) -> MenuItem\n"
"\n"
"Inserts the given item before the position pos.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxMenu_Insert(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Insert(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
         ::wxMenuItem* menuItem;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_menuItem,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState, sipType_wxMenuItem, &menuItem))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*pos,menuItem);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
         ::size_t* pos;
        int posState = 0;
        int id;
        const  ::wxString& itemdef = wxEmptyString;
        const  ::wxString* item = &itemdef;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxItemKind kind = wxITEM_NORMAL;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_id,
            sipName_item,
            sipName_helpString,
            sipName_kind,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1i|J1J1E", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState, sipType_wxItemKind, &kind))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*pos,id,*item,*helpString,kind);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
         ::size_t* pos;
        int posState = 0;
        int id;
        const  ::wxString* text;
        int textState = 0;
         ::wxMenu* submenu;
        const  ::wxString& helpdef = wxEmptyString;
        const  ::wxString* help = &helpdef;
        int helpState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_id,
            sipName_text,
            sipName_submenu,
            sipName_help,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1iJ1J:|J1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState, &id, sipType_wxString,&text, &textState, sipType_wxMenu, &submenu, sipType_wxString,&help, &helpState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*pos,id,*text,submenu,*help);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(text),sipType_wxString,textState);
            sipReleaseType(const_cast< ::wxString *>(help),sipType_wxString,helpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Insert, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_InsertCheckItem, "InsertCheckItem(pos, id, item, helpString=EmptyString) -> MenuItem\n"
"\n"
"Inserts a checkable item at the given position.");

extern "C" {static PyObject *meth_wxMenu_InsertCheckItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_InsertCheckItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_id,
            sipName_item,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1iJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertCheckItem(*pos,id,*item,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_InsertCheckItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_InsertRadioItem, "InsertRadioItem(pos, id, item, helpString=EmptyString) -> MenuItem\n"
"\n"
"Inserts a radio item at the given position.");

extern "C" {static PyObject *meth_wxMenu_InsertRadioItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_InsertRadioItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_id,
            sipName_item,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1iJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertRadioItem(*pos,id,*item,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_InsertRadioItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_InsertSeparator, "InsertSeparator(pos) -> MenuItem\n"
"\n"
"Inserts a separator at the given position.");

extern "C" {static PyObject *meth_wxMenu_InsertSeparator(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_InsertSeparator(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_size_t,&pos, &posState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertSeparator(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_InsertSeparator, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_IsChecked, "IsChecked(id) -> bool\n"
"\n"
"Determines whether a menu item is checked.");

extern "C" {static PyObject *meth_wxMenu_IsChecked(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_IsChecked(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsChecked(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_IsChecked, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_IsEnabled, "IsEnabled(id) -> bool\n"
"\n"
"Determines whether a menu item is enabled.");

extern "C" {static PyObject *meth_wxMenu_IsEnabled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_IsEnabled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEnabled(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_IsEnabled, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Prepend, "Prepend(menuItem) -> MenuItem\n"
"Prepend(id, item=EmptyString, helpString=EmptyString, kind=ITEM_NORMAL) -> MenuItem\n"
"Prepend(id, text, subMenu, help=EmptyString) -> MenuItem\n"
"\n"
"Inserts the given item at position 0, i.e. before all the other\n"
"existing items.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxMenu_Prepend(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Prepend(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenuItem* menuItem;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menuItem,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuItem, &menuItem))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(menuItem);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
        int id;
        const  ::wxString& itemdef = wxEmptyString;
        const  ::wxString* item = &itemdef;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxItemKind kind = wxITEM_NORMAL;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_helpString,
            sipName_kind,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi|J1J1E", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState, sipType_wxItemKind, &kind))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(id,*item,*helpString,kind);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    {
        int id;
        const  ::wxString* text;
        int textState = 0;
         ::wxMenu* subMenu;
        const  ::wxString& helpdef = wxEmptyString;
        const  ::wxString* help = &helpdef;
        int helpState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_text,
            sipName_subMenu,
            sipName_help,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1J:|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&text, &textState, sipType_wxMenu, &subMenu, sipType_wxString,&help, &helpState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(id,*text,subMenu,*help);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(text),sipType_wxString,textState);
            sipReleaseType(const_cast< ::wxString *>(help),sipType_wxString,helpState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Prepend, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_PrependCheckItem, "PrependCheckItem(id, item, helpString=EmptyString) -> MenuItem\n"
"\n"
"Inserts a checkable item at position 0.");

extern "C" {static PyObject *meth_wxMenu_PrependCheckItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_PrependCheckItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependCheckItem(id,*item,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_PrependCheckItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_PrependRadioItem, "PrependRadioItem(id, item, helpString=EmptyString) -> MenuItem\n"
"\n"
"Inserts a radio item at position 0.");

extern "C" {static PyObject *meth_wxMenu_PrependRadioItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_PrependRadioItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* item;
        int itemState = 0;
        const  ::wxString& helpStringdef = wxEmptyString;
        const  ::wxString* helpString = &helpStringdef;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_item,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1|J1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&item, &itemState, sipType_wxString,&helpString, &helpStringState))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependRadioItem(id,*item,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(item),sipType_wxString,itemState);
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_PrependRadioItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_PrependSeparator, "PrependSeparator() -> MenuItem\n"
"\n"
"Inserts a separator at position 0.");

extern "C" {static PyObject *meth_wxMenu_PrependSeparator(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_PrependSeparator(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependSeparator();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_PrependSeparator, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Remove, "Remove(id) -> MenuItem\n"
"Remove(item) -> MenuItem\n"
"\n"
"Removes the menu item from the menu but doesn't delete the associated\n"
"C++ object.\n"
"");

extern "C" {static PyObject *meth_wxMenu_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,Py_None);
        }
    }

    {
         ::wxMenuItem* item;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuItem, &item))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Remove, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_SetHelpString, "SetHelpString(id, helpString)\n"
"\n"
"Sets an item's help string.");

extern "C" {static PyObject *meth_wxMenu_SetHelpString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_SetHelpString(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* helpString;
        int helpStringState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&helpString, &helpStringState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHelpString(id,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_SetHelpString, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_SetLabel, "SetLabel(id, label)\n"
"\n"
"Sets the label of a menu item.");

extern "C" {static PyObject *meth_wxMenu_SetLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_SetLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* label;
        int labelState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_label,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1", &sipSelf, sipType_wxMenu, &sipCpp, &id, sipType_wxString,&label, &labelState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabel(id,*label);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(label),sipType_wxString,labelState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_SetLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_SetTitle, "SetTitle(title)\n"
"\n"
"Sets the title of the menu.");

extern "C" {static PyObject *meth_wxMenu_SetTitle(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_SetTitle(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxString* title;
        int titleState = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_title,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxString,&title, &titleState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetTitle(*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_SetTitle, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_UpdateUI, "UpdateUI(source=None)\n"
"\n"
"Sends events to source (or owning window if NULL) to update the menu\n"
"UI.");

extern "C" {static PyObject *meth_wxMenu_UpdateUI(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_UpdateUI(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxEvtHandler* source = 0;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_source,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|J8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxEvtHandler, &source))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->UpdateUI(source);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_UpdateUI, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_SetInvokingWindow, "SetInvokingWindow(win)");

extern "C" {static PyObject *meth_wxMenu_SetInvokingWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_SetInvokingWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* win;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_win,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxWindow, &win))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetInvokingWindow(win);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_SetInvokingWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetInvokingWindow, "GetInvokingWindow() -> Window");

extern "C" {static PyObject *meth_wxMenu_GetInvokingWindow(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetInvokingWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetInvokingWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetInvokingWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetWindow, "GetWindow() -> Window");

extern "C" {static PyObject *meth_wxMenu_GetWindow(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetStyle, "GetStyle() -> long");

extern "C" {static PyObject *meth_wxMenu_GetStyle(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetStyle(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetStyle();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetStyle, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_SetParent, "SetParent(parent)");

extern "C" {static PyObject *meth_wxMenu_SetParent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_SetParent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu* parent;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenu, &parent))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetParent(parent);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_SetParent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_GetParent, "GetParent() -> Menu");

extern "C" {static PyObject *meth_wxMenu_GetParent(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_GetParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
             ::wxMenu*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetParent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_GetParent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Attach, "Attach(menubar)");

extern "C" {static PyObject *meth_wxMenu_Attach(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Attach(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenuBar* menubar;
         ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menubar,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenu, &sipCpp, sipType_wxMenuBar, &menubar))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Attach(menubar);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Attach, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_Detach, "Detach()");

extern "C" {static PyObject *meth_wxMenu_Detach(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_Detach(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Detach();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_Detach, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_IsAttached, "IsAttached() -> bool");

extern "C" {static PyObject *meth_wxMenu_IsAttached(PyObject *, PyObject *);}
static PyObject *meth_wxMenu_IsAttached(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenu *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenu, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsAttached();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_IsAttached, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenu_FindItemById, "FindItemById(id) -> MenuItem\n"
"\n"
"FindItemById(id) -> MenuItem\n"
"\n"
"Finds the menu item object associated with the given menu item\n"
"identifier.");

extern "C" {static PyObject *meth_wxMenu_FindItemById(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenu_FindItemById(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenu *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenu, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxMenu_FindItemById(sipCpp, id);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Menu, sipName_FindItemById, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxMenu(void *, const sipTypeDef *);}
static void *cast_wxMenu(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxMenu *sipCpp = reinterpret_cast< ::wxMenu *>(sipCppV);

    if (targetType == sipType_wxEvtHandler)
        return static_cast< ::wxEvtHandler *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    if (targetType == sipType_wxTrackable)
        return static_cast< ::wxTrackable *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxMenu(void *, int);}
static void release_wxMenu(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxMenu *>(sipCppV);
    else
        delete reinterpret_cast< ::wxMenu *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxMenu(sipSimpleWrapper *);}
static void dealloc_wxMenu(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxMenu *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxMenu(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxMenu(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxMenu(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxMenu *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxMenu();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        long style;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "l", &style))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxMenu(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::wxString* title;
        int titleState = 0;
        long style = 0;

        static const char *sipKwdList[] = {
            sipName_title,
            sipName_style,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|l", sipType_wxString,&title, &titleState, &style))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxMenu(*title,style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxMenu[] = {{148, 255, 1}};


static PyMethodDef methods_wxMenu[] = {
    {SIP_MLNAME_CAST(sipName_Append), (PyCFunction)meth_wxMenu_Append, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Append)},
    {SIP_MLNAME_CAST(sipName_AppendCheckItem), (PyCFunction)meth_wxMenu_AppendCheckItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_AppendCheckItem)},
    {SIP_MLNAME_CAST(sipName_AppendRadioItem), (PyCFunction)meth_wxMenu_AppendRadioItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_AppendRadioItem)},
    {SIP_MLNAME_CAST(sipName_AppendSeparator), meth_wxMenu_AppendSeparator, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_AppendSeparator)},
    {SIP_MLNAME_CAST(sipName_AppendSubMenu), (PyCFunction)meth_wxMenu_AppendSubMenu, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_AppendSubMenu)},
    {SIP_MLNAME_CAST(sipName_Attach), (PyCFunction)meth_wxMenu_Attach, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Attach)},
    {SIP_MLNAME_CAST(sipName_Break), meth_wxMenu_Break, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_Break)},
    {SIP_MLNAME_CAST(sipName_Check), (PyCFunction)meth_wxMenu_Check, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Check)},
    {SIP_MLNAME_CAST(sipName_Delete), (PyCFunction)meth_wxMenu_Delete, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Delete)},
    {SIP_MLNAME_CAST(sipName_DestroyItem), (PyCFunction)meth_wxMenu_DestroyItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_DestroyItem)},
    {SIP_MLNAME_CAST(sipName_Detach), meth_wxMenu_Detach, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_Detach)},
    {SIP_MLNAME_CAST(sipName_Enable), (PyCFunction)meth_wxMenu_Enable, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Enable)},
    {SIP_MLNAME_CAST(sipName_FindChildItem), (PyCFunction)meth_wxMenu_FindChildItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_FindChildItem)},
    {SIP_MLNAME_CAST(sipName_FindItem), (PyCFunction)meth_wxMenu_FindItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_FindItem)},
    {SIP_MLNAME_CAST(sipName_FindItemById), (PyCFunction)meth_wxMenu_FindItemById, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_FindItemById)},
    {SIP_MLNAME_CAST(sipName_FindItemByPosition), (PyCFunction)meth_wxMenu_FindItemByPosition, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_FindItemByPosition)},
    {SIP_MLNAME_CAST(sipName_GetHelpString), (PyCFunction)meth_wxMenu_GetHelpString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_GetHelpString)},
    {SIP_MLNAME_CAST(sipName_GetInvokingWindow), meth_wxMenu_GetInvokingWindow, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetInvokingWindow)},
    {SIP_MLNAME_CAST(sipName_GetLabel), (PyCFunction)meth_wxMenu_GetLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_GetLabel)},
    {SIP_MLNAME_CAST(sipName_GetLabelText), (PyCFunction)meth_wxMenu_GetLabelText, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_GetLabelText)},
    {SIP_MLNAME_CAST(sipName_GetMenuItemCount), meth_wxMenu_GetMenuItemCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetMenuItemCount)},
    {SIP_MLNAME_CAST(sipName_GetMenuItems), meth_wxMenu_GetMenuItems, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetMenuItems)},
    {SIP_MLNAME_CAST(sipName_GetParent), meth_wxMenu_GetParent, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetParent)},
    {SIP_MLNAME_CAST(sipName_GetStyle), meth_wxMenu_GetStyle, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetStyle)},
    {SIP_MLNAME_CAST(sipName_GetTitle), meth_wxMenu_GetTitle, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetTitle)},
    {SIP_MLNAME_CAST(sipName_GetWindow), meth_wxMenu_GetWindow, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_GetWindow)},
    {SIP_MLNAME_CAST(sipName_Insert), (PyCFunction)meth_wxMenu_Insert, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Insert)},
    {SIP_MLNAME_CAST(sipName_InsertCheckItem), (PyCFunction)meth_wxMenu_InsertCheckItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_InsertCheckItem)},
    {SIP_MLNAME_CAST(sipName_InsertRadioItem), (PyCFunction)meth_wxMenu_InsertRadioItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_InsertRadioItem)},
    {SIP_MLNAME_CAST(sipName_InsertSeparator), (PyCFunction)meth_wxMenu_InsertSeparator, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_InsertSeparator)},
    {SIP_MLNAME_CAST(sipName_IsAttached), meth_wxMenu_IsAttached, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_IsAttached)},
    {SIP_MLNAME_CAST(sipName_IsChecked), (PyCFunction)meth_wxMenu_IsChecked, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_IsChecked)},
    {SIP_MLNAME_CAST(sipName_IsEnabled), (PyCFunction)meth_wxMenu_IsEnabled, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_IsEnabled)},
    {SIP_MLNAME_CAST(sipName_Prepend), (PyCFunction)meth_wxMenu_Prepend, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Prepend)},
    {SIP_MLNAME_CAST(sipName_PrependCheckItem), (PyCFunction)meth_wxMenu_PrependCheckItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_PrependCheckItem)},
    {SIP_MLNAME_CAST(sipName_PrependRadioItem), (PyCFunction)meth_wxMenu_PrependRadioItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_PrependRadioItem)},
    {SIP_MLNAME_CAST(sipName_PrependSeparator), meth_wxMenu_PrependSeparator, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenu_PrependSeparator)},
    {SIP_MLNAME_CAST(sipName_Remove), (PyCFunction)meth_wxMenu_Remove, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_Remove)},
    {SIP_MLNAME_CAST(sipName_SetHelpString), (PyCFunction)meth_wxMenu_SetHelpString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_SetHelpString)},
    {SIP_MLNAME_CAST(sipName_SetInvokingWindow), (PyCFunction)meth_wxMenu_SetInvokingWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_SetInvokingWindow)},
    {SIP_MLNAME_CAST(sipName_SetLabel), (PyCFunction)meth_wxMenu_SetLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_SetLabel)},
    {SIP_MLNAME_CAST(sipName_SetParent), (PyCFunction)meth_wxMenu_SetParent, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_SetParent)},
    {SIP_MLNAME_CAST(sipName_SetTitle), (PyCFunction)meth_wxMenu_SetTitle, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_SetTitle)},
    {SIP_MLNAME_CAST(sipName_TryAfter), (PyCFunction)meth_wxMenu_TryAfter, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_TryBefore), (PyCFunction)meth_wxMenu_TryBefore, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_UpdateUI), (PyCFunction)meth_wxMenu_UpdateUI, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenu_UpdateUI)}
};

sipVariableDef variables_wxMenu[] = {
    {PropertyVariable, sipName_Window, &methods_wxMenu[25], NULL, NULL, NULL},
    {PropertyVariable, sipName_Title, &methods_wxMenu[24], &methods_wxMenu[42], NULL, NULL},
    {PropertyVariable, sipName_Style, &methods_wxMenu[23], NULL, NULL, NULL},
    {PropertyVariable, sipName_Parent, &methods_wxMenu[22], &methods_wxMenu[41], NULL, NULL},
    {PropertyVariable, sipName_MenuItems, &methods_wxMenu[21], NULL, NULL, NULL},
    {PropertyVariable, sipName_MenuItemCount, &methods_wxMenu[20], NULL, NULL, NULL},
    {PropertyVariable, sipName_InvokingWindow, &methods_wxMenu[17], &methods_wxMenu[39], NULL, NULL},
};

PyDoc_STRVAR(doc_wxMenu, "Menu()\n"
"Menu(style)\n"
"Menu(title, style=0)\n"
"\n"
"A menu is a popup (or pull down) list of items, one of which may be\n"
"selected before the menu goes away (clicking elsewhere dismisses the\n"
"menu).");


sipClassTypeDef sipTypeDef__core_wxMenu = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxMenu,
        {0},
        0
    },
    {
        sipNameNr_Menu,
        {0, 0, 1},
        46, methods_wxMenu,
        0, 0,
        7, variables_wxMenu,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxMenu,
    -1,
    -1,
    supers_wxMenu,
    0,
    init_type_wxMenu,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxMenu,
    0,
    0,
    0,
    release_wxMenu,
    cast_wxMenu,
    0,
    0,
    0,
    0,
    0,
    0
};
