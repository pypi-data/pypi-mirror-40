/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/datetime.h>



PyDoc_STRVAR(doc_wxDateSpan_Add, "Add(other) -> DateSpan\n"
"\n"
"Adds the given wxDateSpan to this wxDateSpan and returns a reference\n"
"to itself.");

extern "C" {static PyObject *meth_wxDateSpan_Add(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Add(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* other;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxDateSpan, &sipCpp, sipType_wxDateSpan, &other))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->Add(*other);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Add, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetDays, "GetDays() -> int\n"
"\n"
"Returns the number of days (not counting the weeks component) in this\n"
"date span.");

extern "C" {static PyObject *meth_wxDateSpan_GetDays(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetDays(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetDays();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetDays, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetMonths, "GetMonths() -> int\n"
"\n"
"Returns the number of the months (not counting the years) in this date\n"
"span.");

extern "C" {static PyObject *meth_wxDateSpan_GetMonths(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetMonths(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMonths();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetMonths, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetTotalMonths, "GetTotalMonths() -> int\n"
"\n"
"Returns the combined number of months in this date span, counting both\n"
"years and months.");

extern "C" {static PyObject *meth_wxDateSpan_GetTotalMonths(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetTotalMonths(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTotalMonths();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetTotalMonths, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetTotalDays, "GetTotalDays() -> int\n"
"\n"
"Returns the combined number of days in this date span, counting both\n"
"weeks and days.");

extern "C" {static PyObject *meth_wxDateSpan_GetTotalDays(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetTotalDays(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetTotalDays();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetTotalDays, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetWeeks, "GetWeeks() -> int\n"
"\n"
"Returns the number of weeks in this date span.");

extern "C" {static PyObject *meth_wxDateSpan_GetWeeks(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetWeeks(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetWeeks();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetWeeks, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_GetYears, "GetYears() -> int\n"
"\n"
"Returns the number of years in this date span.");

extern "C" {static PyObject *meth_wxDateSpan_GetYears(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_GetYears(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetYears();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_GetYears, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Multiply, "Multiply(factor) -> DateSpan\n"
"\n"
"Multiplies this date span by the specified factor.");

extern "C" {static PyObject *meth_wxDateSpan_Multiply(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Multiply(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int factor;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_factor,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxDateSpan, &sipCpp, &factor))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->Multiply(factor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Multiply, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Neg, "Neg() -> DateSpan\n"
"\n"
"Changes the sign of this date span.");

extern "C" {static PyObject *meth_wxDateSpan_Neg(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Neg(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->Neg();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Neg, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Negate, "Negate() -> DateSpan\n"
"\n"
"Returns a date span with the opposite sign.");

extern "C" {static PyObject *meth_wxDateSpan_Negate(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Negate(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxDateSpan, &sipCpp))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan(sipCpp->Negate());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Negate, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_SetDays, "SetDays(n) -> DateSpan\n"
"\n"
"Sets the number of days (without modifying any other components) in\n"
"this date span.");

extern "C" {static PyObject *meth_wxDateSpan_SetDays(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_SetDays(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int n;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxDateSpan, &sipCpp, &n))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->SetDays(n);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_SetDays, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_SetMonths, "SetMonths(n) -> DateSpan\n"
"\n"
"Sets the number of months (without modifying any other components) in\n"
"this date span.");

extern "C" {static PyObject *meth_wxDateSpan_SetMonths(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_SetMonths(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int n;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxDateSpan, &sipCpp, &n))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->SetMonths(n);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_SetMonths, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_SetWeeks, "SetWeeks(n) -> DateSpan\n"
"\n"
"Sets the number of weeks (without modifying any other components) in\n"
"this date span.");

extern "C" {static PyObject *meth_wxDateSpan_SetWeeks(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_SetWeeks(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int n;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxDateSpan, &sipCpp, &n))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->SetWeeks(n);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_SetWeeks, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_SetYears, "SetYears(n) -> DateSpan\n"
"\n"
"Sets the number of years (without modifying any other components) in\n"
"this date span.");

extern "C" {static PyObject *meth_wxDateSpan_SetYears(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_SetYears(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int n;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxDateSpan, &sipCpp, &n))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->SetYears(n);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_SetYears, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Subtract, "Subtract(other) -> DateSpan\n"
"\n"
"Subtracts the given wxDateSpan to this wxDateSpan and returns a\n"
"reference to itself.");

extern "C" {static PyObject *meth_wxDateSpan_Subtract(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Subtract(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* other;
         ::wxDateSpan *sipCpp;

        static const char *sipKwdList[] = {
            sipName_other,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxDateSpan, &sipCpp, sipType_wxDateSpan, &other))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->Subtract(*other);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Subtract, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Day, "Day() -> DateSpan\n"
"\n"
"Returns a date span object corresponding to one day.");

extern "C" {static PyObject *meth_wxDateSpan_Day(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Day(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Day());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Day, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Days, "Days(days) -> DateSpan\n"
"\n"
"Returns a date span object corresponding to the given number of days.");

extern "C" {static PyObject *meth_wxDateSpan_Days(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Days(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int days;

        static const char *sipKwdList[] = {
            sipName_days,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "i", &days))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Days(days));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Days, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Month, "Month() -> DateSpan\n"
"\n"
"Returns a date span object corresponding to one month.");

extern "C" {static PyObject *meth_wxDateSpan_Month(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Month(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Month());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Month, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Months, "Months(mon) -> DateSpan\n"
"\n"
"Returns a date span object corresponding to the given number of\n"
"months.");

extern "C" {static PyObject *meth_wxDateSpan_Months(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Months(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int mon;

        static const char *sipKwdList[] = {
            sipName_mon,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "i", &mon))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Months(mon));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Months, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Week, "Week() -> DateSpan\n"
"\n"
"Returns a date span object corresponding to one week.");

extern "C" {static PyObject *meth_wxDateSpan_Week(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Week(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Week());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Week, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Weeks, "Weeks(weeks) -> DateSpan\n"
"\n"
"Returns a date span object corresponding to the given number of weeks.");

extern "C" {static PyObject *meth_wxDateSpan_Weeks(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Weeks(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int weeks;

        static const char *sipKwdList[] = {
            sipName_weeks,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "i", &weeks))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Weeks(weeks));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Weeks, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Year, "Year() -> DateSpan\n"
"\n"
"Returns a date span object corresponding to one year.");

extern "C" {static PyObject *meth_wxDateSpan_Year(PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Year(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Year());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Year, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxDateSpan_Years, "Years(years) -> DateSpan\n"
"\n"
"Returns a date span object corresponding to the given number of years.");

extern "C" {static PyObject *meth_wxDateSpan_Years(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxDateSpan_Years(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int years;

        static const char *sipKwdList[] = {
            sipName_years,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "i", &years))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan( ::wxDateSpan::Years(years));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_DateSpan, sipName_Years, NULL);

    return NULL;
}


extern "C" {static PyObject *slot_wxDateSpan___ne__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* ds;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_wxDateSpan, &ds))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp-> ::wxDateSpan::operator!=(*ds);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__core, ne_slot, sipType_wxDateSpan, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_wxDateSpan___eq__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* ds;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_wxDateSpan, &ds))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp-> ::wxDateSpan::operator==(*ds);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__core, eq_slot, sipType_wxDateSpan, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_wxDateSpan___mul__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxDateSpan* a0;
        int n;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9i", sipType_wxDateSpan, &a0, &n))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan((*a0 * n));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__core, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_wxDateSpan___imul__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___imul__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_wxDateSpan)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int factor;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &factor))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp-> ::wxDateSpan::operator*=(factor);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_wxDateSpan___neg__(PyObject *);}
static PyObject *slot_wxDateSpan___neg__(PyObject *sipSelf)
{
     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;


    {
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &-(*sipCpp);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_wxDateSpan___sub__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxDateSpan* a0;
        const  ::wxDateSpan* ds;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_wxDateSpan, &a0, sipType_wxDateSpan, &ds))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan((*a0 - *ds));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__core, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_wxDateSpan___isub__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_wxDateSpan)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* other;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_wxDateSpan, &other))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp-> ::wxDateSpan::operator-=(*other);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_wxDateSpan___add__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxDateSpan* a0;
        const  ::wxDateSpan* ds;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_wxDateSpan, &a0, sipType_wxDateSpan, &ds))
        {
             ::wxDateSpan*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxDateSpan((*a0 + *ds));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxDateSpan,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI__core, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_wxDateSpan___iadd__(PyObject *,PyObject *);}
static PyObject *slot_wxDateSpan___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_wxDateSpan)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::wxDateSpan *sipCpp = reinterpret_cast< ::wxDateSpan *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_wxDateSpan));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::wxDateSpan* other;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_wxDateSpan, &other))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp-> ::wxDateSpan::operator+=(*other);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxDateSpan(void *, int);}
static void release_wxDateSpan(void *sipCppV, int)
{
    Py_BEGIN_ALLOW_THREADS

    delete reinterpret_cast< ::wxDateSpan *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_wxDateSpan(void *, SIP_SSIZE_T, void *);}
static void assign_wxDateSpan(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::wxDateSpan *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::wxDateSpan *>(sipSrc);
}


extern "C" {static void *array_wxDateSpan(SIP_SSIZE_T);}
static void *array_wxDateSpan(SIP_SSIZE_T sipNrElem)
{
    return new  ::wxDateSpan[sipNrElem];
}


extern "C" {static void *copy_wxDateSpan(const void *, SIP_SSIZE_T);}
static void *copy_wxDateSpan(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::wxDateSpan(reinterpret_cast<const  ::wxDateSpan *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_wxDateSpan(sipSimpleWrapper *);}
static void dealloc_wxDateSpan(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxDateSpan(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_wxDateSpan(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxDateSpan(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::wxDateSpan *sipCpp = 0;

    {
        int years = 0;
        int months = 0;
        int weeks = 0;
        int days = 0;

        static const char *sipKwdList[] = {
            sipName_years,
            sipName_months,
            sipName_weeks,
            sipName_days,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|iiii", &years, &months, &weeks, &days))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new  ::wxDateSpan(years,months,weeks,days);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            return sipCpp;
        }
    }

    {
        const  ::wxDateSpan* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_wxDateSpan, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new  ::wxDateSpan(*a0);
            Py_END_ALLOW_THREADS

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_wxDateSpan[] = {
    {(void *)slot_wxDateSpan___ne__, ne_slot},
    {(void *)slot_wxDateSpan___eq__, eq_slot},
    {(void *)slot_wxDateSpan___mul__, mul_slot},
    {(void *)slot_wxDateSpan___imul__, imul_slot},
    {(void *)slot_wxDateSpan___neg__, neg_slot},
    {(void *)slot_wxDateSpan___sub__, sub_slot},
    {(void *)slot_wxDateSpan___isub__, isub_slot},
    {(void *)slot_wxDateSpan___add__, add_slot},
    {(void *)slot_wxDateSpan___iadd__, iadd_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_wxDateSpan[] = {
    {SIP_MLNAME_CAST(sipName_Add), (PyCFunction)meth_wxDateSpan_Add, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Add)},
    {SIP_MLNAME_CAST(sipName_Day), meth_wxDateSpan_Day, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Day)},
    {SIP_MLNAME_CAST(sipName_Days), (PyCFunction)meth_wxDateSpan_Days, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Days)},
    {SIP_MLNAME_CAST(sipName_GetDays), meth_wxDateSpan_GetDays, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetDays)},
    {SIP_MLNAME_CAST(sipName_GetMonths), meth_wxDateSpan_GetMonths, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetMonths)},
    {SIP_MLNAME_CAST(sipName_GetTotalDays), meth_wxDateSpan_GetTotalDays, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetTotalDays)},
    {SIP_MLNAME_CAST(sipName_GetTotalMonths), meth_wxDateSpan_GetTotalMonths, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetTotalMonths)},
    {SIP_MLNAME_CAST(sipName_GetWeeks), meth_wxDateSpan_GetWeeks, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetWeeks)},
    {SIP_MLNAME_CAST(sipName_GetYears), meth_wxDateSpan_GetYears, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_GetYears)},
    {SIP_MLNAME_CAST(sipName_Month), meth_wxDateSpan_Month, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Month)},
    {SIP_MLNAME_CAST(sipName_Months), (PyCFunction)meth_wxDateSpan_Months, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Months)},
    {SIP_MLNAME_CAST(sipName_Multiply), (PyCFunction)meth_wxDateSpan_Multiply, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Multiply)},
    {SIP_MLNAME_CAST(sipName_Neg), meth_wxDateSpan_Neg, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Neg)},
    {SIP_MLNAME_CAST(sipName_Negate), meth_wxDateSpan_Negate, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Negate)},
    {SIP_MLNAME_CAST(sipName_SetDays), (PyCFunction)meth_wxDateSpan_SetDays, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_SetDays)},
    {SIP_MLNAME_CAST(sipName_SetMonths), (PyCFunction)meth_wxDateSpan_SetMonths, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_SetMonths)},
    {SIP_MLNAME_CAST(sipName_SetWeeks), (PyCFunction)meth_wxDateSpan_SetWeeks, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_SetWeeks)},
    {SIP_MLNAME_CAST(sipName_SetYears), (PyCFunction)meth_wxDateSpan_SetYears, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_SetYears)},
    {SIP_MLNAME_CAST(sipName_Subtract), (PyCFunction)meth_wxDateSpan_Subtract, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Subtract)},
    {SIP_MLNAME_CAST(sipName_Week), meth_wxDateSpan_Week, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Week)},
    {SIP_MLNAME_CAST(sipName_Weeks), (PyCFunction)meth_wxDateSpan_Weeks, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Weeks)},
    {SIP_MLNAME_CAST(sipName_Year), meth_wxDateSpan_Year, METH_VARARGS, SIP_MLDOC_CAST(doc_wxDateSpan_Year)},
    {SIP_MLNAME_CAST(sipName_Years), (PyCFunction)meth_wxDateSpan_Years, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxDateSpan_Years)}
};

PyDoc_STRVAR(doc_wxDateSpan, "DateSpan(years=0, months=0, weeks=0, days=0)\n"
"\n"
"This class is a \"logical time span\" and is useful for implementing\n"
"program logic for such things as \"add one month to the date\" which, in\n"
"general, doesn't mean to add 60*60*24*31 seconds to it, but to take\n"
"the same date the next month (to understand that this is indeed\n"
"different consider adding one month to Feb, 15  we want to get Mar,\n"
"15, of course).");


sipClassTypeDef sipTypeDef__core_wxDateSpan = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_wxDateSpan,
        {0},
        0
    },
    {
        sipNameNr_DateSpan,
        {0, 0, 1},
        23, methods_wxDateSpan,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxDateSpan,
    -1,
    -1,
    0,
    slots_wxDateSpan,
    init_type_wxDateSpan,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxDateSpan,
    assign_wxDateSpan,
    array_wxDateSpan,
    copy_wxDateSpan,
    release_wxDateSpan,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
