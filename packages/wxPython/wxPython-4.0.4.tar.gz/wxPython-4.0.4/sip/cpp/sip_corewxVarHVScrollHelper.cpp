/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/vscroll.h>

        #include <wx/window.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/position.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>


class sipwxVarHVScrollHelper : public  ::wxVarHVScrollHelper
{
public:
    sipwxVarHVScrollHelper( ::wxWindow*);
    sipwxVarHVScrollHelper(const  ::wxVarHVScrollHelper&);
    virtual ~sipwxVarHVScrollHelper();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
     ::wxCoord sipProtectVirt_EstimateTotalWidth(bool) const;
    void sipProtectVirt_OnGetColumnsWidthHint(bool, ::size_t, ::size_t) const;
     ::wxCoord sipProtect_OnGetColumnWidth( ::size_t) const;
    void sipProtectVirt_OnGetRowsHeightHint(bool, ::size_t, ::size_t) const;
     ::wxCoord sipProtectVirt_EstimateTotalHeight(bool) const;
     ::wxCoord sipProtect_OnGetRowHeight( ::size_t) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void RefreshRowsColumns(const  ::wxPosition&,const  ::wxPosition&);
    void RefreshRowsColumns( ::size_t, ::size_t, ::size_t, ::size_t);
    void RefreshRowColumn(const  ::wxPosition&);
    void RefreshRowColumn( ::size_t, ::size_t);
    void RefreshColumn( ::size_t);
    void RefreshColumns( ::size_t, ::size_t);
    bool ScrollColumnPages(int);
    bool ScrollColumns(int);
     ::wxCoord EstimateTotalWidth() const;
    void OnGetColumnsWidthHint( ::size_t, ::size_t) const;
     ::wxCoord OnGetColumnWidth( ::size_t) const;
    void RefreshRow( ::size_t);
    void RefreshRows( ::size_t, ::size_t);
    bool ScrollRowPages(int);
    bool ScrollRows(int);
    void OnGetRowsHeightHint( ::size_t, ::size_t) const;
     ::wxCoord EstimateTotalHeight() const;
     ::wxCoord OnGetRowHeight( ::size_t) const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxVarHVScrollHelper(const sipwxVarHVScrollHelper &);
    sipwxVarHVScrollHelper &operator = (const sipwxVarHVScrollHelper &);

    char sipPyMethods[18];
};

sipwxVarHVScrollHelper::sipwxVarHVScrollHelper( ::wxWindow*winToScroll):  ::wxVarHVScrollHelper(winToScroll), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxVarHVScrollHelper::sipwxVarHVScrollHelper(const  ::wxVarHVScrollHelper& a0):  ::wxVarHVScrollHelper(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxVarHVScrollHelper::~sipwxVarHVScrollHelper()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipwxVarHVScrollHelper::RefreshRowsColumns(const  ::wxPosition& from,const  ::wxPosition& to)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_RefreshRowsColumns);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRowsColumns(from,to);
        return;
    }

    extern void sipVH__core_139(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxPosition&,const  ::wxPosition&);

    sipVH__core_139(sipGILState, 0, sipPySelf, sipMeth, from, to);
}

void sipwxVarHVScrollHelper::RefreshRowsColumns( ::size_t fromRow, ::size_t toRow, ::size_t fromColumn, ::size_t toColumn)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_RefreshRowsColumns);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRowsColumns(fromRow,toRow,fromColumn,toColumn);
        return;
    }

    extern void sipVH__core_138(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t, ::size_t, ::size_t);

    sipVH__core_138(sipGILState, 0, sipPySelf, sipMeth, fromRow, toRow, fromColumn, toColumn);
}

void sipwxVarHVScrollHelper::RefreshRowColumn(const  ::wxPosition& pos)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_RefreshRowColumn);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRowColumn(pos);
        return;
    }

    extern void sipVH__core_137(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxPosition&);

    sipVH__core_137(sipGILState, 0, sipPySelf, sipMeth, pos);
}

void sipwxVarHVScrollHelper::RefreshRowColumn( ::size_t row, ::size_t column)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_RefreshRowColumn);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRowColumn(row,column);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, row, column);
}

void sipwxVarHVScrollHelper::RefreshColumn( ::size_t column)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_RefreshColumn);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshColumn(column);
        return;
    }

    extern void sipVH__core_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    sipVH__core_135(sipGILState, 0, sipPySelf, sipMeth, column);
}

void sipwxVarHVScrollHelper::RefreshColumns( ::size_t from_, ::size_t to_)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_RefreshColumns);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshColumns(from_,to_);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

bool sipwxVarHVScrollHelper::ScrollColumnPages(int pages)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_ScrollColumnPages);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::ScrollColumnPages(pages);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, pages);
}

bool sipwxVarHVScrollHelper::ScrollColumns(int columns)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,NULL,sipName_ScrollColumns);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::ScrollColumns(columns);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, columns);
}

 ::wxCoord sipwxVarHVScrollHelper::EstimateTotalWidth() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[8]),sipPySelf,NULL,sipName_EstimateTotalWidth);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::EstimateTotalWidth();

    extern  ::wxCoord sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxVarHVScrollHelper::OnGetColumnsWidthHint( ::size_t columnMin, ::size_t columnMax) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[9]),sipPySelf,NULL,sipName_OnGetColumnsWidthHint);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::OnGetColumnsWidthHint(columnMin,columnMax);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, columnMin, columnMax);
}

 ::wxCoord sipwxVarHVScrollHelper::OnGetColumnWidth( ::size_t column) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[10]),sipPySelf,sipName_VarHVScrollHelper,sipName_OnGetColumnWidth);

    if (!sipMeth)
        return 0;

    extern  ::wxCoord sipVH__core_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    return sipVH__core_134(sipGILState, 0, sipPySelf, sipMeth, column);
}

void sipwxVarHVScrollHelper::RefreshRow( ::size_t row)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[11],sipPySelf,NULL,sipName_RefreshRow);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRow(row);
        return;
    }

    extern void sipVH__core_135(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    sipVH__core_135(sipGILState, 0, sipPySelf, sipMeth, row);
}

void sipwxVarHVScrollHelper::RefreshRows( ::size_t from_, ::size_t to_)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[12],sipPySelf,NULL,sipName_RefreshRows);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::RefreshRows(from_,to_);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, from_, to_);
}

bool sipwxVarHVScrollHelper::ScrollRowPages(int pages)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_ScrollRowPages);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::ScrollRowPages(pages);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, pages);
}

bool sipwxVarHVScrollHelper::ScrollRows(int rows)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,NULL,sipName_ScrollRows);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::ScrollRows(rows);

    extern bool sipVH__core_136(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    return sipVH__core_136(sipGILState, 0, sipPySelf, sipMeth, rows);
}

void sipwxVarHVScrollHelper::OnGetRowsHeightHint( ::size_t rowMin, ::size_t rowMax) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[15]),sipPySelf,NULL,sipName_OnGetRowsHeightHint);

    if (!sipMeth)
    {
         ::wxVarHVScrollHelper::OnGetRowsHeightHint(rowMin,rowMax);
        return;
    }

    extern void sipVH__core_133(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t, ::size_t);

    sipVH__core_133(sipGILState, 0, sipPySelf, sipMeth, rowMin, rowMax);
}

 ::wxCoord sipwxVarHVScrollHelper::EstimateTotalHeight() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[16]),sipPySelf,NULL,sipName_EstimateTotalHeight);

    if (!sipMeth)
        return  ::wxVarHVScrollHelper::EstimateTotalHeight();

    extern  ::wxCoord sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxCoord sipwxVarHVScrollHelper::OnGetRowHeight( ::size_t row) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[17]),sipPySelf,sipName_VarHVScrollHelper,sipName_OnGetRowHeight);

    if (!sipMeth)
        return 0;

    extern  ::wxCoord sipVH__core_134(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::size_t);

    return sipVH__core_134(sipGILState, 0, sipPySelf, sipMeth, row);
}

 ::wxCoord sipwxVarHVScrollHelper::sipProtectVirt_EstimateTotalWidth(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarHScrollHelper::EstimateTotalWidth() : EstimateTotalWidth());
}

void sipwxVarHVScrollHelper::sipProtectVirt_OnGetColumnsWidthHint(bool sipSelfWasArg, ::size_t columnMin, ::size_t columnMax) const
{
    (sipSelfWasArg ?  ::wxVarHScrollHelper::OnGetColumnsWidthHint(columnMin,columnMax) : OnGetColumnsWidthHint(columnMin,columnMax));
}

 ::wxCoord sipwxVarHVScrollHelper::sipProtect_OnGetColumnWidth( ::size_t column) const
{
    return OnGetColumnWidth(column);
}

void sipwxVarHVScrollHelper::sipProtectVirt_OnGetRowsHeightHint(bool sipSelfWasArg, ::size_t rowMin, ::size_t rowMax) const
{
    (sipSelfWasArg ?  ::wxVarVScrollHelper::OnGetRowsHeightHint(rowMin,rowMax) : OnGetRowsHeightHint(rowMin,rowMax));
}

 ::wxCoord sipwxVarHVScrollHelper::sipProtectVirt_EstimateTotalHeight(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxVarVScrollHelper::EstimateTotalHeight() : EstimateTotalHeight());
}

 ::wxCoord sipwxVarHVScrollHelper::sipProtect_OnGetRowHeight( ::size_t row) const
{
    return OnGetRowHeight(row);
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_EstimateTotalWidth, "EstimateTotalWidth() -> Coord\n"
"\n"
"This class forwards calls from EstimateTotalSize() to this function so\n"
"derived classes can override either just the height or the width\n"
"estimation, or just estimate both differently if desired in any\n"
"wxHVScrolledWindow derived class.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_EstimateTotalWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_EstimateTotalWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHVScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_EstimateTotalWidth(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_EstimateTotalWidth, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_OnGetColumnsWidthHint, "OnGetColumnsWidthHint(columnMin, columnMax)\n"
"\n"
"This function doesn't have to be overridden but it may be useful to do\n"
"so if calculating the columns' sizes is a relatively expensive\n"
"operation as it gives your code a chance to calculate several of them\n"
"at once and cache the result if necessary.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetColumnsWidthHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetColumnsWidthHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* columnMin;
        int columnMinState = 0;
         ::size_t* columnMax;
        int columnMaxState = 0;
        const sipwxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_columnMin,
            sipName_columnMax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&columnMin, &columnMinState, sipType_size_t,&columnMax, &columnMaxState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_OnGetColumnsWidthHint(sipSelfWasArg,*columnMin,*columnMax);
            Py_END_ALLOW_THREADS
            sipReleaseType(columnMin,sipType_size_t,columnMinState);
            sipReleaseType(columnMax,sipType_size_t,columnMaxState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_OnGetColumnsWidthHint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_OnGetColumnWidth, "OnGetColumnWidth(column) -> Coord\n"
"\n"
"This function must be overridden in the derived class, and should\n"
"return the width of the given column in pixels.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetColumnWidth(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetColumnWidth(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::size_t* column;
        int columnState = 0;
        const sipwxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&column, &columnState))
        {
             ::wxCoord sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_VarHVScrollHelper, sipName_OnGetColumnWidth);
                return NULL;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_OnGetColumnWidth(*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_OnGetColumnWidth, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_OnGetRowsHeightHint, "OnGetRowsHeightHint(rowMin, rowMax)\n"
"\n"
"This function doesn't have to be overridden but it may be useful to do\n"
"so if calculating the rows' sizes is a relatively expensive operation\n"
"as it gives your code a chance to calculate several of them at once\n"
"and cache the result if necessary.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetRowsHeightHint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetRowsHeightHint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* rowMin;
        int rowMinState = 0;
         ::size_t* rowMax;
        int rowMaxState = 0;
        const sipwxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowMin,
            sipName_rowMax,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&rowMin, &rowMinState, sipType_size_t,&rowMax, &rowMaxState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_OnGetRowsHeightHint(sipSelfWasArg,*rowMin,*rowMax);
            Py_END_ALLOW_THREADS
            sipReleaseType(rowMin,sipType_size_t,rowMinState);
            sipReleaseType(rowMax,sipType_size_t,rowMaxState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_OnGetRowsHeightHint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_EstimateTotalHeight, "EstimateTotalHeight() -> Coord\n"
"\n"
"This class forwards calls from EstimateTotalSize() to this function so\n"
"derived classes can override either just the height or the width\n"
"estimation, or just estimate both differently if desired in any\n"
"wxHVScrolledWindow derived class.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_EstimateTotalHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_EstimateTotalHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxVarHVScrollHelper *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp))
        {
             ::wxCoord sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_EstimateTotalHeight(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_EstimateTotalHeight, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_OnGetRowHeight, "OnGetRowHeight(row) -> Coord\n"
"\n"
"This function must be overridden in the derived class, and should\n"
"return the height of the given row in pixels.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetRowHeight(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetRowHeight(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::size_t* row;
        int rowState = 0;
        const sipwxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&row, &rowState))
        {
             ::wxCoord sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_VarHVScrollHelper, sipName_OnGetRowHeight);
                return NULL;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtect_OnGetRowHeight(*row);
            Py_END_ALLOW_THREADS
            sipReleaseType(row,sipType_size_t,rowState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_OnGetRowHeight, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_IsVisible, "IsVisible(row, column) -> bool\n"
"IsVisible(pos) -> bool\n"
"\n"
"Returns true if both the given row and column are currently visible\n"
"(even if only partially visible) or false otherwise.\n"
"");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_IsVisible(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_IsVisible(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* row;
        int rowState = 0;
         ::size_t* column;
        int columnState = 0;
        const  ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&row, &rowState, sipType_size_t,&column, &columnState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsVisible(*row,*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(row,sipType_size_t,rowState);
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxPosition* pos;
        int posState = 0;
        const  ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_wxPosition, &pos, &posState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsVisible(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPosition *>(pos),sipType_wxPosition,posState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_IsVisible, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_RefreshRowColumn, "RefreshRowColumn(row, column)\n"
"RefreshRowColumn(pos)\n"
"\n"
"Triggers a refresh for just the area shared between the given row and\n"
"column of the window if it is visible.\n"
"");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_RefreshRowColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_RefreshRowColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* row;
        int rowState = 0;
         ::size_t* column;
        int columnState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&row, &rowState, sipType_size_t,&column, &columnState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHVScrollHelper::RefreshRowColumn(*row,*column) : sipCpp->RefreshRowColumn(*row,*column));
            Py_END_ALLOW_THREADS
            sipReleaseType(row,sipType_size_t,rowState);
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPosition* pos;
        int posState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_wxPosition, &pos, &posState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHVScrollHelper::RefreshRowColumn(*pos) : sipCpp->RefreshRowColumn(*pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPosition *>(pos),sipType_wxPosition,posState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_RefreshRowColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_RefreshRowsColumns, "RefreshRowsColumns(fromRow, toRow, fromColumn, toColumn)\n"
"RefreshRowsColumns(from, to)\n"
"\n"
"Triggers a refresh for the visible area shared between all given rows\n"
"and columns (inclusive) of the window.\n"
"");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_RefreshRowsColumns(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_RefreshRowsColumns(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::size_t* fromRow;
        int fromRowState = 0;
         ::size_t* toRow;
        int toRowState = 0;
         ::size_t* fromColumn;
        int fromColumnState = 0;
         ::size_t* toColumn;
        int toColumnState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_fromRow,
            sipName_toRow,
            sipName_fromColumn,
            sipName_toColumn,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1J1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&fromRow, &fromRowState, sipType_size_t,&toRow, &toRowState, sipType_size_t,&fromColumn, &fromColumnState, sipType_size_t,&toColumn, &toColumnState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHVScrollHelper::RefreshRowsColumns(*fromRow,*toRow,*fromColumn,*toColumn) : sipCpp->RefreshRowsColumns(*fromRow,*toRow,*fromColumn,*toColumn));
            Py_END_ALLOW_THREADS
            sipReleaseType(fromRow,sipType_size_t,fromRowState);
            sipReleaseType(toRow,sipType_size_t,toRowState);
            sipReleaseType(fromColumn,sipType_size_t,fromColumnState);
            sipReleaseType(toColumn,sipType_size_t,toColumnState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPosition* from;
        int fromState = 0;
        const  ::wxPosition* to;
        int toState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_from,
            sipName_to,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_wxPosition, &from, &fromState, sipType_wxPosition, &to, &toState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxVarHVScrollHelper::RefreshRowsColumns(*from,*to) : sipCpp->RefreshRowsColumns(*from,*to));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPosition *>(from),sipType_wxPosition,fromState);
            sipReleaseType(const_cast< ::wxPosition *>(to),sipType_wxPosition,toState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_RefreshRowsColumns, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_ScrollToRowColumn, "ScrollToRowColumn(row, column) -> bool\n"
"ScrollToRowColumn(pos) -> bool\n"
"\n"
"Scroll to the specified row and column.\n"
"");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_ScrollToRowColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_ScrollToRowColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* row;
        int rowState = 0;
         ::size_t* column;
        int columnState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_row,
            sipName_column,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&row, &rowState, sipType_size_t,&column, &columnState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollToRowColumn(*row,*column);
            Py_END_ALLOW_THREADS
            sipReleaseType(row,sipType_size_t,rowState);
            sipReleaseType(column,sipType_size_t,columnState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::wxPosition* pos;
        int posState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_wxPosition, &pos, &posState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->ScrollToRowColumn(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPosition *>(pos),sipType_wxPosition,posState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_ScrollToRowColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_VirtualHitTest, "VirtualHitTest(x, y) -> Position\n"
"VirtualHitTest(pos) -> Position\n"
"\n"
"Returns the virtual scroll unit under the device unit given accounting\n"
"for scroll position or wxNOT_FOUND (for the row, column, or possibly\n"
"both values) if none.\n"
"");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_VirtualHitTest(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_VirtualHitTest(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
        const  ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, &x, &y))
        {
             ::wxPosition*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPosition(sipCpp->VirtualHitTest(x,y));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPosition,NULL);
        }
    }

    {
        const  ::wxPoint* pos;
        int posState = 0;
        const  ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_wxPoint, &pos, &posState))
        {
             ::wxPosition*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPosition(sipCpp->VirtualHitTest(*pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos),sipType_wxPoint,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPosition,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_VirtualHitTest, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_EnablePhysicalScrolling, "EnablePhysicalScrolling(vscrolling=True, hscrolling=True)\n"
"\n"
"With physical scrolling on (when this is true), the device origin is\n"
"changed properly when a wxPaintDC is prepared, children are actually\n"
"moved and laid out properly, and the contents of the window (pixels)\n"
"are actually moved.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_EnablePhysicalScrolling(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_EnablePhysicalScrolling(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        bool vscrolling = 1;
        bool hscrolling = 1;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_vscrolling,
            sipName_hscrolling,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|bb", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, &vscrolling, &hscrolling))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnablePhysicalScrolling(vscrolling,hscrolling);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_EnablePhysicalScrolling, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_GetRowColumnCount, "GetRowColumnCount() -> Size\n"
"\n"
"Returns the number of columns and rows the target window contains.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetRowColumnCount(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetRowColumnCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHVScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetRowColumnCount());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_GetRowColumnCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_GetVisibleBegin, "GetVisibleBegin() -> Position\n"
"\n"
"Returns the index of the first visible column and row based on the\n"
"current scroll position.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetVisibleBegin(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetVisibleBegin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHVScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp))
        {
             ::wxPosition*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPosition(sipCpp->GetVisibleBegin());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPosition,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_GetVisibleBegin, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_GetVisibleEnd, "GetVisibleEnd() -> Position\n"
"\n"
"Returns the index of the last visible column and row based on the\n"
"scroll position.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetVisibleEnd(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetVisibleEnd(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxVarHVScrollHelper *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp))
        {
             ::wxPosition*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPosition(sipCpp->GetVisibleEnd());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPosition,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_GetVisibleEnd, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxVarHVScrollHelper_SetRowColumnCount, "SetRowColumnCount(rowCount, columnCount)\n"
"\n"
"Set the number of rows and columns the target window will contain.");

extern "C" {static PyObject *meth_wxVarHVScrollHelper_SetRowColumnCount(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_SetRowColumnCount(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* rowCount;
        int rowCountState = 0;
         ::size_t* columnCount;
        int columnCountState = 0;
         ::wxVarHVScrollHelper *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rowCount,
            sipName_columnCount,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxVarHVScrollHelper, &sipCpp, sipType_size_t,&rowCount, &rowCountState, sipType_size_t,&columnCount, &columnCountState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetRowColumnCount(*rowCount,*columnCount);
            Py_END_ALLOW_THREADS
            sipReleaseType(rowCount,sipType_size_t,rowCountState);
            sipReleaseType(columnCount,sipType_size_t,columnCountState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_VarHVScrollHelper, sipName_SetRowColumnCount, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetUnitsSizeHint(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetUnitsSizeHint(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_OnGetUnitsSizeHint, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_EstimateTotalSize(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_EstimateTotalSize(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_EstimateTotalSize, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetNonOrientationTargetSize(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetNonOrientationTargetSize(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_GetNonOrientationTargetSize, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetOrientation(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetOrientation(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_GetOrientation, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_GetOrientationTargetSize(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_GetOrientationTargetSize(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_GetOrientationTargetSize, NULL);

    return NULL;
}


extern "C" {static PyObject *meth_wxVarHVScrollHelper_OnGetUnitSize(PyObject *, PyObject *);}
static PyObject *meth_wxVarHVScrollHelper_OnGetUnitSize(PyObject *, PyObject *)
{

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(NULL, sipName_VarHVScrollHelper, sipName_OnGetUnitSize, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxVarHVScrollHelper(void *, const sipTypeDef *);}
static void *cast_wxVarHVScrollHelper(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxVarHVScrollHelper *sipCpp = reinterpret_cast< ::wxVarHVScrollHelper *>(sipCppV);

    if (targetType == sipType_wxVarVScrollHelper)
        return static_cast< ::wxVarVScrollHelper *>(sipCpp);

    if (targetType == sipType_wxVarHScrollHelper)
        return static_cast< ::wxVarHScrollHelper *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxVarHVScrollHelper(void *, int);}
static void release_wxVarHVScrollHelper(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxVarHVScrollHelper *>(sipCppV);
    else
        delete reinterpret_cast< ::wxVarHVScrollHelper *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxVarHVScrollHelper(sipSimpleWrapper *);}
static void dealloc_wxVarHVScrollHelper(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxVarHVScrollHelper *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxVarHVScrollHelper(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxVarHVScrollHelper(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxVarHVScrollHelper(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxVarHVScrollHelper *sipCpp = 0;

    {
         ::wxWindow* winToScroll;

        static const char *sipKwdList[] = {
            sipName_winToScroll,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J8", sipType_wxWindow, &winToScroll))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxVarHVScrollHelper(winToScroll);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::wxVarHVScrollHelper* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_wxVarHVScrollHelper, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxVarHVScrollHelper(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxVarHVScrollHelper[] = {{564, 255, 0}, {561, 255, 1}};


static PyMethodDef methods_wxVarHVScrollHelper[] = {
    {SIP_MLNAME_CAST(sipName_EnablePhysicalScrolling), (PyCFunction)meth_wxVarHVScrollHelper_EnablePhysicalScrolling, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_EnablePhysicalScrolling)},
    {SIP_MLNAME_CAST(sipName_EstimateTotalHeight), (PyCFunction)meth_wxVarHVScrollHelper_EstimateTotalHeight, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_EstimateTotalSize), meth_wxVarHVScrollHelper_EstimateTotalSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_EstimateTotalWidth), (PyCFunction)meth_wxVarHVScrollHelper_EstimateTotalWidth, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_GetNonOrientationTargetSize), meth_wxVarHVScrollHelper_GetNonOrientationTargetSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetOrientation), meth_wxVarHVScrollHelper_GetOrientation, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetOrientationTargetSize), meth_wxVarHVScrollHelper_GetOrientationTargetSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_GetRowColumnCount), meth_wxVarHVScrollHelper_GetRowColumnCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_GetRowColumnCount)},
    {SIP_MLNAME_CAST(sipName_GetVisibleBegin), meth_wxVarHVScrollHelper_GetVisibleBegin, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_GetVisibleBegin)},
    {SIP_MLNAME_CAST(sipName_GetVisibleEnd), meth_wxVarHVScrollHelper_GetVisibleEnd, METH_VARARGS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_GetVisibleEnd)},
    {SIP_MLNAME_CAST(sipName_IsVisible), (PyCFunction)meth_wxVarHVScrollHelper_IsVisible, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_IsVisible)},
    {SIP_MLNAME_CAST(sipName_OnGetColumnWidth), (PyCFunction)meth_wxVarHVScrollHelper_OnGetColumnWidth, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_OnGetColumnsWidthHint), (PyCFunction)meth_wxVarHVScrollHelper_OnGetColumnsWidthHint, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_OnGetRowHeight), (PyCFunction)meth_wxVarHVScrollHelper_OnGetRowHeight, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_OnGetRowsHeightHint), (PyCFunction)meth_wxVarHVScrollHelper_OnGetRowsHeightHint, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_OnGetUnitSize), meth_wxVarHVScrollHelper_OnGetUnitSize, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_OnGetUnitsSizeHint), meth_wxVarHVScrollHelper_OnGetUnitsSizeHint, METH_VARARGS, NULL},
    {SIP_MLNAME_CAST(sipName_RefreshRowColumn), (PyCFunction)meth_wxVarHVScrollHelper_RefreshRowColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_RefreshRowColumn)},
    {SIP_MLNAME_CAST(sipName_RefreshRowsColumns), (PyCFunction)meth_wxVarHVScrollHelper_RefreshRowsColumns, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_RefreshRowsColumns)},
    {SIP_MLNAME_CAST(sipName_ScrollToRowColumn), (PyCFunction)meth_wxVarHVScrollHelper_ScrollToRowColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_ScrollToRowColumn)},
    {SIP_MLNAME_CAST(sipName_SetRowColumnCount), (PyCFunction)meth_wxVarHVScrollHelper_SetRowColumnCount, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_SetRowColumnCount)},
    {SIP_MLNAME_CAST(sipName_VirtualHitTest), (PyCFunction)meth_wxVarHVScrollHelper_VirtualHitTest, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxVarHVScrollHelper_VirtualHitTest)}
};

sipVariableDef variables_wxVarHVScrollHelper[] = {
    {PropertyVariable, sipName_VisibleEnd, &methods_wxVarHVScrollHelper[9], NULL, NULL, NULL},
    {PropertyVariable, sipName_VisibleBegin, &methods_wxVarHVScrollHelper[8], NULL, NULL, NULL},
    {PropertyVariable, sipName_RowColumnCount, &methods_wxVarHVScrollHelper[7], &methods_wxVarHVScrollHelper[20], NULL, NULL},
};

PyDoc_STRVAR(doc_wxVarHVScrollHelper, "VarHVScrollHelper(winToScroll)\n"
"\n"
"This class provides functions wrapping the wxVarHScrollHelper and\n"
"wxVarVScrollHelper classes, targeted for scrolling a window in both\n"
"axis.");


sipClassTypeDef sipTypeDef__core_wxVarHVScrollHelper = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_CLASS,
        sipNameNr_wxVarHVScrollHelper,
        {0},
        0
    },
    {
        sipNameNr_VarHVScrollHelper,
        {0, 0, 1},
        22, methods_wxVarHVScrollHelper,
        0, 0,
        3, variables_wxVarHVScrollHelper,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxVarHVScrollHelper,
    -1,
    -1,
    supers_wxVarHVScrollHelper,
    0,
    init_type_wxVarHVScrollHelper,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxVarHVScrollHelper,
    0,
    0,
    0,
    release_wxVarHVScrollHelper,
    cast_wxVarHVScrollHelper,
    0,
    0,
    0,
    0,
    0,
    0
};
