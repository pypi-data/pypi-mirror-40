/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/sizer.h>

        #include <wx/window.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/sizer.h>
        #include <wx/sizer.h>
        
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    wxSizerItem* _wxSizer_Add(wxSizer* self, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Add(size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Add(wxSizer* self, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Add(size->x, size->y, *flags);
    }
    wxSizerItem* _wxSizer_Insert(wxSizer* self, ulong index, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Insert(index, size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Insert(wxSizer* self, ulong index, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Insert(index, size->x, size->y, *flags);
    }
    wxSizerItem* _wxSizer_Prepend(wxSizer* self, const wxSize* size, int proportion, int flag, int border, wxPyUserData* userData )
    {
        return self->Prepend(size->x, size->y, proportion, flag, border, userData);
    }
    wxSizerItem* _wxSizer_Prepend(wxSizer* self, const wxSize* size, const wxSizerFlags* flags)
    {
        return self->Prepend(size->x, size->y, *flags);
    }


class sipwxSizer : public  ::wxSizer
{
public:
    sipwxSizer();
    virtual ~sipwxSizer();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void RecalcSizes();
     ::wxSize CalcMin();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxSizer(const sipwxSizer &);
    sipwxSizer &operator = (const sipwxSizer &);

    char sipPyMethods[2];
};

sipwxSizer::sipwxSizer():  ::wxSizer(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxSizer::~sipwxSizer()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipwxSizer::RecalcSizes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,sipName_Sizer,sipName_RecalcSizes);

    if (!sipMeth)
        return;

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxSizer::CalcMin()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,sipName_Sizer,sipName_CalcMin);

    if (!sipMeth)
        return  ::wxSize();

    extern  ::wxSize sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_wxSizer_GetChildren, "GetChildren() -> SizerItemList\n"
"\n"
"Returns the list of the items in this sizer.");

extern "C" {static PyObject *meth_wxSizer_GetChildren(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSizerItemList*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->GetChildren();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItemList,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetChildren, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetItemMinSize, "SetItemMinSize(window, width, height) -> bool\n"
"SetItemMinSize(window, size) -> bool\n"
"SetItemMinSize(sizer, width, height) -> bool\n"
"SetItemMinSize(sizer, size) -> bool\n"
"SetItemMinSize(index, width, height) -> bool\n"
"SetItemMinSize(index, size) -> bool\n"
"\n"
"Set an item's minimum size by window, sizer, or position.\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetItemMinSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetItemMinSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8ii", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(window,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxWindow* window;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(window,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8ii", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(sizer,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(sizer,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1ii", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &width, &height))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(*index,width,height);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxSize, &size, &sizeState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->SetItemMinSize(*index,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetItemMinSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Add, "Add(window, flags) -> SizerItem\n"
"Add(window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(sizer, flags) -> SizerItem\n"
"Add(sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Add(width, height, flags) -> SizerItem\n"
"Add(item) -> SizerItem\n"
"Add(size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Add(size, flags) -> SizerItem\n"
"\n"
"Appends a child to the sizer.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Add(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Add(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(window,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(sizer,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiiJ9", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(width,height,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Add(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Add(sipCpp, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Add(sipCpp, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Add, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_AddSpacer, "AddSpacer(size) -> SizerItem\n"
"\n"
"This base function adds non-stretchable space to both the horizontal\n"
"and vertical orientation of the sizer.");

extern "C" {static PyObject *meth_wxSizer_AddSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_AddSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AddSpacer(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_AddSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_AddStretchSpacer, "AddStretchSpacer(prop=1) -> SizerItem\n"
"\n"
"Adds stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_AddStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_AddStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|i", &sipSelf, sipType_wxSizer, &sipCpp, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->AddStretchSpacer(prop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_AddStretchSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_CalcMin, "CalcMin() -> Size\n"
"\n"
"This method is abstract and has to be overwritten by any derived\n"
"class.");

extern "C" {static PyObject *meth_wxSizer_CalcMin(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_CalcMin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Sizer, sipName_CalcMin);
                return NULL;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->CalcMin());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_CalcMin, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Clear, "Clear(delete_windows=False)\n"
"\n"
"Detaches all children from the sizer.");

extern "C" {static PyObject *meth_wxSizer_Clear(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Clear(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        bool delete_windows = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_delete_windows,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|b", &sipSelf, sipType_wxSizer, &sipCpp, &delete_windows))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Clear(delete_windows);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Clear, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_ComputeFittingClientSize, "ComputeFittingClientSize(window) -> Size\n"
"\n"
"Computes client area size for window so that it matches the sizer's\n"
"minimal size.");

extern "C" {static PyObject *meth_wxSizer_ComputeFittingClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ComputeFittingClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ComputeFittingClientSize(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ComputeFittingClientSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_ComputeFittingWindowSize, "ComputeFittingWindowSize(window) -> Size\n"
"\n"
"Like ComputeFittingClientSize(), but converts the result into window\n"
"size.");

extern "C" {static PyObject *meth_wxSizer_ComputeFittingWindowSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ComputeFittingWindowSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->ComputeFittingWindowSize(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ComputeFittingWindowSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Detach, "Detach(window) -> bool\n"
"Detach(sizer) -> bool\n"
"Detach(index) -> bool\n"
"\n"
"Detach the child window from the sizer without destroying it.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Detach(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Detach(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Detach(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Detach, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Fit, "Fit(window) -> Size\n"
"\n"
"Tell the sizer to resize the window so that its client area matches\n"
"the sizer's minimal size (ComputeFittingClientSize() is called to\n"
"determine it).");

extern "C" {static PyObject *meth_wxSizer_Fit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Fit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->Fit(window));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Fit, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_FitInside, "FitInside(window)\n"
"\n"
"Tell the sizer to resize the virtual size of the window to match the\n"
"sizer's minimal size.");

extern "C" {static PyObject *meth_wxSizer_FitInside(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_FitInside(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->FitInside(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_FitInside, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_InformFirstDirection, "InformFirstDirection(direction, size, availableOtherDir) -> bool\n"
"\n"
"Inform sizer about the first direction that has been decided (by\n"
"parent item).");

extern "C" {static PyObject *meth_wxSizer_InformFirstDirection(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InformFirstDirection(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int direction;
        int size;
        int availableOtherDir;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_direction,
            sipName_size,
            sipName_availableOtherDir,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biii", &sipSelf, sipType_wxSizer, &sipCpp, &direction, &size, &availableOtherDir))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InformFirstDirection(direction,size,availableOtherDir);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InformFirstDirection, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetContainingWindow, "GetContainingWindow() -> Window\n"
"\n"
"Returns the window this sizer is used in or NULL if none.");

extern "C" {static PyObject *meth_wxSizer_GetContainingWindow(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetContainingWindow(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxWindow*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetContainingWindow();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxWindow,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetContainingWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetContainingWindow, "SetContainingWindow(window)\n"
"\n"
"Set the window this sizer is used in.");

extern "C" {static PyObject *meth_wxSizer_SetContainingWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetContainingWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetContainingWindow(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetContainingWindow, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetItemCount, "GetItemCount() -> size_t\n"
"\n"
"Returns the number of items in the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetItemCount(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItemCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetItemCount());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItemCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetItem, "GetItem(window, recursive=False) -> SizerItem\n"
"GetItem(sizer, recursive=False) -> SizerItem\n"
"GetItem(index) -> SizerItem\n"
"\n"
"Finds wxSizerItem which holds the given window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_GetItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(window,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizer* sizer;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(sizer,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItem(*index);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetItemById, "GetItemById(id, recursive=False) -> SizerItem\n"
"\n"
"Finds item of the sizer which has the given id.");

extern "C" {static PyObject *meth_wxSizer_GetItemById(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetItemById(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi|b", &sipSelf, sipType_wxSizer, &sipCpp, &id, &recursive))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetItemById(id,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetItemById, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetMinSize, "GetMinSize() -> Size\n"
"\n"
"Returns the minimal size of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetMinSize(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetMinSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetMinSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetMinSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetPosition, "GetPosition() -> Point\n"
"\n"
"Returns the current position of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetPosition(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetPosition(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPosition());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetPosition, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_GetSize, "GetSize() -> Size\n"
"\n"
"Returns the current size of the sizer.");

extern "C" {static PyObject *meth_wxSizer_GetSize(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_GetSize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->GetSize());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_GetSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Hide, "Hide(window, recursive=False) -> bool\n"
"Hide(sizer, recursive=False) -> bool\n"
"Hide(index) -> bool\n"
"\n"
"Hides the child window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Hide(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Hide(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(window,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(sizer,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Hide(*index);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Hide, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Insert, "Insert(index, window, flags) -> SizerItem\n"
"Insert(index, window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, sizer, flags) -> SizerItem\n"
"Insert(index, sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Insert(index, width, height, flags) -> SizerItem\n"
"Insert(index, item) -> SizerItem\n"
"Insert(index, size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Insert(index, size, flags) -> SizerItem\n"
"\n"
"Insert a child into the sizer before any existing item at index.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Insert(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Insert(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* index;
        int indexState = 0;
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J8J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,window,*flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,sizer,*flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1ii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1iiJ9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,width,height,*flags);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*index,item);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::ulong index;
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BmJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Insert(sipCpp, index, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::ulong index;
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BmJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, &index, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Insert(sipCpp, index, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Insert, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_InsertSpacer, "InsertSpacer(index, size) -> SizerItem\n"
"\n"
"Inserts non-stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_InsertSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InsertSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* index;
        int indexState = 0;
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1i", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertSpacer(*index,size);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InsertSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_InsertStretchSpacer, "InsertStretchSpacer(index, prop=1) -> SizerItem\n"
"\n"
"Inserts stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_InsertStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_InsertStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* index;
        int indexState = 0;
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1|i", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->InsertStretchSpacer(*index,prop);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_InsertStretchSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_IsEmpty, "IsEmpty() -> bool\n"
"\n"
"Return true if the sizer has no elements.");

extern "C" {static PyObject *meth_wxSizer_IsEmpty(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_IsEmpty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEmpty();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_IsEmpty, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_IsShown, "IsShown(window) -> bool\n"
"IsShown(sizer) -> bool\n"
"IsShown(index) -> bool\n"
"\n"
"Returns true if the window is shown.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_IsShown(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_IsShown(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        const  ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsShown(*index);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_IsShown, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Layout, "Layout()\n"
"\n"
"Call this to force layout of the children anew, e.g. after having\n"
"added a child to or removed a child (window, other sizer or space)\n"
"from the sizer while keeping the current dimension.");

extern "C" {static PyObject *meth_wxSizer_Layout(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Layout(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Layout();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Layout, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Prepend, "Prepend(window, flags) -> SizerItem\n"
"Prepend(window, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(sizer, flags) -> SizerItem\n"
"Prepend(sizer, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(width, height, proportion=0, flag=0, border=0, userData=None) -> SizerItem\n"
"Prepend(width, height, flags) -> SizerItem\n"
"Prepend(item) -> SizerItem\n"
"Prepend(size, proportion=0, flag=0, border=0, /Transfer/=None) -> SizerItem\n"
"Prepend(size, flags) -> SizerItem\n"
"\n"
"Same as Add(), but prepends the items to the beginning of the list of\n"
"items (windows, subsizers or spaces) owned by this sizer.\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Prepend(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Prepend(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(window,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxWindow* window;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(window,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizer* sizer;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(sizer,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizer* sizer;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(sizer,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        int width;
        int height;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(width,height,proportion,flag,border,userData);
            Py_END_ALLOW_THREADS
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        int width;
        int height;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiiJ9", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(width,height,*flags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
         ::wxSizerItem* item;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizerItem, &item))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Prepend(item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        int proportion = 0;
        int flag = 0;
        int border = 0;
         ::wxPyUserData* userData = 0;
        int userDataState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_proportion,
            sipName_flag,
            sipName_border,
            sipName_userData,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1|iiiJ2", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, &proportion, &flag, &border, sipType_wxPyUserData,&userData, &userDataState))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Prepend(sipCpp, size, proportion, flag, border, userData);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);
            sipReleaseType(userData,sipType_wxPyUserData,userDataState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    {
        const  ::wxSize* size;
        int sizeState = 0;
        const  ::wxSizerFlags* flags;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
            sipName_flags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J9", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState, sipType_wxSizerFlags, &flags))
        {
             ::wxSizerItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxSizer_Prepend(sipCpp, size, flags);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Prepend, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_PrependSpacer, "PrependSpacer(size) -> SizerItem\n"
"\n"
"Prepends non-stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_PrependSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_PrependSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int size;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &size))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependSpacer(size);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_PrependSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_PrependStretchSpacer, "PrependStretchSpacer(prop=1) -> SizerItem\n"
"\n"
"Prepends stretchable space to the sizer.");

extern "C" {static PyObject *meth_wxSizer_PrependStretchSpacer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_PrependStretchSpacer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int prop = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_prop,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|i", &sipSelf, sipType_wxSizer, &sipCpp, &prop))
        {
             ::wxSizerItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->PrependStretchSpacer(prop);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxSizerItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_PrependStretchSpacer, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_RecalcSizes, "RecalcSizes()\n"
"\n"
"This method is abstract and has to be overwritten by any derived\n"
"class.");

extern "C" {static PyObject *meth_wxSizer_RecalcSizes(PyObject *, PyObject *);}
static PyObject *meth_wxSizer_RecalcSizes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    PyObject *sipOrigSelf = sipSelf;

    {
         ::wxSizer *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSizer, &sipCpp))
        {
            if (!sipOrigSelf)
            {
                sipAbstractMethod(sipName_Sizer, sipName_RecalcSizes);
                return NULL;
            }

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->RecalcSizes();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_RecalcSizes, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Remove, "Remove(sizer) -> bool\n"
"Remove(index) -> bool\n"
"\n"
"Removes a sizer child from the sizer and destroys it.\n"
"");

extern "C" {static PyObject *meth_wxSizer_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSizer* sizer;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(sizer);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
        int index;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxSizer, &sipCpp, &index))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Remove, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Replace, "Replace(oldwin, newwin, recursive=False) -> bool\n"
"Replace(oldsz, newsz, recursive=False) -> bool\n"
"Replace(index, newitem) -> bool\n"
"\n"
"Detaches the given oldwin from the sizer and replaces it with the\n"
"given newwin.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Replace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Replace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* oldwin;
         ::wxWindow* newwin;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldwin,
            sipName_newwin,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &oldwin, sipType_wxWindow, &newwin, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(oldwin,newwin,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* oldsz;
         ::wxSizer* newsz;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_oldsz,
            sipName_newsz,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8J8|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &oldsz, sipType_wxSizer, &newsz, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(oldsz,newsz,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
         ::wxSizerItem* newitem;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_newitem,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, sipType_wxSizerItem, &newitem))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(*index,newitem);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Replace, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetDimension, "SetDimension(x, y, width, height)\n"
"SetDimension(pos, size)\n"
"\n"
"Call this to force the sizer to take the given dimension and thus\n"
"force the items owned by the sizer to resize themselves according to\n"
"the rules defined by the parameter in the Add() and Prepend() methods.\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetDimension(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetDimension(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int x;
        int y;
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biiii", &sipSelf, sipType_wxSizer, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDimension(x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPoint* pos;
        int posState = 0;
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxPoint, &pos, &posState, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetDimension(*pos,*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pos),sipType_wxPoint,posState);
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetDimension, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetMinSize, "SetMinSize(size)\n"
"SetMinSize(width, height)\n"
"\n"
"Call this to give the sizer a minimal size.\n"
"");

extern "C" {static PyObject *meth_wxSizer_SetMinSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetMinSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxSize* size;
        int sizeState = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSize, &size, &sizeState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinSize(*size);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxSize *>(size),sipType_wxSize,sizeState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        int width;
        int height;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii", &sipSelf, sipType_wxSizer, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMinSize(width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetMinSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetSizeHints, "SetSizeHints(window)\n"
"\n"
"This method first calls Fit() and then\n"
"wxTopLevelWindow::SetSizeHints() on the window passed to it.");

extern "C" {static PyObject *meth_wxSizer_SetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetSizeHints(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetSizeHints, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_SetVirtualSizeHints, "SetVirtualSizeHints(window)\n"
"\n"
"Tell the sizer to set the minimal size of the window virtual area to\n"
"match the sizer's minimal size.");

extern "C" {static PyObject *meth_wxSizer_SetVirtualSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_SetVirtualSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window))
        {
            if (sipDeprecated(sipName_Sizer,sipName_SetVirtualSizeHints) < 0)
                return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetVirtualSizeHints(window);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_SetVirtualSizeHints, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_Show, "Show(window, show=True, recursive=False) -> bool\n"
"Show(sizer, show=True, recursive=False) -> bool\n"
"Show(index, show=True) -> bool\n"
"\n"
"Shows or hides the window.\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSizer_Show(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_Show(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxWindow* window;
        bool show = 1;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_window,
            sipName_show,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|bb", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxWindow, &window, &show, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(window,show,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::wxSizer* sizer;
        bool show = 1;
        bool recursive = 0;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_sizer,
            sipName_show,
            sipName_recursive,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8|bb", &sipSelf, sipType_wxSizer, &sipCpp, sipType_wxSizer, &sizer, &show, &recursive))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(sizer,show,recursive);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    {
         ::size_t* index;
        int indexState = 0;
        bool show = 1;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1|b", &sipSelf, sipType_wxSizer, &sipCpp, sipType_size_t,&index, &indexState, &show))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Show(*index,show);
            Py_END_ALLOW_THREADS
            sipReleaseType(index,sipType_size_t,indexState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_Show, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSizer_ShowItems, "ShowItems(show)\n"
"\n"
"Show or hide all items managed by the sizer.");

extern "C" {static PyObject *meth_wxSizer_ShowItems(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSizer_ShowItems(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        bool show;
         ::wxSizer *sipCpp;

        static const char *sipKwdList[] = {
            sipName_show,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bb", &sipSelf, sipType_wxSizer, &sipCpp, &show))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->ShowItems(show);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Sizer, sipName_ShowItems, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxSizer(void *, const sipTypeDef *);}
static void *cast_wxSizer(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxSizer *sipCpp = reinterpret_cast< ::wxSizer *>(sipCppV);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxSizer(void *, int);}
static void release_wxSizer(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxSizer *>(sipCppV);
    else
        delete reinterpret_cast< ::wxSizer *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxSizer(sipSimpleWrapper *);}
static void dealloc_wxSizer(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxSizer *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxSizer(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxSizer(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxSizer(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxSizer *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxSizer();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxSizer[] = {{358, 255, 1}};


static PyMethodDef methods_wxSizer[] = {
    {SIP_MLNAME_CAST(sipName_Add), (PyCFunction)meth_wxSizer_Add, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Add)},
    {SIP_MLNAME_CAST(sipName_AddSpacer), (PyCFunction)meth_wxSizer_AddSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_AddSpacer)},
    {SIP_MLNAME_CAST(sipName_AddStretchSpacer), (PyCFunction)meth_wxSizer_AddStretchSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_AddStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_CalcMin), meth_wxSizer_CalcMin, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_CalcMin)},
    {SIP_MLNAME_CAST(sipName_Clear), (PyCFunction)meth_wxSizer_Clear, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Clear)},
    {SIP_MLNAME_CAST(sipName_ComputeFittingClientSize), (PyCFunction)meth_wxSizer_ComputeFittingClientSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ComputeFittingClientSize)},
    {SIP_MLNAME_CAST(sipName_ComputeFittingWindowSize), (PyCFunction)meth_wxSizer_ComputeFittingWindowSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ComputeFittingWindowSize)},
    {SIP_MLNAME_CAST(sipName_Detach), (PyCFunction)meth_wxSizer_Detach, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Detach)},
    {SIP_MLNAME_CAST(sipName_Fit), (PyCFunction)meth_wxSizer_Fit, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Fit)},
    {SIP_MLNAME_CAST(sipName_FitInside), (PyCFunction)meth_wxSizer_FitInside, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_FitInside)},
    {SIP_MLNAME_CAST(sipName_GetChildren), meth_wxSizer_GetChildren, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetChildren)},
    {SIP_MLNAME_CAST(sipName_GetContainingWindow), meth_wxSizer_GetContainingWindow, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetContainingWindow)},
    {SIP_MLNAME_CAST(sipName_GetItem), (PyCFunction)meth_wxSizer_GetItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_GetItem)},
    {SIP_MLNAME_CAST(sipName_GetItemById), (PyCFunction)meth_wxSizer_GetItemById, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_GetItemById)},
    {SIP_MLNAME_CAST(sipName_GetItemCount), meth_wxSizer_GetItemCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetItemCount)},
    {SIP_MLNAME_CAST(sipName_GetMinSize), meth_wxSizer_GetMinSize, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetMinSize)},
    {SIP_MLNAME_CAST(sipName_GetPosition), meth_wxSizer_GetPosition, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetPosition)},
    {SIP_MLNAME_CAST(sipName_GetSize), meth_wxSizer_GetSize, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_GetSize)},
    {SIP_MLNAME_CAST(sipName_Hide), (PyCFunction)meth_wxSizer_Hide, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Hide)},
    {SIP_MLNAME_CAST(sipName_InformFirstDirection), (PyCFunction)meth_wxSizer_InformFirstDirection, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InformFirstDirection)},
    {SIP_MLNAME_CAST(sipName_Insert), (PyCFunction)meth_wxSizer_Insert, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Insert)},
    {SIP_MLNAME_CAST(sipName_InsertSpacer), (PyCFunction)meth_wxSizer_InsertSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InsertSpacer)},
    {SIP_MLNAME_CAST(sipName_InsertStretchSpacer), (PyCFunction)meth_wxSizer_InsertStretchSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_InsertStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_IsEmpty), meth_wxSizer_IsEmpty, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_IsEmpty)},
    {SIP_MLNAME_CAST(sipName_IsShown), (PyCFunction)meth_wxSizer_IsShown, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_IsShown)},
    {SIP_MLNAME_CAST(sipName_Layout), meth_wxSizer_Layout, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_Layout)},
    {SIP_MLNAME_CAST(sipName_Prepend), (PyCFunction)meth_wxSizer_Prepend, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Prepend)},
    {SIP_MLNAME_CAST(sipName_PrependSpacer), (PyCFunction)meth_wxSizer_PrependSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_PrependSpacer)},
    {SIP_MLNAME_CAST(sipName_PrependStretchSpacer), (PyCFunction)meth_wxSizer_PrependStretchSpacer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_PrependStretchSpacer)},
    {SIP_MLNAME_CAST(sipName_RecalcSizes), meth_wxSizer_RecalcSizes, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSizer_RecalcSizes)},
    {SIP_MLNAME_CAST(sipName_Remove), (PyCFunction)meth_wxSizer_Remove, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Remove)},
    {SIP_MLNAME_CAST(sipName_Replace), (PyCFunction)meth_wxSizer_Replace, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Replace)},
    {SIP_MLNAME_CAST(sipName_SetContainingWindow), (PyCFunction)meth_wxSizer_SetContainingWindow, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetContainingWindow)},
    {SIP_MLNAME_CAST(sipName_SetDimension), (PyCFunction)meth_wxSizer_SetDimension, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetDimension)},
    {SIP_MLNAME_CAST(sipName_SetItemMinSize), (PyCFunction)meth_wxSizer_SetItemMinSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetItemMinSize)},
    {SIP_MLNAME_CAST(sipName_SetMinSize), (PyCFunction)meth_wxSizer_SetMinSize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetMinSize)},
    {SIP_MLNAME_CAST(sipName_SetSizeHints), (PyCFunction)meth_wxSizer_SetSizeHints, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetSizeHints)},
    {SIP_MLNAME_CAST(sipName_SetVirtualSizeHints), (PyCFunction)meth_wxSizer_SetVirtualSizeHints, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_SetVirtualSizeHints)},
    {SIP_MLNAME_CAST(sipName_Show), (PyCFunction)meth_wxSizer_Show, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_Show)},
    {SIP_MLNAME_CAST(sipName_ShowItems), (PyCFunction)meth_wxSizer_ShowItems, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSizer_ShowItems)}
};

sipVariableDef variables_wxSizer[] = {
    {PropertyVariable, sipName_Size, &methods_wxSizer[17], NULL, NULL, NULL},
    {PropertyVariable, sipName_Position, &methods_wxSizer[16], NULL, NULL, NULL},
    {PropertyVariable, sipName_MinSize, &methods_wxSizer[15], &methods_wxSizer[35], NULL, NULL},
    {PropertyVariable, sipName_ItemCount, &methods_wxSizer[14], NULL, NULL, NULL},
    {PropertyVariable, sipName_ContainingWindow, &methods_wxSizer[11], &methods_wxSizer[32], NULL, NULL},
    {PropertyVariable, sipName_Children, &methods_wxSizer[10], NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_wxSizer, "Sizer()\n"
"\n"
"wxSizer is the abstract base class used for laying out subwindows in a\n"
"window.");


sipClassTypeDef sipTypeDef__core_wxSizer = {
    {
        -1,
        0,
        0,
        SIP_TYPE_ABSTRACT|SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxSizer,
        {0},
        0
    },
    {
        sipNameNr_Sizer,
        {0, 0, 1},
        40, methods_wxSizer,
        0, 0,
        6, variables_wxSizer,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxSizer,
    -1,
    -1,
    supers_wxSizer,
    0,
    init_type_wxSizer,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxSizer,
    0,
    0,
    0,
    release_wxSizer,
    cast_wxSizer,
    0,
    0,
    0,
    0,
    0,
    0
};
