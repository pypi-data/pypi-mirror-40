/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/listctrl.h>

        #include <wx/event.h>
        #include <wx/listctrl.h>
        #include <wx/gdicmn.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxListEvent : public  ::wxListEvent
{
public:
    sipwxListEvent( ::wxEventType,int);
    sipwxListEvent(const  ::wxListEvent&);
    virtual ~sipwxListEvent();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
     ::wxEvent* Clone() const;
     ::wxEventCategory GetEventCategory() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxListEvent(const sipwxListEvent &);
    sipwxListEvent &operator = (const sipwxListEvent &);

    char sipPyMethods[2];
};

sipwxListEvent::sipwxListEvent( ::wxEventType commandType,int id):  ::wxListEvent(commandType,id), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxListEvent::sipwxListEvent(const  ::wxListEvent& a0):  ::wxListEvent(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxListEvent::~sipwxListEvent()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

 ::wxEvent* sipwxListEvent::Clone() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[0]),sipPySelf,NULL,sipName_Clone);

    if (!sipMeth)
        return  ::wxListEvent::Clone();

    extern  ::wxEvent* sipVH__core_95(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_95(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxEventCategory sipwxListEvent::GetEventCategory() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[1]),sipPySelf,NULL,sipName_GetEventCategory);

    if (!sipMeth)
        return  ::wxListEvent::GetEventCategory();

    extern  ::wxEventCategory sipVH__core_96(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_96(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_wxListEvent_GetCacheFrom, "GetCacheFrom() -> long\n"
"\n"
"For EVT_LIST_CACHE_HINT event only: return the first item which the\n"
"list control advises us to cache.");

extern "C" {static PyObject *meth_wxListEvent_GetCacheFrom(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetCacheFrom(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCacheFrom();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetCacheFrom, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetCacheTo, "GetCacheTo() -> long\n"
"\n"
"For EVT_LIST_CACHE_HINT event only: return the last item (inclusive)\n"
"which the list control advises us to cache.");

extern "C" {static PyObject *meth_wxListEvent_GetCacheTo(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetCacheTo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetCacheTo();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetCacheTo, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetColumn, "GetColumn() -> int\n"
"\n"
"The column position: it is only used with COL events.");

extern "C" {static PyObject *meth_wxListEvent_GetColumn(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetColumn(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetColumn();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetData, "GetData() -> UIntPtr\n"
"\n"
"The data.");

extern "C" {static PyObject *meth_wxListEvent_GetData(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxUIntPtr*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxUIntPtr(sipCpp->GetData());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxUIntPtr,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetData, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetImage, "GetImage() -> int\n"
"\n"
"The image.");

extern "C" {static PyObject *meth_wxListEvent_GetImage(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetImage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetImage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetImage, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetIndex, "GetIndex() -> long\n"
"\n"
"The item index.");

extern "C" {static PyObject *meth_wxListEvent_GetIndex(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetIndex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetIndex();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetIndex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetItem, "GetItem() -> ListItem\n"
"\n"
"An item object, used by some events.");

extern "C" {static PyObject *meth_wxListEvent_GetItem(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetItem(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxListItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxListItem(sipCpp->GetItem());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxListItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetKeyCode, "GetKeyCode() -> int\n"
"\n"
"Key code if the event is a keypress event.");

extern "C" {static PyObject *meth_wxListEvent_GetKeyCode(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetKeyCode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetKeyCode();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetKeyCode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetLabel, "GetLabel() -> String\n"
"\n"
"The (new) item label for EVT_LIST_END_LABEL_EDIT event.");

extern "C" {static PyObject *meth_wxListEvent_GetLabel(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetLabel(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabel());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetMask, "GetMask() -> long\n"
"\n"
"The mask.");

extern "C" {static PyObject *meth_wxListEvent_GetMask(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetMask(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            long sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMask();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetMask, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetPoint, "GetPoint() -> Point\n"
"\n"
"The position of the mouse pointer if the event is a drag event.");

extern "C" {static PyObject *meth_wxListEvent_GetPoint(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxPoint*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxPoint(sipCpp->GetPoint());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxPoint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetPoint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_GetText, "GetText() -> String\n"
"\n"
"The text.");

extern "C" {static PyObject *meth_wxListEvent_GetText(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_GetText(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetText());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_GetText, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_IsEditCancelled, "IsEditCancelled() -> bool\n"
"\n"
"This method only makes sense for EVT_LIST_END_LABEL_EDIT message and\n"
"returns true if it the label editing has been cancelled by the user\n"
"(GetLabel() returns an empty string in this case but it doesn't allow\n"
"the application to distinguish between really cancelling the edit and\n"
"the admittedly rare case when the user wants to rename it to an empty\n"
"string).");

extern "C" {static PyObject *meth_wxListEvent_IsEditCancelled(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_IsEditCancelled(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEditCancelled();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_IsEditCancelled, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetKeyCode, "SetKeyCode(code)");

extern "C" {static PyObject *meth_wxListEvent_SetKeyCode(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetKeyCode(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int code;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_code,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxListEvent, &sipCpp, &code))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetKeyCode(code);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetKeyCode, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetIndex, "SetIndex(index)");

extern "C" {static PyObject *meth_wxListEvent_SetIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        long index;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_index,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &index))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetIndex(index);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetIndex, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetColumn, "SetColumn(col)");

extern "C" {static PyObject *meth_wxListEvent_SetColumn(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetColumn(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int col;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_col,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxListEvent, &sipCpp, &col))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetColumn(col);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetColumn, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetPoint, "SetPoint(point)");

extern "C" {static PyObject *meth_wxListEvent_SetPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxPoint* point;
        int pointState = 0;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_point,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxListEvent, &sipCpp, sipType_wxPoint, &point, &pointState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPoint(*point);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(point),sipType_wxPoint,pointState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetPoint, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetItem, "SetItem(item)");

extern "C" {static PyObject *meth_wxListEvent_SetItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxListItem* item;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_item,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxListEvent, &sipCpp, sipType_wxListItem, &item))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetItem(*item);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetCacheFrom, "SetCacheFrom(cacheFrom)");

extern "C" {static PyObject *meth_wxListEvent_SetCacheFrom(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetCacheFrom(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        long cacheFrom;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cacheFrom,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &cacheFrom))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCacheFrom(cacheFrom);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetCacheFrom, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_SetCacheTo, "SetCacheTo(cacheTo)");

extern "C" {static PyObject *meth_wxListEvent_SetCacheTo(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_SetCacheTo(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        long cacheTo;
         ::wxListEvent *sipCpp;

        static const char *sipKwdList[] = {
            sipName_cacheTo,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bl", &sipSelf, sipType_wxListEvent, &sipCpp, &cacheTo))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetCacheTo(cacheTo);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_SetCacheTo, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxListEvent_Clone, "Clone(self) -> Event");

extern "C" {static PyObject *meth_wxListEvent_Clone(PyObject *, PyObject *);}
static PyObject *meth_wxListEvent_Clone(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxListEvent *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxListEvent, &sipCpp))
        {
             ::wxEvent*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxListEvent::Clone() : sipCpp->Clone());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxEvent,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ListEvent, sipName_Clone, doc_wxListEvent_Clone);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxListEvent(void *, const sipTypeDef *);}
static void *cast_wxListEvent(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxListEvent *sipCpp = reinterpret_cast< ::wxListEvent *>(sipCppV);

    if (targetType == sipType_wxNotifyEvent)
        return static_cast< ::wxNotifyEvent *>(sipCpp);

    if (targetType == sipType_wxCommandEvent)
        return static_cast< ::wxCommandEvent *>(sipCpp);

    if (targetType == sipType_wxEvent)
        return static_cast< ::wxEvent *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxListEvent(void *, int);}
static void release_wxListEvent(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxListEvent *>(sipCppV);
    else
        delete reinterpret_cast< ::wxListEvent *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxListEvent(sipSimpleWrapper *);}
static void dealloc_wxListEvent(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxListEvent *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxListEvent(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxListEvent(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxListEvent(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxListEvent *sipCpp = 0;

    {
         ::wxEventType commandType = wxEVT_NULL;
        int id = 0;

        static const char *sipKwdList[] = {
            sipName_commandType,
            sipName_id,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|ii", &commandType, &id))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxListEvent(commandType,id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::wxListEvent* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_wxListEvent, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxListEvent(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxListEvent[] = {{356, 255, 1}};


static PyMethodDef methods_wxListEvent[] = {
    {SIP_MLNAME_CAST(sipName_Clone), meth_wxListEvent_Clone, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_Clone)},
    {SIP_MLNAME_CAST(sipName_GetCacheFrom), meth_wxListEvent_GetCacheFrom, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetCacheFrom)},
    {SIP_MLNAME_CAST(sipName_GetCacheTo), meth_wxListEvent_GetCacheTo, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetCacheTo)},
    {SIP_MLNAME_CAST(sipName_GetColumn), meth_wxListEvent_GetColumn, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetColumn)},
    {SIP_MLNAME_CAST(sipName_GetData), meth_wxListEvent_GetData, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetData)},
    {SIP_MLNAME_CAST(sipName_GetImage), meth_wxListEvent_GetImage, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetImage)},
    {SIP_MLNAME_CAST(sipName_GetIndex), meth_wxListEvent_GetIndex, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetIndex)},
    {SIP_MLNAME_CAST(sipName_GetItem), meth_wxListEvent_GetItem, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetItem)},
    {SIP_MLNAME_CAST(sipName_GetKeyCode), meth_wxListEvent_GetKeyCode, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetKeyCode)},
    {SIP_MLNAME_CAST(sipName_GetLabel), meth_wxListEvent_GetLabel, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetLabel)},
    {SIP_MLNAME_CAST(sipName_GetMask), meth_wxListEvent_GetMask, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetMask)},
    {SIP_MLNAME_CAST(sipName_GetPoint), meth_wxListEvent_GetPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetPoint)},
    {SIP_MLNAME_CAST(sipName_GetText), meth_wxListEvent_GetText, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_GetText)},
    {SIP_MLNAME_CAST(sipName_IsEditCancelled), meth_wxListEvent_IsEditCancelled, METH_VARARGS, SIP_MLDOC_CAST(doc_wxListEvent_IsEditCancelled)},
    {SIP_MLNAME_CAST(sipName_SetCacheFrom), (PyCFunction)meth_wxListEvent_SetCacheFrom, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetCacheFrom)},
    {SIP_MLNAME_CAST(sipName_SetCacheTo), (PyCFunction)meth_wxListEvent_SetCacheTo, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetCacheTo)},
    {SIP_MLNAME_CAST(sipName_SetColumn), (PyCFunction)meth_wxListEvent_SetColumn, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetColumn)},
    {SIP_MLNAME_CAST(sipName_SetIndex), (PyCFunction)meth_wxListEvent_SetIndex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetIndex)},
    {SIP_MLNAME_CAST(sipName_SetItem), (PyCFunction)meth_wxListEvent_SetItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetItem)},
    {SIP_MLNAME_CAST(sipName_SetKeyCode), (PyCFunction)meth_wxListEvent_SetKeyCode, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetKeyCode)},
    {SIP_MLNAME_CAST(sipName_SetPoint), (PyCFunction)meth_wxListEvent_SetPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxListEvent_SetPoint)}
};

sipVariableDef variables_wxListEvent[] = {
    {PropertyVariable, sipName_Text, &methods_wxListEvent[12], NULL, NULL, NULL},
    {PropertyVariable, sipName_Point, &methods_wxListEvent[11], &methods_wxListEvent[20], NULL, NULL},
    {PropertyVariable, sipName_Mask, &methods_wxListEvent[10], NULL, NULL, NULL},
    {PropertyVariable, sipName_Label, &methods_wxListEvent[9], NULL, NULL, NULL},
    {PropertyVariable, sipName_KeyCode, &methods_wxListEvent[8], &methods_wxListEvent[19], NULL, NULL},
    {PropertyVariable, sipName_Item, &methods_wxListEvent[7], &methods_wxListEvent[18], NULL, NULL},
    {PropertyVariable, sipName_Index, &methods_wxListEvent[6], &methods_wxListEvent[17], NULL, NULL},
    {PropertyVariable, sipName_Image, &methods_wxListEvent[5], NULL, NULL, NULL},
    {PropertyVariable, sipName_Data, &methods_wxListEvent[4], NULL, NULL, NULL},
    {PropertyVariable, sipName_Column, &methods_wxListEvent[3], &methods_wxListEvent[16], NULL, NULL},
    {PropertyVariable, sipName_CacheTo, &methods_wxListEvent[2], &methods_wxListEvent[15], NULL, NULL},
    {PropertyVariable, sipName_CacheFrom, &methods_wxListEvent[1], &methods_wxListEvent[14], NULL, NULL},
};

PyDoc_STRVAR(doc_wxListEvent, "ListEvent(commandType=wxEVT_NULL, id=0)\n"
"\n"
"A list event holds information about events associated with wxListCtrl\n"
"objects.");


sipClassTypeDef sipTypeDef__core_wxListEvent = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxListEvent,
        {0},
        0
    },
    {
        sipNameNr_ListEvent,
        {0, 0, 1},
        21, methods_wxListEvent,
        0, 0,
        12, variables_wxListEvent,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxListEvent,
    -1,
    -1,
    supers_wxListEvent,
    0,
    init_type_wxListEvent,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxListEvent,
    0,
    0,
    0,
    release_wxListEvent,
    cast_wxListEvent,
    0,
    0,
    0,
    0,
    0,
    0
};
