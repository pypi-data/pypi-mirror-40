/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/dcsvg.h>

        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/gdicmn.h>
        #include <wx/region.h>
        #include <wx/palette.h>
        #include <wx/colour.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/bitmap.h>
        #include <wx/dc.h>
        #include <wx/affinematrix2d.h>
        #include <wx/pen.h>
        #include "arrayholder.h"
        #include <wx/brush.h>
        #include <wx/font.h>
        #include <wx/dc.h>
        
        #include <wx/icon.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>


class sipwxSVGFileDC : public  ::wxSVGFileDC
{
public:
    sipwxSVGFileDC(const  ::wxString&,int,int,double);
    ~sipwxSVGFileDC();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxSVGFileDC(const sipwxSVGFileDC &);
    sipwxSVGFileDC &operator = (const sipwxSVGFileDC &);
};

sipwxSVGFileDC::sipwxSVGFileDC(const  ::wxString& filename,int width,int height,double dpi):  ::wxSVGFileDC(filename,width,height,dpi), sipPySelf(0)
{
}

sipwxSVGFileDC::~sipwxSVGFileDC()
{
    sipInstanceDestroyedEx(&sipPySelf);
}


PyDoc_STRVAR(doc_wxSVGFileDC_CrossHair, "CrossHair(x, y)\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_CrossHair(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_CrossHair(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->CrossHair(x,y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_CrossHair, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_FloodFill, "FloodFill(x, y, colour, style=FLOOD_SURFACE) -> bool\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_FloodFill(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_FloodFill(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
        const  ::wxColour* colour;
        int colourState = 0;
         ::wxFloodFillStyle style = wxFLOOD_SURFACE;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_colour,
            sipName_style,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiiJ1|E", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, sipType_wxColour, &colour, &colourState, sipType_wxFloodFillStyle, &style))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FloodFill(x,y,*colour,style);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxColour *>(colour),sipType_wxColour,colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_FloodFill, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_GetClippingBox, "GetClippingBox(x, y, width, height)\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_GetClippingBox(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_GetClippingBox(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxCoord width;
         ::wxCoord height;
        const  ::wxSVGFileDC *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->GetClippingBox(&x,&y,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(iiii)",x,y,width,height);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_GetClippingBox, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_GetPixel, "GetPixel(x, y, colour) -> bool\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_GetPixel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_GetPixel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxColour* colour;
        int colourState = 0;
        const  ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_colour,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiiJ0", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, sipType_wxColour, &colour, &colourState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetPixel(x,y,colour);
            Py_END_ALLOW_THREADS
            sipReleaseType(colour,sipType_wxColour,colourState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_GetPixel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetPalette, "SetPalette(palette)\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetPalette(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetPalette(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxPalette* palette;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_palette,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxPalette, &palette))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetPalette(*palette);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetPalette, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_StartDoc, "StartDoc(message) -> bool\n"
"\n"
"Functions not implemented in this DC class.");

extern "C" {static PyObject *meth_wxSVGFileDC_StartDoc(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_StartDoc(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxString* message;
        int messageState = 0;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_message,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxString,&message, &messageState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->StartDoc(*message);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(message),sipType_wxString,messageState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_StartDoc, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_EndDoc, "EndDoc()\n"
"\n"
"Does nothing.");

extern "C" {static PyObject *meth_wxSVGFileDC_EndDoc(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_EndDoc(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndDoc();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_EndDoc, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_EndPage, "EndPage()\n"
"\n"
"Does nothing.");

extern "C" {static PyObject *meth_wxSVGFileDC_EndPage(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_EndPage(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EndPage();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_EndPage, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_Clear, "Clear()\n"
"\n"
"This makes no sense in wxSVGFileDC and does nothing.");

extern "C" {static PyObject *meth_wxSVGFileDC_Clear(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_Clear(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Clear();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_Clear, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetLogicalFunction, "SetLogicalFunction(function)\n"
"\n"
"Does the same as wxDC::SetLogicalFunction(), except that only wxCOPY\n"
"is available.");

extern "C" {static PyObject *meth_wxSVGFileDC_SetLogicalFunction(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetLogicalFunction(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxRasterOperationMode function;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_function,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BE", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxRasterOperationMode, &function))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLogicalFunction(function);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetLogicalFunction, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_SetClippingRegion, "SetClippingRegion(x, y, width, height)\n"
"SetClippingRegion(pt, sz)\n"
"SetClippingRegion(rect)\n"
"SetClippingRegion(region)\n"
"\n"
"Sets the clipping region for this device context to the intersection\n"
"of the given region described by the parameters of this method and the\n"
"previously set clipping region.\n"
"\n"
"\n"
"");

extern "C" {static PyObject *meth_wxSVGFileDC_SetClippingRegion(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_SetClippingRegion(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxCoord x;
         ::wxCoord y;
         ::wxCoord width;
         ::wxCoord height;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biiii", &sipSelf, sipType_wxSVGFileDC, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClippingRegion(x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxPoint* pt;
        int ptState = 0;
        const  ::wxSize* sz;
        int szState = 0;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pt,
            sipName_sz,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxPoint, &pt, &ptState, sipType_wxSize, &sz, &szState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClippingRegion(*pt,*sz);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxPoint *>(pt),sipType_wxPoint,ptState);
            sipReleaseType(const_cast< ::wxSize *>(sz),sipType_wxSize,szState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxRect* rect;
        int rectState = 0;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClippingRegion(*rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect),sipType_wxRect,rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::wxRegion* region;
         ::wxSVGFileDC *sipCpp;

        static const char *sipKwdList[] = {
            sipName_region,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxSVGFileDC, &sipCpp, sipType_wxRegion, &region))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetClippingRegion(*region);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_SetClippingRegion, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxSVGFileDC_DestroyClippingRegion, "DestroyClippingRegion()\n"
"\n"
"Destroys the current clipping region so that none of the DC is\n"
"clipped.");

extern "C" {static PyObject *meth_wxSVGFileDC_DestroyClippingRegion(PyObject *, PyObject *);}
static PyObject *meth_wxSVGFileDC_DestroyClippingRegion(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxSVGFileDC *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxSVGFileDC, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->DestroyClippingRegion();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SVGFileDC, sipName_DestroyClippingRegion, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxSVGFileDC(void *, const sipTypeDef *);}
static void *cast_wxSVGFileDC(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxSVGFileDC *sipCpp = reinterpret_cast< ::wxSVGFileDC *>(sipCppV);

    if (targetType == sipType_wxDC)
        return static_cast< ::wxDC *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxSVGFileDC(void *, int);}
static void release_wxSVGFileDC(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxSVGFileDC *>(sipCppV);
    else
        delete reinterpret_cast< ::wxSVGFileDC *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxSVGFileDC(sipSimpleWrapper *);}
static void dealloc_wxSVGFileDC(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxSVGFileDC *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxSVGFileDC(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxSVGFileDC(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxSVGFileDC(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxSVGFileDC *sipCpp = 0;

    {
        const  ::wxString* filename;
        int filenameState = 0;
        int width = 320;
        int height = 240;
        double dpi = 72;

        static const char *sipKwdList[] = {
            sipName_filename,
            sipName_width,
            sipName_height,
            sipName_dpi,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|iid", sipType_wxString,&filename, &filenameState, &width, &height, &dpi))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxSVGFileDC(*filename,width,height,dpi);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(filename),sipType_wxString,filenameState);

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxSVGFileDC[] = {{94, 255, 1}};


static PyMethodDef methods_wxSVGFileDC[] = {
    {SIP_MLNAME_CAST(sipName_Clear), meth_wxSVGFileDC_Clear, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_Clear)},
    {SIP_MLNAME_CAST(sipName_CrossHair), (PyCFunction)meth_wxSVGFileDC_CrossHair, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_CrossHair)},
    {SIP_MLNAME_CAST(sipName_DestroyClippingRegion), meth_wxSVGFileDC_DestroyClippingRegion, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_DestroyClippingRegion)},
    {SIP_MLNAME_CAST(sipName_EndDoc), meth_wxSVGFileDC_EndDoc, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_EndDoc)},
    {SIP_MLNAME_CAST(sipName_EndPage), meth_wxSVGFileDC_EndPage, METH_VARARGS, SIP_MLDOC_CAST(doc_wxSVGFileDC_EndPage)},
    {SIP_MLNAME_CAST(sipName_FloodFill), (PyCFunction)meth_wxSVGFileDC_FloodFill, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_FloodFill)},
    {SIP_MLNAME_CAST(sipName_GetClippingBox), (PyCFunction)meth_wxSVGFileDC_GetClippingBox, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_GetClippingBox)},
    {SIP_MLNAME_CAST(sipName_GetPixel), (PyCFunction)meth_wxSVGFileDC_GetPixel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_GetPixel)},
    {SIP_MLNAME_CAST(sipName_SetClippingRegion), (PyCFunction)meth_wxSVGFileDC_SetClippingRegion, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetClippingRegion)},
    {SIP_MLNAME_CAST(sipName_SetLogicalFunction), (PyCFunction)meth_wxSVGFileDC_SetLogicalFunction, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetLogicalFunction)},
    {SIP_MLNAME_CAST(sipName_SetPalette), (PyCFunction)meth_wxSVGFileDC_SetPalette, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_SetPalette)},
    {SIP_MLNAME_CAST(sipName_StartDoc), (PyCFunction)meth_wxSVGFileDC_StartDoc, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxSVGFileDC_StartDoc)}
};

PyDoc_STRVAR(doc_wxSVGFileDC, "SVGFileDC(filename, width=320, height=240, dpi=72)\n"
"\n"
"A wxSVGFileDC is a device context onto which graphics and text can be\n"
"drawn, and the output produced as a vector file, in SVG format.");


sipClassTypeDef sipTypeDef__core_wxSVGFileDC = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxSVGFileDC,
        {0},
        0
    },
    {
        sipNameNr_SVGFileDC,
        {0, 0, 1},
        12, methods_wxSVGFileDC,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxSVGFileDC,
    -1,
    -1,
    supers_wxSVGFileDC,
    0,
    init_type_wxSVGFileDC,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxSVGFileDC,
    0,
    0,
    0,
    release_wxSVGFileDC,
    cast_wxSVGFileDC,
    0,
    0,
    0,
    0,
    0,
    0
};
