/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/menu.h>

        #include <wx/menuitem.h>
        #include <wx/frame.h>
        #include <wx/menu.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/gdicmn.h>
        #include <wx/event.h>
        #include <wx/gdicmn.h>
        #include <wx/window.h>
        #include <wx/gdicmn.h>
        #include <wx/window.h>
        #include <wx/event.h>
    #include <wx/setup.h>
    #include <wxPython/wxpy_api.h>
        #include <wx/event.h>
        #include <wx/cursor.h>
        #include <wx/caret.h>
        #include <wx/layout.h>
        #include <wx/sizer.h>
        #include <wx/dnd.h>
        #include <wx/access.h>
        #include <wx/accel.h>
        #include <wx/validate.h>
        #include <wx/tooltip.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/event.h>
        #include <wx/palette.h>
        #include <wx/colour.h>
        #include <wx/font.h>
        #include <wx/region.h>
        
        #include <wx/eventfilter.h>
        #include <wx/object.h>
        #include <wx/object.h>
        #include <wx/object.h>
    wxMenu * _wxMenuBar_OSXGetAppleMenu(const wxMenuBar* self)
    {
        #ifdef __WXMAC__
            return self->OSXGetAppleMenu();
        #else
            return NULL;
        #endif
    }
    void _wxMenuBar_MacSetCommonMenuBar(wxMenuBar *menubar)
    {
        #ifdef __WXMAC__
            wxMenuBar::MacSetCommonMenuBar(menubar);
        #endif
    }
    wxMenuBar * _wxMenuBar_MacGetCommonMenuBar()
    {
        #ifdef __WXMAC__
            return wxMenuBar::MacGetCommonMenuBar();
        #else
            return NULL;
        #endif
    }
    wxMenuItem* _wxMenuBar_FindItemById(const wxMenuBar* self, int id)
    {
        return self->FindItem(id);
    }


class sipwxMenuBar : public  ::wxMenuBar
{
public:
    sipwxMenuBar(long);
    virtual ~sipwxMenuBar();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtectVirt_DoEnable(bool,bool);
    void sipProtectVirt_DoGetPosition(bool,int*,int*) const;
    void sipProtectVirt_DoGetSize(bool,int*,int*) const;
    void sipProtectVirt_DoGetClientSize(bool,int*,int*) const;
    void sipProtectVirt_DoSetSize(bool,int,int,int,int,int);
    void sipProtectVirt_DoSetClientSize(bool,int,int);
    void sipProtectVirt_DoSetSizeHints(bool,int,int,int,int,int,int);
     ::wxSize sipProtectVirt_DoGetBorderSize(bool) const;
    void sipProtectVirt_DoMoveWindow(bool,int,int,int,int);
    void sipProtectVirt_DoSetWindowVariant(bool, ::wxWindowVariant);
     ::wxBorder sipProtectVirt_GetDefaultBorder(bool) const;
     ::wxBorder sipProtectVirt_GetDefaultBorderForControl(bool) const;
    void sipProtectVirt_DoFreeze(bool);
    void sipProtectVirt_DoThaw(bool);
    bool sipProtectVirt_TryBefore(bool, ::wxEvent&);
    bool sipProtectVirt_TryAfter(bool, ::wxEvent&);
     ::wxSize sipProtectVirt_DoGetBestSize(bool) const;
     ::wxSize sipProtectVirt_DoGetBestClientSize(bool) const;
    void sipProtect_SendDestroyEvent();
    bool sipProtectVirt_ProcessEvent(bool, ::wxEvent&);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void RemoveChild( ::wxWindowBase*);
    void AddChild( ::wxWindowBase*);
    bool ProcessEvent( ::wxEvent&);
    bool TryBefore( ::wxEvent&);
    bool TryAfter( ::wxEvent&);
    bool AcceptsFocus() const;
    bool AcceptsFocusFromKeyboard() const;
    bool AcceptsFocusRecursively() const;
    void SetCanFocus(bool);
    bool InformFirstDirection(int,int,int);
     ::wxPoint GetClientAreaOrigin() const;
    bool HasTransparentBackground();
    bool ShouldInheritColours() const;
     ::wxValidator* GetValidator();
    void SetValidator(const  ::wxValidator&);
    bool TransferDataFromWindow();
    bool TransferDataToWindow();
    bool Validate();
    bool Destroy();
    void InheritAttributes();
    void InitDialog();
    void OnInternalIdle();
     ::wxWindow* GetMainWindowOfCompositeControl();
    void DoEnable(bool);
    void DoGetPosition(int*,int*) const;
    void DoGetSize(int*,int*) const;
    void DoGetClientSize(int*,int*) const;
    void DoSetSize(int,int,int,int,int);
    void DoSetClientSize(int,int);
    void DoSetSizeHints(int,int,int,int,int,int);
     ::wxSize DoGetBorderSize() const;
    void DoMoveWindow(int,int,int,int);
    void DoSetWindowVariant( ::wxWindowVariant);
     ::wxBorder GetDefaultBorder() const;
     ::wxBorder GetDefaultBorderForControl() const;
    void DoFreeze();
    void DoThaw();
     ::wxSize DoGetBestSize() const;
     ::wxSize DoGetBestClientSize() const;

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxMenuBar(const sipwxMenuBar &);
    sipwxMenuBar &operator = (const sipwxMenuBar &);

    char sipPyMethods[39];
};

sipwxMenuBar::sipwxMenuBar(long style):  ::wxMenuBar(style), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxMenuBar::~sipwxMenuBar()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

void sipwxMenuBar::RemoveChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_RemoveChild);

    if (!sipMeth)
    {
         ::wxMenuBar::RemoveChild(child);
        return;
    }

    extern void sipVH__core_114(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__core_114(sipGILState, 0, sipPySelf, sipMeth, child);
}

void sipwxMenuBar::AddChild( ::wxWindowBase*child)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_AddChild);

    if (!sipMeth)
    {
         ::wxMenuBar::AddChild(child);
        return;
    }

    extern void sipVH__core_114(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowBase*);

    sipVH__core_114(sipGILState, 0, sipPySelf, sipMeth, child);
}

bool sipwxMenuBar::ProcessEvent( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_ProcessEvent);

    if (!sipMeth)
        return  ::wxMenuBar::ProcessEvent(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenuBar::TryBefore( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_TryBefore);

    if (!sipMeth)
        return  ::wxMenuBar::TryBefore(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenuBar::TryAfter( ::wxEvent& event)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_TryAfter);

    if (!sipMeth)
        return  ::wxMenuBar::TryAfter(event);

    extern bool sipVH__core_94(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEvent&);

    return sipVH__core_94(sipGILState, 0, sipPySelf, sipMeth, event);
}

bool sipwxMenuBar::AcceptsFocus() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,NULL,sipName_AcceptsFocus);

    if (!sipMeth)
        return  ::wxMenuBar::AcceptsFocus();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::AcceptsFocusFromKeyboard() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[6]),sipPySelf,NULL,sipName_AcceptsFocusFromKeyboard);

    if (!sipMeth)
        return  ::wxMenuBar::AcceptsFocusFromKeyboard();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::AcceptsFocusRecursively() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[7]),sipPySelf,NULL,sipName_AcceptsFocusRecursively);

    if (!sipMeth)
        return  ::wxMenuBar::AcceptsFocusRecursively();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::SetCanFocus(bool canFocus)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,NULL,sipName_SetCanFocus);

    if (!sipMeth)
    {
         ::wxMenuBar::SetCanFocus(canFocus);
        return;
    }

    extern void sipVH__core_87(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__core_87(sipGILState, 0, sipPySelf, sipMeth, canFocus);
}

bool sipwxMenuBar::InformFirstDirection(int direction,int size,int availableOtherDir)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,NULL,sipName_InformFirstDirection);

    if (!sipMeth)
        return  ::wxMenuBar::InformFirstDirection(direction,size,availableOtherDir);

    extern bool sipVH__core_115(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int);

    return sipVH__core_115(sipGILState, 0, sipPySelf, sipMeth, direction, size, availableOtherDir);
}

 ::wxPoint sipwxMenuBar::GetClientAreaOrigin() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[10]),sipPySelf,NULL,sipName_GetClientAreaOrigin);

    if (!sipMeth)
        return  ::wxMenuBar::GetClientAreaOrigin();

    extern  ::wxPoint sipVH__core_116(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_116(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::HasTransparentBackground()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[11],sipPySelf,NULL,sipName_HasTransparentBackground);

    if (!sipMeth)
        return  ::wxMenuBar::HasTransparentBackground();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::ShouldInheritColours() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[12]),sipPySelf,NULL,sipName_ShouldInheritColours);

    if (!sipMeth)
        return  ::wxMenuBar::ShouldInheritColours();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxValidator* sipwxMenuBar::GetValidator()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_GetValidator);

    if (!sipMeth)
        return  ::wxMenuBar::GetValidator();

    extern  ::wxValidator* sipVH__core_117(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_117(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::SetValidator(const  ::wxValidator& validator)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[14],sipPySelf,NULL,sipName_SetValidator);

    if (!sipMeth)
    {
         ::wxMenuBar::SetValidator(validator);
        return;
    }

    extern void sipVH__core_118(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::wxValidator&);

    sipVH__core_118(sipGILState, 0, sipPySelf, sipMeth, validator);
}

bool sipwxMenuBar::TransferDataFromWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[15],sipPySelf,NULL,sipName_TransferDataFromWindow);

    if (!sipMeth)
        return  ::wxMenuBar::TransferDataFromWindow();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::TransferDataToWindow()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[16],sipPySelf,NULL,sipName_TransferDataToWindow);

    if (!sipMeth)
        return  ::wxMenuBar::TransferDataToWindow();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::Validate()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[17],sipPySelf,NULL,sipName_Validate);

    if (!sipMeth)
        return  ::wxMenuBar::Validate();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxMenuBar::Destroy()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[18],sipPySelf,NULL,sipName_Destroy);

    if (!sipMeth)
        return  ::wxMenuBar::Destroy();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::InheritAttributes()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[19],sipPySelf,NULL,sipName_InheritAttributes);

    if (!sipMeth)
    {
         ::wxMenuBar::InheritAttributes();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::InitDialog()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[20],sipPySelf,NULL,sipName_InitDialog);

    if (!sipMeth)
    {
         ::wxMenuBar::InitDialog();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::OnInternalIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[21],sipPySelf,NULL,sipName_OnInternalIdle);

    if (!sipMeth)
    {
         ::wxMenuBar::OnInternalIdle();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxWindow* sipwxMenuBar::GetMainWindowOfCompositeControl()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[22],sipPySelf,NULL,sipName_GetMainWindowOfCompositeControl);

    if (!sipMeth)
        return  ::wxMenuBar::GetMainWindowOfCompositeControl();

    extern  ::wxWindow* sipVH__core_119(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_119(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::DoEnable(bool enable)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[23],sipPySelf,NULL,sipName_DoEnable);

    if (!sipMeth)
    {
         ::wxMenuBar::DoEnable(enable);
        return;
    }

    extern void sipVH__core_87(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, bool);

    sipVH__core_87(sipGILState, 0, sipPySelf, sipMeth, enable);
}

void sipwxMenuBar::DoGetPosition(int*x,int*y) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[24]),sipPySelf,NULL,sipName_DoGetPosition);

    if (!sipMeth)
    {
         ::wxMenuBar::DoGetPosition(x,y);
        return;
    }

    extern void sipVH__core_120(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_120(sipGILState, 0, sipPySelf, sipMeth, x, y);
}

void sipwxMenuBar::DoGetSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[25]),sipPySelf,NULL,sipName_DoGetSize);

    if (!sipMeth)
    {
         ::wxMenuBar::DoGetSize(width,height);
        return;
    }

    extern void sipVH__core_120(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_120(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxMenuBar::DoGetClientSize(int*width,int*height) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[26]),sipPySelf,NULL,sipName_DoGetClientSize);

    if (!sipMeth)
    {
         ::wxMenuBar::DoGetClientSize(width,height);
        return;
    }

    extern void sipVH__core_120(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int*,int*);

    sipVH__core_120(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxMenuBar::DoSetSize(int x,int y,int width,int height,int sizeFlags)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[27],sipPySelf,NULL,sipName_DoSetSize);

    if (!sipMeth)
    {
         ::wxMenuBar::DoSetSize(x,y,width,height,sizeFlags);
        return;
    }

    extern void sipVH__core_121(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int);

    sipVH__core_121(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height, sizeFlags);
}

void sipwxMenuBar::DoSetClientSize(int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[28],sipPySelf,NULL,sipName_DoSetClientSize);

    if (!sipMeth)
    {
         ::wxMenuBar::DoSetClientSize(width,height);
        return;
    }

    extern void sipVH__core_122(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int);

    sipVH__core_122(sipGILState, 0, sipPySelf, sipMeth, width, height);
}

void sipwxMenuBar::DoSetSizeHints(int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[29],sipPySelf,NULL,sipName_DoSetSizeHints);

    if (!sipMeth)
    {
         ::wxMenuBar::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH);
        return;
    }

    extern void sipVH__core_123(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int,int,int);

    sipVH__core_123(sipGILState, 0, sipPySelf, sipMeth, minW, minH, maxW, maxH, incW, incH);
}

 ::wxSize sipwxMenuBar::DoGetBorderSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[30]),sipPySelf,NULL,sipName_DoGetBorderSize);

    if (!sipMeth)
        return  ::wxMenuBar::DoGetBorderSize();

    extern  ::wxSize sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::DoMoveWindow(int x,int y,int width,int height)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[31],sipPySelf,NULL,sipName_DoMoveWindow);

    if (!sipMeth)
    {
         ::wxMenuBar::DoMoveWindow(x,y,width,height);
        return;
    }

    extern void sipVH__core_124(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int,int,int,int);

    sipVH__core_124(sipGILState, 0, sipPySelf, sipMeth, x, y, width, height);
}

void sipwxMenuBar::DoSetWindowVariant( ::wxWindowVariant variant)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[32],sipPySelf,NULL,sipName_DoSetWindowVariant);

    if (!sipMeth)
    {
         ::wxMenuBar::DoSetWindowVariant(variant);
        return;
    }

    extern void sipVH__core_125(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxWindowVariant);

    sipVH__core_125(sipGILState, 0, sipPySelf, sipMeth, variant);
}

 ::wxBorder sipwxMenuBar::GetDefaultBorder() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[33]),sipPySelf,NULL,sipName_GetDefaultBorder);

    if (!sipMeth)
        return  ::wxMenuBar::GetDefaultBorder();

    extern  ::wxBorder sipVH__core_126(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_126(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxBorder sipwxMenuBar::GetDefaultBorderForControl() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[34]),sipPySelf,NULL,sipName_GetDefaultBorderForControl);

    if (!sipMeth)
        return  ::wxMenuBar::GetDefaultBorderForControl();

    extern  ::wxBorder sipVH__core_126(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_126(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::DoFreeze()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[35],sipPySelf,NULL,sipName_DoFreeze);

    if (!sipMeth)
    {
         ::wxMenuBar::DoFreeze();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::DoThaw()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[36],sipPySelf,NULL,sipName_DoThaw);

    if (!sipMeth)
    {
         ::wxMenuBar::DoThaw();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxMenuBar::DoGetBestSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[37]),sipPySelf,NULL,sipName_DoGetBestSize);

    if (!sipMeth)
        return  ::wxMenuBar::DoGetBestSize();

    extern  ::wxSize sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth);
}

 ::wxSize sipwxMenuBar::DoGetBestClientSize() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[38]),sipPySelf,NULL,sipName_DoGetBestClientSize);

    if (!sipMeth)
        return  ::wxMenuBar::DoGetBestClientSize();

    extern  ::wxSize sipVH__core_97(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_97(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxMenuBar::sipProtectVirt_DoEnable(bool sipSelfWasArg,bool enable)
{
    (sipSelfWasArg ?  ::wxWindow::DoEnable(enable) : DoEnable(enable));
}

void sipwxMenuBar::sipProtectVirt_DoGetPosition(bool sipSelfWasArg,int*x,int*y) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetPosition(x,y) : DoGetPosition(x,y));
}

void sipwxMenuBar::sipProtectVirt_DoGetSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetSize(width,height) : DoGetSize(width,height));
}

void sipwxMenuBar::sipProtectVirt_DoGetClientSize(bool sipSelfWasArg,int*width,int*height) const
{
    (sipSelfWasArg ?  ::wxWindow::DoGetClientSize(width,height) : DoGetClientSize(width,height));
}

void sipwxMenuBar::sipProtectVirt_DoSetSize(bool sipSelfWasArg,int x,int y,int width,int height,int sizeFlags)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetSize(x,y,width,height,sizeFlags) : DoSetSize(x,y,width,height,sizeFlags));
}

void sipwxMenuBar::sipProtectVirt_DoSetClientSize(bool sipSelfWasArg,int width,int height)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetClientSize(width,height) : DoSetClientSize(width,height));
}

void sipwxMenuBar::sipProtectVirt_DoSetSizeHints(bool sipSelfWasArg,int minW,int minH,int maxW,int maxH,int incW,int incH)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetSizeHints(minW,minH,maxW,maxH,incW,incH) : DoSetSizeHints(minW,minH,maxW,maxH,incW,incH));
}

 ::wxSize sipwxMenuBar::sipProtectVirt_DoGetBorderSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::DoGetBorderSize() : DoGetBorderSize());
}

void sipwxMenuBar::sipProtectVirt_DoMoveWindow(bool sipSelfWasArg,int x,int y,int width,int height)
{
    (sipSelfWasArg ?  ::wxWindow::DoMoveWindow(x,y,width,height) : DoMoveWindow(x,y,width,height));
}

void sipwxMenuBar::sipProtectVirt_DoSetWindowVariant(bool sipSelfWasArg, ::wxWindowVariant variant)
{
    (sipSelfWasArg ?  ::wxWindow::DoSetWindowVariant(variant) : DoSetWindowVariant(variant));
}

 ::wxBorder sipwxMenuBar::sipProtectVirt_GetDefaultBorder(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::GetDefaultBorder() : GetDefaultBorder());
}

 ::wxBorder sipwxMenuBar::sipProtectVirt_GetDefaultBorderForControl(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::GetDefaultBorderForControl() : GetDefaultBorderForControl());
}

void sipwxMenuBar::sipProtectVirt_DoFreeze(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxWindow::DoFreeze() : DoFreeze());
}

void sipwxMenuBar::sipProtectVirt_DoThaw(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxWindow::DoThaw() : DoThaw());
}

bool sipwxMenuBar::sipProtectVirt_TryBefore(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::TryBefore(event) : TryBefore(event));
}

bool sipwxMenuBar::sipProtectVirt_TryAfter(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::TryAfter(event) : TryAfter(event));
}

 ::wxSize sipwxMenuBar::sipProtectVirt_DoGetBestSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::DoGetBestSize() : DoGetBestSize());
}

 ::wxSize sipwxMenuBar::sipProtectVirt_DoGetBestClientSize(bool sipSelfWasArg) const
{
    return (sipSelfWasArg ?  ::wxWindow::DoGetBestClientSize() : DoGetBestClientSize());
}

void sipwxMenuBar::sipProtect_SendDestroyEvent()
{
     ::wxWindow::SendDestroyEvent();
}

bool sipwxMenuBar::sipProtectVirt_ProcessEvent(bool sipSelfWasArg, ::wxEvent& event)
{
    return (sipSelfWasArg ?  ::wxWindow::ProcessEvent(event) : ProcessEvent(event));
}


PyDoc_STRVAR(doc_wxMenuBar_DoEnable, "DoEnable(self, enable: bool)");

extern "C" {static PyObject *meth_wxMenuBar_DoEnable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoEnable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        bool enable;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bb", &sipSelf, sipType_wxMenuBar, &sipCpp, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoEnable(sipSelfWasArg,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoEnable, doc_wxMenuBar_DoEnable);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetPosition, "DoGetPosition(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxMenuBar_DoGetPosition(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetPosition(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetPosition(sipSelfWasArg,&x,&y);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",x,y);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetPosition, doc_wxMenuBar_DoGetPosition);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetSize, "DoGetSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxMenuBar_DoGetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetSize, doc_wxMenuBar_DoGetSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetClientSize, "DoGetClientSize(self) -> Tuple[int, int]");

extern "C" {static PyObject *meth_wxMenuBar_DoGetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoGetClientSize(sipSelfWasArg,&width,&height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipBuildResult(0,"(ii)",width,height);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetClientSize, doc_wxMenuBar_DoGetClientSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoSetSize, "DoSetSize(self, x: int, y: int, width: int, height: int, sizeFlags: int)");

extern "C" {static PyObject *meth_wxMenuBar_DoSetSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoSetSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        int sizeFlags;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
            sipName_sizeFlags,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biiiii", &sipSelf, sipType_wxMenuBar, &sipCpp, &x, &y, &width, &height, &sizeFlags))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSize(sipSelfWasArg,x,y,width,height,sizeFlags);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoSetSize, doc_wxMenuBar_DoSetSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoSetClientSize, "DoSetClientSize(self, width: int, height: int)");

extern "C" {static PyObject *meth_wxMenuBar_DoSetClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoSetClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int width;
        int height;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bii", &sipSelf, sipType_wxMenuBar, &sipCpp, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetClientSize(sipSelfWasArg,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoSetClientSize, doc_wxMenuBar_DoSetClientSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoSetSizeHints, "DoSetSizeHints(self, minW: int, minH: int, maxW: int, maxH: int, incW: int, incH: int)");

extern "C" {static PyObject *meth_wxMenuBar_DoSetSizeHints(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoSetSizeHints(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int minW;
        int minH;
        int maxW;
        int maxH;
        int incW;
        int incH;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_minW,
            sipName_minH,
            sipName_maxW,
            sipName_maxH,
            sipName_incW,
            sipName_incH,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biiiiii", &sipSelf, sipType_wxMenuBar, &sipCpp, &minW, &minH, &maxW, &maxH, &incW, &incH))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetSizeHints(sipSelfWasArg,minW,minH,maxW,maxH,incW,incH);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoSetSizeHints, doc_wxMenuBar_DoSetSizeHints);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetBorderSize, "DoGetBorderSize(self) -> Size");

extern "C" {static PyObject *meth_wxMenuBar_DoGetBorderSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetBorderSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBorderSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetBorderSize, doc_wxMenuBar_DoGetBorderSize);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoMoveWindow, "DoMoveWindow(self, x: int, y: int, width: int, height: int)");

extern "C" {static PyObject *meth_wxMenuBar_DoMoveWindow(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoMoveWindow(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int x;
        int y;
        int width;
        int height;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_x,
            sipName_y,
            sipName_width,
            sipName_height,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Biiii", &sipSelf, sipType_wxMenuBar, &sipCpp, &x, &y, &width, &height))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoMoveWindow(sipSelfWasArg,x,y,width,height);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoMoveWindow, doc_wxMenuBar_DoMoveWindow);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoSetWindowVariant, "DoSetWindowVariant(self, variant: WindowVariant)");

extern "C" {static PyObject *meth_wxMenuBar_DoSetWindowVariant(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoSetWindowVariant(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxWindowVariant variant;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_variant,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BE", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxWindowVariant, &variant))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoSetWindowVariant(sipSelfWasArg,variant);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoSetWindowVariant, doc_wxMenuBar_DoSetWindowVariant);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetDefaultBorder, "GetDefaultBorder(self) -> Border");

extern "C" {static PyObject *meth_wxMenuBar_GetDefaultBorder(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetDefaultBorder(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorder(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetDefaultBorder, doc_wxMenuBar_GetDefaultBorder);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetDefaultBorderForControl, "GetDefaultBorderForControl(self) -> Border");

extern "C" {static PyObject *meth_wxMenuBar_GetDefaultBorderForControl(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetDefaultBorderForControl(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxBorder sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_GetDefaultBorderForControl(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_wxBorder);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetDefaultBorderForControl, doc_wxMenuBar_GetDefaultBorderForControl);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoFreeze, "DoFreeze(self)");

extern "C" {static PyObject *meth_wxMenuBar_DoFreeze(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoFreeze(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoFreeze(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoFreeze, doc_wxMenuBar_DoFreeze);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoThaw, "DoThaw(self)");

extern "C" {static PyObject *meth_wxMenuBar_DoThaw(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoThaw(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_DoThaw(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoThaw, doc_wxMenuBar_DoThaw);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_TryBefore, "TryBefore(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxMenuBar_TryBefore(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_TryBefore(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryBefore(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_TryBefore, doc_wxMenuBar_TryBefore);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_TryAfter, "TryAfter(self, event: Event) -> bool");

extern "C" {static PyObject *meth_wxMenuBar_TryAfter(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_TryAfter(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_TryAfter(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_TryAfter, doc_wxMenuBar_TryAfter);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetBestSize, "DoGetBestSize() -> Size\n"
"\n"
"Implementation of GetBestSize() that can be overridden.");

extern "C" {static PyObject *meth_wxMenuBar_DoGetBestSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetBestSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetBestSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_DoGetBestClientSize, "DoGetBestClientSize() -> Size\n"
"\n"
"Override this method to return the best size for a custom control.");

extern "C" {static PyObject *meth_wxMenuBar_DoGetBestClientSize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_DoGetBestClientSize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxSize*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxSize(sipCpp->sipProtectVirt_DoGetBestClientSize(sipSelfWasArg));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxSize,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_DoGetBestClientSize, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_SendDestroyEvent, "SendDestroyEvent()\n"
"\n"
"Generate wxWindowDestroyEvent for this window.");

extern "C" {static PyObject *meth_wxMenuBar_SendDestroyEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_SendDestroyEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        sipwxMenuBar *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtect_SendDestroyEvent();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_SendDestroyEvent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_ProcessEvent, "ProcessEvent(event) -> bool\n"
"\n"
"This function is public in wxEvtHandler but protected in wxWindow\n"
"because for wxWindows you should always call ProcessEvent() on the\n"
"pointer returned by GetEventHandler() and not on the wxWindow object\n"
"itself.");

extern "C" {static PyObject *meth_wxMenuBar_ProcessEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_ProcessEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxEvent* event;
        sipwxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_event,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxEvent, &event))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->sipProtectVirt_ProcessEvent(sipSelfWasArg,*event);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_ProcessEvent, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Append, "Append(menu, title) -> bool\n"
"\n"
"Adds the item to the end of the menu bar.");

extern "C" {static PyObject *meth_wxMenuBar_Append(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Append(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenu* menu;
        const  ::wxString* title;
        int titleState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menu,
            sipName_title,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ:J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxMenu, &menu, sipType_wxString,&title, &titleState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Append(menu,*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Append, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Check, "Check(id, check)\n"
"\n"
"Checks or unchecks a menu item.");

extern "C" {static PyObject *meth_wxMenuBar_Check(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Check(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        bool check;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_check,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bib", &sipSelf, sipType_wxMenuBar, &sipCpp, &id, &check))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Check(id,check);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Check, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Enable, "Enable(id, enable)\n"
"\n"
"Enables or disables (greys out) a menu item.");

extern "C" {static PyObject *meth_wxMenuBar_Enable(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Enable(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        bool enable;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bib", &sipSelf, sipType_wxMenuBar, &sipCpp, &id, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Enable(id,enable);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Enable, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_IsEnabledTop, "IsEnabledTop(pos) -> bool\n"
"\n"
"Returns true if the menu with the given index is enabled.");

extern "C" {static PyObject *meth_wxMenuBar_IsEnabledTop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_IsEnabledTop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEnabledTop(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_IsEnabledTop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_EnableTop, "EnableTop(pos, enable)\n"
"\n"
"Enables or disables a whole menu.");

extern "C" {static PyObject *meth_wxMenuBar_EnableTop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_EnableTop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        bool enable;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_enable,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1b", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState, &enable))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->EnableTop(*pos,enable);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_EnableTop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_FindItem, "FindItem(id) -> (MenuItem, menu)\n"
"\n"
"Finds the menu item object associated with the given menu item\n"
"identifier.");

extern "C" {static PyObject *meth_wxMenuBar_FindItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_FindItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
         ::wxMenu* menu;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindItem(id,&menu);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            PyObject *sipResObj = sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
            return sipBuildResult(0,"(RD)",sipResObj,menu,sipType_wxMenu,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_FindItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_FindMenu, "FindMenu(title) -> int\n"
"\n"
"Returns the index of the menu with the given title or wxNOT_FOUND if\n"
"no such menu exists in this menubar.");

extern "C" {static PyObject *meth_wxMenuBar_FindMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_FindMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxString* title;
        int titleState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_title,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxString,&title, &titleState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindMenu(*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_FindMenu, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_FindMenuItem, "FindMenuItem(menuString, itemString) -> int\n"
"\n"
"Finds the menu item id for a menu name/menu item string pair.");

extern "C" {static PyObject *meth_wxMenuBar_FindMenuItem(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_FindMenuItem(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxString* menuString;
        int menuStringState = 0;
        const  ::wxString* itemString;
        int itemStringState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menuString,
            sipName_itemString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxString,&menuString, &menuStringState, sipType_wxString,&itemString, &itemStringState))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->FindMenuItem(*menuString,*itemString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(menuString),sipType_wxString,menuStringState);
            sipReleaseType(const_cast< ::wxString *>(itemString),sipType_wxString,itemStringState);

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_FindMenuItem, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetHelpString, "GetHelpString(id) -> String\n"
"\n"
"Gets the help string associated with the menu item identifier.");

extern "C" {static PyObject *meth_wxMenuBar_GetHelpString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetHelpString(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetHelpString(id));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetHelpString, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetLabel, "GetLabel(id) -> String\n"
"\n"
"Gets the label associated with a menu item.");

extern "C" {static PyObject *meth_wxMenuBar_GetLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabel(id));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetLabelTop, "GetLabelTop(pos) -> String\n"
"\n"
"Returns the label of a top-level menu.");

extern "C" {static PyObject *meth_wxMenuBar_GetLabelTop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetLabelTop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState))
        {
             ::wxString*sipRes;

            if (sipDeprecated(sipName_MenuBar,sipName_GetLabelTop) < 0)
                return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetLabelTop(*pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetLabelTop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetMenu, "GetMenu(menuIndex) -> Menu\n"
"\n"
"Returns the menu at menuIndex (zero-based).");

extern "C" {static PyObject *meth_wxMenuBar_GetMenu(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetMenu(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* menuIndex;
        int menuIndexState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_menuIndex,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&menuIndex, &menuIndexState))
        {
             ::wxMenu*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMenu(*menuIndex);
            Py_END_ALLOW_THREADS
            sipReleaseType(menuIndex,sipType_size_t,menuIndexState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetMenu, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetMenuCount, "GetMenuCount() -> size_t\n"
"\n"
"Returns the number of menus in this menubar.");

extern "C" {static PyObject *meth_wxMenuBar_GetMenuCount(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetMenuCount(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenuBar *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::size_t*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::size_t(sipCpp->GetMenuCount());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_size_t,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetMenuCount, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetMenuLabel, "GetMenuLabel(pos) -> String\n"
"\n"
"Returns the label of a top-level menu.");

extern "C" {static PyObject *meth_wxMenuBar_GetMenuLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetMenuLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetMenuLabel(*pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetMenuLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetMenuLabelText, "GetMenuLabelText(pos) -> String\n"
"\n"
"Returns the label of a top-level menu.");

extern "C" {static PyObject *meth_wxMenuBar_GetMenuLabelText(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetMenuLabelText(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState))
        {
             ::wxString*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::wxString(sipCpp->GetMenuLabelText(*pos));
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromNewType(sipRes,sipType_wxString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetMenuLabelText, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Insert, "Insert(pos, menu, title) -> bool\n"
"\n"
"Inserts the menu at the given position into the menu bar.");

extern "C" {static PyObject *meth_wxMenuBar_Insert(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Insert(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
         ::wxMenu* menu;
        const  ::wxString* title;
        int titleState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_menu,
            sipName_title,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState, sipType_wxMenu, &menu, sipType_wxString,&title, &titleState))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Insert(*pos,menu,*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Insert, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_IsChecked, "IsChecked(id) -> bool\n"
"\n"
"Determines whether an item is checked.");

extern "C" {static PyObject *meth_wxMenuBar_IsChecked(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_IsChecked(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsChecked(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_IsChecked, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_IsEnabled, "IsEnabled(id) -> bool\n"
"\n"
"Determines whether an item is enabled.");

extern "C" {static PyObject *meth_wxMenuBar_IsEnabled(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_IsEnabled(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsEnabled(id);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_IsEnabled, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Refresh, "Refresh(eraseBackground=True, rect=None)\n"
"\n"
"Redraw the menu bar.");

extern "C" {static PyObject *meth_wxMenuBar_Refresh(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Refresh(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        bool eraseBackground = 1;
        const  ::wxRect* rect = 0;
        int rectState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eraseBackground,
            sipName_rect,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|bJ0", &sipSelf, sipType_wxMenuBar, &sipCpp, &eraseBackground, sipType_wxRect, &rect, &rectState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Refresh(eraseBackground,rect);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxRect *>(rect),sipType_wxRect,rectState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Refresh, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Remove, "Remove(pos) -> Menu\n"
"\n"
"Removes the menu from the menu bar and returns the menu object - the\n"
"caller is responsible for deleting it.");

extern "C" {static PyObject *meth_wxMenuBar_Remove(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Remove(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState))
        {
             ::wxMenu*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Remove(*pos);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Remove, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Replace, "Replace(pos, menu, title) -> Menu\n"
"\n"
"Replaces the menu at the given position with another one.");

extern "C" {static PyObject *meth_wxMenuBar_Replace(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Replace(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
         ::wxMenu* menu;
        const  ::wxString* title;
        int titleState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_menu,
            sipName_title,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J:J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState, sipType_wxMenu, &menu, sipType_wxString,&title, &titleState))
        {
             ::wxMenu*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->Replace(*pos,menu,*title);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(title),sipType_wxString,titleState);

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,Py_None);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Replace, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_SetHelpString, "SetHelpString(id, helpString)\n"
"\n"
"Sets the help string associated with a menu item.");

extern "C" {static PyObject *meth_wxMenuBar_SetHelpString(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_SetHelpString(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* helpString;
        int helpStringState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_helpString,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, &id, sipType_wxString,&helpString, &helpStringState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetHelpString(id,*helpString);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(helpString),sipType_wxString,helpStringState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_SetHelpString, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_SetLabel, "SetLabel(id, label)\n"
"\n"
"Sets the label of a menu item.");

extern "C" {static PyObject *meth_wxMenuBar_SetLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_SetLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxString* label;
        int labelState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
            sipName_label,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BiJ1", &sipSelf, sipType_wxMenuBar, &sipCpp, &id, sipType_wxString,&label, &labelState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabel(id,*label);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::wxString *>(label),sipType_wxString,labelState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_SetLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_SetLabelTop, "SetLabelTop(pos, label)\n"
"\n"
"Sets the label of a top-level menu.");

extern "C" {static PyObject *meth_wxMenuBar_SetLabelTop(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_SetLabelTop(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxString* label;
        int labelState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_label,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState, sipType_wxString,&label, &labelState))
        {
            if (sipDeprecated(sipName_MenuBar,sipName_SetLabelTop) < 0)
                return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetLabelTop(*pos,*label);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(label),sipType_wxString,labelState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_SetLabelTop, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_SetMenuLabel, "SetMenuLabel(pos, label)\n"
"\n"
"Sets the label of a top-level menu.");

extern "C" {static PyObject *meth_wxMenuBar_SetMenuLabel(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_SetMenuLabel(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::size_t* pos;
        int posState = 0;
        const  ::wxString* label;
        int labelState = 0;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_pos,
            sipName_label,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_size_t,&pos, &posState, sipType_wxString,&label, &labelState))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->SetMenuLabel(*pos,*label);
            Py_END_ALLOW_THREADS
            sipReleaseType(pos,sipType_size_t,posState);
            sipReleaseType(const_cast< ::wxString *>(label),sipType_wxString,labelState);

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_SetMenuLabel, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_OSXGetAppleMenu, "OSXGetAppleMenu() -> Menu\n"
"\n"
"Returns the Apple menu.");

extern "C" {static PyObject *meth_wxMenuBar_OSXGetAppleMenu(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_OSXGetAppleMenu(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenuBar *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxMenu*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxMenuBar_OSXGetAppleMenu(sipCpp);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenu,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_OSXGetAppleMenu, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_GetFrame, "GetFrame() -> Frame");

extern "C" {static PyObject *meth_wxMenuBar_GetFrame(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_GetFrame(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenuBar *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
             ::wxFrame*sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetFrame();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return sipConvertFromType(sipRes,sipType_wxFrame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_GetFrame, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_IsAttached, "IsAttached() -> bool");

extern "C" {static PyObject *meth_wxMenuBar_IsAttached(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_IsAttached(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::wxMenuBar *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->IsAttached();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_IsAttached, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Attach, "Attach(frame)");

extern "C" {static PyObject *meth_wxMenuBar_Attach(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Attach(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxFrame* frame;
         ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_frame,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ8", &sipSelf, sipType_wxMenuBar, &sipCpp, sipType_wxFrame, &frame))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Attach(frame);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Attach, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_Detach, "Detach()");

extern "C" {static PyObject *meth_wxMenuBar_Detach(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_Detach(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenuBar *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxMenuBar, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->Detach();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_Detach, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_MacSetCommonMenuBar, "MacSetCommonMenuBar(menubar)\n"
"\n"
"Enables you to set the global menubar on Mac, that is, the menubar\n"
"displayed when the app is running without any frames open.");

extern "C" {static PyObject *meth_wxMenuBar_MacSetCommonMenuBar(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_MacSetCommonMenuBar(PyObject *, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::wxMenuBar* menubar;

        static const char *sipKwdList[] = {
            sipName_menubar,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J8", sipType_wxMenuBar, &menubar))
        {
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        _wxMenuBar_MacSetCommonMenuBar(menubar);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_MacSetCommonMenuBar, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_MacGetCommonMenuBar, "MacGetCommonMenuBar() -> MenuBar\n"
"\n"
"Enables you to get the global menubar on Mac, that is, the menubar\n"
"displayed when the app is running without any frames open.");

extern "C" {static PyObject *meth_wxMenuBar_MacGetCommonMenuBar(PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_MacGetCommonMenuBar(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::wxMenuBar*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxMenuBar_MacGetCommonMenuBar();
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuBar,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_MacGetCommonMenuBar, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxMenuBar_FindItemById, "FindItemById(id) -> MenuItem\n"
"\n"
"FindItemById(id) -> MenuItem\n"
"\n"
"Finds the menu item object associated with the given menu item\n"
"identifier.");

extern "C" {static PyObject *meth_wxMenuBar_FindItemById(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxMenuBar_FindItemById(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int id;
        const  ::wxMenuBar *sipCpp;

        static const char *sipKwdList[] = {
            sipName_id,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi", &sipSelf, sipType_wxMenuBar, &sipCpp, &id))
        {
             ::wxMenuItem*sipRes = 0;
            int sipIsErr = 0;

        PyErr_Clear();
        Py_BEGIN_ALLOW_THREADS
        sipRes = _wxMenuBar_FindItemById(sipCpp, id);
        Py_END_ALLOW_THREADS
        if (PyErr_Occurred()) sipIsErr = 1;

            if (sipIsErr)
                return 0;

            return sipConvertFromType(sipRes,sipType_wxMenuItem,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MenuBar, sipName_FindItemById, NULL);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxMenuBar(void *, const sipTypeDef *);}
static void *cast_wxMenuBar(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxMenuBar *sipCpp = reinterpret_cast< ::wxMenuBar *>(sipCppV);

    if (targetType == sipType_wxWindow)
        return static_cast< ::wxWindow *>(sipCpp);

    if (targetType == sipType_wxWindowBase)
        return static_cast< ::wxWindowBase *>(sipCpp);

    if (targetType == sipType_wxEvtHandler)
        return static_cast< ::wxEvtHandler *>(sipCpp);

    if (targetType == sipType_wxObject)
        return static_cast< ::wxObject *>(sipCpp);

    if (targetType == sipType_wxTrackable)
        return static_cast< ::wxTrackable *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxMenuBar(void *, int);}
static void release_wxMenuBar(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxMenuBar *>(sipCppV);
    else
        delete reinterpret_cast< ::wxMenuBar *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxMenuBar(sipSimpleWrapper *);}
static void dealloc_wxMenuBar(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxMenuBar *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxMenuBar(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxMenuBar(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxMenuBar(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxMenuBar *sipCpp = 0;

    {
        long style = 0;

        static const char *sipKwdList[] = {
            sipName_style,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|l", &style))
        {

        if (!wxPyCheckForApp()) return NULL;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxMenuBar(style);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxMenuBar[] = {{570, 255, 1}};


static PyMethodDef methods_wxMenuBar[] = {
    {SIP_MLNAME_CAST(sipName_Append), (PyCFunction)meth_wxMenuBar_Append, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Append)},
    {SIP_MLNAME_CAST(sipName_Attach), (PyCFunction)meth_wxMenuBar_Attach, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Attach)},
    {SIP_MLNAME_CAST(sipName_Check), (PyCFunction)meth_wxMenuBar_Check, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Check)},
    {SIP_MLNAME_CAST(sipName_Detach), meth_wxMenuBar_Detach, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_Detach)},
    {SIP_MLNAME_CAST(sipName_DoEnable), (PyCFunction)meth_wxMenuBar_DoEnable, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoFreeze), (PyCFunction)meth_wxMenuBar_DoFreeze, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetBestClientSize), (PyCFunction)meth_wxMenuBar_DoGetBestClientSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetBestSize), (PyCFunction)meth_wxMenuBar_DoGetBestSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetBorderSize), (PyCFunction)meth_wxMenuBar_DoGetBorderSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetClientSize), (PyCFunction)meth_wxMenuBar_DoGetClientSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetPosition), (PyCFunction)meth_wxMenuBar_DoGetPosition, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoGetSize), (PyCFunction)meth_wxMenuBar_DoGetSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoMoveWindow), (PyCFunction)meth_wxMenuBar_DoMoveWindow, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoSetClientSize), (PyCFunction)meth_wxMenuBar_DoSetClientSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoSetSize), (PyCFunction)meth_wxMenuBar_DoSetSize, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoSetSizeHints), (PyCFunction)meth_wxMenuBar_DoSetSizeHints, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoSetWindowVariant), (PyCFunction)meth_wxMenuBar_DoSetWindowVariant, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_DoThaw), (PyCFunction)meth_wxMenuBar_DoThaw, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_Enable), (PyCFunction)meth_wxMenuBar_Enable, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Enable)},
    {SIP_MLNAME_CAST(sipName_EnableTop), (PyCFunction)meth_wxMenuBar_EnableTop, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_EnableTop)},
    {SIP_MLNAME_CAST(sipName_FindItem), (PyCFunction)meth_wxMenuBar_FindItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_FindItem)},
    {SIP_MLNAME_CAST(sipName_FindItemById), (PyCFunction)meth_wxMenuBar_FindItemById, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_FindItemById)},
    {SIP_MLNAME_CAST(sipName_FindMenu), (PyCFunction)meth_wxMenuBar_FindMenu, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_FindMenu)},
    {SIP_MLNAME_CAST(sipName_FindMenuItem), (PyCFunction)meth_wxMenuBar_FindMenuItem, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_FindMenuItem)},
    {SIP_MLNAME_CAST(sipName_GetDefaultBorder), (PyCFunction)meth_wxMenuBar_GetDefaultBorder, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_GetDefaultBorderForControl), (PyCFunction)meth_wxMenuBar_GetDefaultBorderForControl, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_GetFrame), meth_wxMenuBar_GetFrame, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_GetFrame)},
    {SIP_MLNAME_CAST(sipName_GetHelpString), (PyCFunction)meth_wxMenuBar_GetHelpString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetHelpString)},
    {SIP_MLNAME_CAST(sipName_GetLabel), (PyCFunction)meth_wxMenuBar_GetLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetLabel)},
    {SIP_MLNAME_CAST(sipName_GetLabelTop), (PyCFunction)meth_wxMenuBar_GetLabelTop, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetLabelTop)},
    {SIP_MLNAME_CAST(sipName_GetMenu), (PyCFunction)meth_wxMenuBar_GetMenu, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetMenu)},
    {SIP_MLNAME_CAST(sipName_GetMenuCount), meth_wxMenuBar_GetMenuCount, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_GetMenuCount)},
    {SIP_MLNAME_CAST(sipName_GetMenuLabel), (PyCFunction)meth_wxMenuBar_GetMenuLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetMenuLabel)},
    {SIP_MLNAME_CAST(sipName_GetMenuLabelText), (PyCFunction)meth_wxMenuBar_GetMenuLabelText, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_GetMenuLabelText)},
    {SIP_MLNAME_CAST(sipName_Insert), (PyCFunction)meth_wxMenuBar_Insert, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Insert)},
    {SIP_MLNAME_CAST(sipName_IsAttached), meth_wxMenuBar_IsAttached, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_IsAttached)},
    {SIP_MLNAME_CAST(sipName_IsChecked), (PyCFunction)meth_wxMenuBar_IsChecked, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_IsChecked)},
    {SIP_MLNAME_CAST(sipName_IsEnabled), (PyCFunction)meth_wxMenuBar_IsEnabled, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_IsEnabled)},
    {SIP_MLNAME_CAST(sipName_IsEnabledTop), (PyCFunction)meth_wxMenuBar_IsEnabledTop, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_IsEnabledTop)},
    {SIP_MLNAME_CAST(sipName_MacGetCommonMenuBar), meth_wxMenuBar_MacGetCommonMenuBar, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_MacGetCommonMenuBar)},
    {SIP_MLNAME_CAST(sipName_MacSetCommonMenuBar), (PyCFunction)meth_wxMenuBar_MacSetCommonMenuBar, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_MacSetCommonMenuBar)},
    {SIP_MLNAME_CAST(sipName_OSXGetAppleMenu), meth_wxMenuBar_OSXGetAppleMenu, METH_VARARGS, SIP_MLDOC_CAST(doc_wxMenuBar_OSXGetAppleMenu)},
    {SIP_MLNAME_CAST(sipName_ProcessEvent), (PyCFunction)meth_wxMenuBar_ProcessEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_Refresh), (PyCFunction)meth_wxMenuBar_Refresh, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Refresh)},
    {SIP_MLNAME_CAST(sipName_Remove), (PyCFunction)meth_wxMenuBar_Remove, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Remove)},
    {SIP_MLNAME_CAST(sipName_Replace), (PyCFunction)meth_wxMenuBar_Replace, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_Replace)},
    {SIP_MLNAME_CAST(sipName_SendDestroyEvent), (PyCFunction)meth_wxMenuBar_SendDestroyEvent, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_SetHelpString), (PyCFunction)meth_wxMenuBar_SetHelpString, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_SetHelpString)},
    {SIP_MLNAME_CAST(sipName_SetLabel), (PyCFunction)meth_wxMenuBar_SetLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_SetLabel)},
    {SIP_MLNAME_CAST(sipName_SetLabelTop), (PyCFunction)meth_wxMenuBar_SetLabelTop, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_SetLabelTop)},
    {SIP_MLNAME_CAST(sipName_SetMenuLabel), (PyCFunction)meth_wxMenuBar_SetMenuLabel, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxMenuBar_SetMenuLabel)},
    {SIP_MLNAME_CAST(sipName_TryAfter), (PyCFunction)meth_wxMenuBar_TryAfter, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_TryBefore), (PyCFunction)meth_wxMenuBar_TryBefore, METH_VARARGS|METH_KEYWORDS, NULL}
};

PyDoc_STRVAR(doc_wxMenuBar, "MenuBar(style=0)\n"
"\n"
"A menu bar is a series of menus accessible from the top of a frame.");


sipClassTypeDef sipTypeDef__core_wxMenuBar = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_CLASS,
        sipNameNr_wxMenuBar,
        {0},
        0
    },
    {
        sipNameNr_MenuBar,
        {0, 0, 1},
        53, methods_wxMenuBar,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxMenuBar,
    -1,
    -1,
    supers_wxMenuBar,
    0,
    init_type_wxMenuBar,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxMenuBar,
    0,
    0,
    0,
    release_wxMenuBar,
    cast_wxMenuBar,
    0,
    0,
    0,
    0,
    0,
    0
};
