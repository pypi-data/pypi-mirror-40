/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.13
 *
 *     Copyright: (c) 2018 by Total Control Software
 *     License:   wxWindows License
 */

#include "sipAPI_core.h"

        #include <wx/evtloop.h>

        #include <wx/evtloop.h>


class sipwxGUIEventLoop : public  ::wxGUIEventLoop
{
public:
    sipwxGUIEventLoop();
    virtual ~sipwxGUIEventLoop();

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    void sipProtectVirt_OnExit(bool);

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    bool YieldFor(long);
    int Run();
    bool IsOk() const;
    void Exit(int);
    void ScheduleExit(int);
    bool Pending() const;
    bool Dispatch();
    int DispatchTimeout(unsigned long);
    void WakeUp();
    void WakeUpIdle();
    bool ProcessIdle();
    bool IsYielding() const;
    bool IsEventAllowedInsideYield( ::wxEventCategory) const;
    void OnExit();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipwxGUIEventLoop(const sipwxGUIEventLoop &);
    sipwxGUIEventLoop &operator = (const sipwxGUIEventLoop &);

    char sipPyMethods[14];
};

sipwxGUIEventLoop::sipwxGUIEventLoop():  ::wxGUIEventLoop(), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipwxGUIEventLoop::~sipwxGUIEventLoop()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

bool sipwxGUIEventLoop::YieldFor(long eventsToProcess)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_YieldFor);

    if (!sipMeth)
        return  ::wxGUIEventLoop::YieldFor(eventsToProcess);

    extern bool sipVH__core_105(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, long);

    return sipVH__core_105(sipGILState, 0, sipPySelf, sipMeth, eventsToProcess);
}

int sipwxGUIEventLoop::Run()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_Run);

    if (!sipMeth)
        return  ::wxGUIEventLoop::Run();

    extern int sipVH__core_101(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_101(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGUIEventLoop::IsOk() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[2]),sipPySelf,NULL,sipName_IsOk);

    if (!sipMeth)
        return  ::wxGUIEventLoop::IsOk();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGUIEventLoop::Exit(int rc)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_Exit);

    if (!sipMeth)
    {
         ::wxGUIEventLoop::Exit(rc);
        return;
    }

    extern void sipVH__core_102(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    sipVH__core_102(sipGILState, 0, sipPySelf, sipMeth, rc);
}

void sipwxGUIEventLoop::ScheduleExit(int rc)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_ScheduleExit);

    if (!sipMeth)
    {
         ::wxGUIEventLoop::ScheduleExit(rc);
        return;
    }

    extern void sipVH__core_102(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, int);

    sipVH__core_102(sipGILState, 0, sipPySelf, sipMeth, rc);
}

bool sipwxGUIEventLoop::Pending() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[5]),sipPySelf,NULL,sipName_Pending);

    if (!sipMeth)
        return  ::wxGUIEventLoop::Pending();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGUIEventLoop::Dispatch()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_Dispatch);

    if (!sipMeth)
        return  ::wxGUIEventLoop::Dispatch();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

int sipwxGUIEventLoop::DispatchTimeout(unsigned long timeout)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[7],sipPySelf,NULL,sipName_DispatchTimeout);

    if (!sipMeth)
        return  ::wxGUIEventLoop::DispatchTimeout(timeout);

    extern int sipVH__core_103(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, unsigned long);

    return sipVH__core_103(sipGILState, 0, sipPySelf, sipMeth, timeout);
}

void sipwxGUIEventLoop::WakeUp()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[8],sipPySelf,NULL,sipName_WakeUp);

    if (!sipMeth)
    {
         ::wxGUIEventLoop::WakeUp();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGUIEventLoop::WakeUpIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[9],sipPySelf,NULL,sipName_WakeUpIdle);

    if (!sipMeth)
    {
         ::wxGUIEventLoop::WakeUpIdle();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGUIEventLoop::ProcessIdle()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[10],sipPySelf,NULL,sipName_ProcessIdle);

    if (!sipMeth)
        return  ::wxGUIEventLoop::ProcessIdle();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGUIEventLoop::IsYielding() const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[11]),sipPySelf,NULL,sipName_IsYielding);

    if (!sipMeth)
        return  ::wxGUIEventLoop::IsYielding();

    extern bool sipVH__core_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    return sipVH__core_8(sipGILState, 0, sipPySelf, sipMeth);
}

bool sipwxGUIEventLoop::IsEventAllowedInsideYield( ::wxEventCategory cat) const
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,const_cast<char *>(&sipPyMethods[12]),sipPySelf,NULL,sipName_IsEventAllowedInsideYield);

    if (!sipMeth)
        return  ::wxGUIEventLoop::IsEventAllowedInsideYield(cat);

    extern bool sipVH__core_104(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::wxEventCategory);

    return sipVH__core_104(sipGILState, 0, sipPySelf, sipMeth, cat);
}

void sipwxGUIEventLoop::OnExit()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[13],sipPySelf,NULL,sipName_OnExit);

    if (!sipMeth)
    {
         ::wxGUIEventLoop::OnExit();
        return;
    }

    extern void sipVH__core_48(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH__core_48(sipGILState, 0, sipPySelf, sipMeth);
}

void sipwxGUIEventLoop::sipProtectVirt_OnExit(bool sipSelfWasArg)
{
    (sipSelfWasArg ?  ::wxEventLoopBase::OnExit() : OnExit());
}


PyDoc_STRVAR(doc_wxGUIEventLoop_OnExit, "OnExit()\n"
"\n"
"This function is called before the event loop terminates, whether this\n"
"happens normally (because of Exit() call) or abnormally (because of an\n"
"exception thrown from inside the loop).");

extern "C" {static PyObject *meth_wxGUIEventLoop_OnExit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_OnExit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        sipwxGUIEventLoop *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_wxGUIEventLoop, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp->sipProtectVirt_OnExit(sipSelfWasArg);
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_OnExit, NULL);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_Run, "Run(self) -> int");

extern "C" {static PyObject *meth_wxGUIEventLoop_Run(PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_Run(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGUIEventLoop *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGUIEventLoop, &sipCpp))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::Run() : sipCpp->Run());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_Run, doc_wxGUIEventLoop_Run);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_Exit, "Exit(self, rc: int = 0)");

extern "C" {static PyObject *meth_wxGUIEventLoop_Exit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_Exit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int rc = 0;
         ::wxGUIEventLoop *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rc,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|i", &sipSelf, sipType_wxGUIEventLoop, &sipCpp, &rc))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::Exit(rc) : sipCpp->Exit(rc));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_Exit, doc_wxGUIEventLoop_Exit);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_ScheduleExit, "ScheduleExit(self, rc: int = 0)");

extern "C" {static PyObject *meth_wxGUIEventLoop_ScheduleExit(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_ScheduleExit(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        int rc = 0;
         ::wxGUIEventLoop *sipCpp;

        static const char *sipKwdList[] = {
            sipName_rc,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "B|i", &sipSelf, sipType_wxGUIEventLoop, &sipCpp, &rc))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::ScheduleExit(rc) : sipCpp->ScheduleExit(rc));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_ScheduleExit, doc_wxGUIEventLoop_ScheduleExit);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_Pending, "Pending(self) -> bool");

extern "C" {static PyObject *meth_wxGUIEventLoop_Pending(PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_Pending(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::wxGUIEventLoop *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGUIEventLoop, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::Pending() : sipCpp->Pending());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_Pending, doc_wxGUIEventLoop_Pending);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_Dispatch, "Dispatch(self) -> bool");

extern "C" {static PyObject *meth_wxGUIEventLoop_Dispatch(PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_Dispatch(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGUIEventLoop *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGUIEventLoop, &sipCpp))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::Dispatch() : sipCpp->Dispatch());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_Dispatch, doc_wxGUIEventLoop_Dispatch);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_DispatchTimeout, "DispatchTimeout(self, timeout: int) -> int");

extern "C" {static PyObject *meth_wxGUIEventLoop_DispatchTimeout(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_DispatchTimeout(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        unsigned long timeout;
         ::wxGUIEventLoop *sipCpp;

        static const char *sipKwdList[] = {
            sipName_timeout,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bm", &sipSelf, sipType_wxGUIEventLoop, &sipCpp, &timeout))
        {
            int sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::DispatchTimeout(timeout) : sipCpp->DispatchTimeout(timeout));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_DispatchTimeout, doc_wxGUIEventLoop_DispatchTimeout);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_WakeUp, "WakeUp(self)");

extern "C" {static PyObject *meth_wxGUIEventLoop_WakeUp(PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_WakeUp(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::wxGUIEventLoop *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_wxGUIEventLoop, &sipCpp))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::WakeUp() : sipCpp->WakeUp());
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_WakeUp, doc_wxGUIEventLoop_WakeUp);

    return NULL;
}


PyDoc_STRVAR(doc_wxGUIEventLoop_YieldFor, "YieldFor(self, eventsToProcess: int) -> bool");

extern "C" {static PyObject *meth_wxGUIEventLoop_YieldFor(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_wxGUIEventLoop_YieldFor(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        long eventsToProcess;
         ::wxGUIEventLoop *sipCpp;

        static const char *sipKwdList[] = {
            sipName_eventsToProcess,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bl", &sipSelf, sipType_wxGUIEventLoop, &sipCpp, &eventsToProcess))
        {
            bool sipRes;

            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipRes = (sipSelfWasArg ? sipCpp-> ::wxGUIEventLoop::YieldFor(eventsToProcess) : sipCpp->YieldFor(eventsToProcess));
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
                return 0;

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_GUIEventLoop, sipName_YieldFor, doc_wxGUIEventLoop_YieldFor);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_wxGUIEventLoop(void *, const sipTypeDef *);}
static void *cast_wxGUIEventLoop(void *sipCppV, const sipTypeDef *targetType)
{
     ::wxGUIEventLoop *sipCpp = reinterpret_cast< ::wxGUIEventLoop *>(sipCppV);

    if (targetType == sipType_wxEventLoopBase)
        return static_cast< ::wxEventLoopBase *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_wxGUIEventLoop(void *, int);}
static void release_wxGUIEventLoop(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipwxGUIEventLoop *>(sipCppV);
    else
        delete reinterpret_cast< ::wxGUIEventLoop *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void dealloc_wxGUIEventLoop(sipSimpleWrapper *);}
static void dealloc_wxGUIEventLoop(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipwxGUIEventLoop *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_wxGUIEventLoop(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_wxGUIEventLoop(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_wxGUIEventLoop(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipwxGUIEventLoop *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            PyErr_Clear();

            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipwxGUIEventLoop();
            Py_END_ALLOW_THREADS

            if (PyErr_Occurred())
            {
                delete sipCpp;
                return NULL;
            }

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_wxGUIEventLoop[] = {{146, 255, 1}};


static PyMethodDef methods_wxGUIEventLoop[] = {
    {SIP_MLNAME_CAST(sipName_Dispatch), meth_wxGUIEventLoop_Dispatch, METH_VARARGS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_Dispatch)},
    {SIP_MLNAME_CAST(sipName_DispatchTimeout), (PyCFunction)meth_wxGUIEventLoop_DispatchTimeout, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_DispatchTimeout)},
    {SIP_MLNAME_CAST(sipName_Exit), (PyCFunction)meth_wxGUIEventLoop_Exit, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_Exit)},
    {SIP_MLNAME_CAST(sipName_OnExit), (PyCFunction)meth_wxGUIEventLoop_OnExit, METH_VARARGS|METH_KEYWORDS, NULL},
    {SIP_MLNAME_CAST(sipName_Pending), meth_wxGUIEventLoop_Pending, METH_VARARGS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_Pending)},
    {SIP_MLNAME_CAST(sipName_Run), meth_wxGUIEventLoop_Run, METH_VARARGS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_Run)},
    {SIP_MLNAME_CAST(sipName_ScheduleExit), (PyCFunction)meth_wxGUIEventLoop_ScheduleExit, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_ScheduleExit)},
    {SIP_MLNAME_CAST(sipName_WakeUp), meth_wxGUIEventLoop_WakeUp, METH_VARARGS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_WakeUp)},
    {SIP_MLNAME_CAST(sipName_YieldFor), (PyCFunction)meth_wxGUIEventLoop_YieldFor, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_wxGUIEventLoop_YieldFor)}
};

PyDoc_STRVAR(doc_wxGUIEventLoop, "GUIEventLoop()\n"
"\n"
"A generic implementation of the GUI event loop.");


sipClassTypeDef sipTypeDef__core_wxGUIEventLoop = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_wxGUIEventLoop,
        {0},
        0
    },
    {
        sipNameNr_GUIEventLoop,
        {0, 0, 1},
        9, methods_wxGUIEventLoop,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_wxGUIEventLoop,
    -1,
    -1,
    supers_wxGUIEventLoop,
    0,
    init_type_wxGUIEventLoop,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_wxGUIEventLoop,
    0,
    0,
    0,
    release_wxGUIEventLoop,
    cast_wxGUIEventLoop,
    0,
    0,
    0,
    0,
    0,
    0
};
