#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.psutils',
  description = 'Assorted process management functions.',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20190101',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 (GPLv3)'],
  install_requires = [],
  keywords = ['python2', 'python3'],
  long_description = "Assorted process management functions.\n\n## Function `groupargv(pre_argv, argv, post_argv=(), max_argv=None, encode=False)`\n\nDistribute the array `argv` over multiple arrays\nto fit within `MAX_ARGV`.\nReturn a list of argv lists.\n\nParameters:\n* `pre_argv`: the sequence of leading arguments\n* `argv`: the sequence of arguments to distribute; this may not be empty\n* `post_argv`: optional, the sequence of trailing arguments\n* `max_argv`: optional, the maximum length of each distributed\n  argument list, default: MAX_ARGV\n* `encode`: default False.\n  If true, encode the argv sequences into bytes for accurate tallying.\n  If `encode` is a Boolean,\n  encode the elements with their .encode() method.\n  If `encode` is a `str`, encode the elements with their `.encode()`\n  method with `encode` as the encoding name;\n  otherwise presume that `encode` is a callable\n  for encoding each element.\n\nThe returned argv arrays will contain the encoded element values.\n\n## Function `PidFileManager(path, pid=None)`\n\nContext manager for a pid file.\n\nParameters:\n* `path`: the path to the process id file.\n* `pid`: the process id to store in the pid file,\n  default from `os.etpid`.\n\nWrites the process id file at the start\nand removes the process id file at the end.\n\n## Function `pipefrom(argv, trace=False, binary=False, keep_stdin=False, **kw)`\n\nPipe text from a command.\nOptionally trace invocation.\nReturn the `Popen` object with `.stdout` decoded as text.\n\nParameters:\n* `argv`: the command argument list\n* `binary`: if true (default false)\n  return the raw stdout instead of a text wrapper\n* `trace`: if true (default `False`),\n  if `trace` is `True`, recite invocation to stderr\n  otherwise presume that `trace` is a stream\n  to which to recite the invocation.\n* `keep_stdin`: if true (default `False`)\n  do not attach the command's standard input to the null device.\n  The default behaviour is to do so,\n  preventing commands from accidentally\n  consuming the main process' input stream.\n\nOther keyword arguments are passed to the `io.TextIOWrapper`\nwhich wraps the command's output.\n\n## Function `pipeto(argv, trace=False, **kw)`\n\nPipe text to a command.\nOptionally trace invocation.\nReturn the Popen object with .stdin encoded as text.\n\nParameters:\n* `argv`: the command argument list\n* `trace`: if true (default `False`),\n  if `trace` is `True`, recite invocation to stderr\n  otherwise presume that `trace` is a stream\n  to which to recite the invocation.\n\nOther keyword arguments are passed to the `io.TextIOWrapper`\nwhich wraps the command's input.\n\n## Function `remove_pidfile(path)`\n\nTruncate and remove a pidfile, permissions permitting.\n\n## Function `run(argv, logger=None, pids=None, **kw)`\n\nRun a command. Optionally trace invocation.\nReturn result of subprocess.call.\n\nParameters:\n* `argv`: the command argument list\n* `pids`: if supplied and not None,\n  call .add and .remove with the subprocess pid around the execution\n\nOther keyword arguments are passed to `subprocess.call`.\n\n## Function `stop(pid, signum=<Signals.SIGTERM: 15>, wait=None, do_SIGKILL=False)`\n\nStop the process specified by `pid`, optionally await its demise.\n\nParameters:\n* `pid`: process id.\n  If `pid` is a string, treat as a process id file and read the\n  process id from it.\n* `signum`: the signal to send, default `signal.SIGTERM`.\n* `wait`: whether to wait for the process, default `None`.\n  If `None`, return `True` (signal delivered).\n  If `0`, wait indefinitely until the process exits as tested by\n  `os.kill(pid, 0)`.\n  If greater than 0, wait up to `wait` seconds for the process to die;\n  if it exits, return `True`, otherwise `False`;\n* `do_SIGKILL`: if true (default `False`),\n  send the process `signal.SIGKILL` as a final measure before return.\n\n## Function `write_pidfile(path, pid=None)`\n\nWrite a process id to a pid file.\n\nParameters:\n* `path`: the path to the pid file.\n* `pid`: the process id to write, defautl from `os.getpid`.",
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.psutils'],
)
