#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Sep 18 10:42:33 2018 by generateDS.py version 2.29.24.
# Python 2.7.14 (default, Sep 11 2018, 11:39:53)  [GCC 4.4.7 20120313 (Red Hat 4.4.7-23)]
#
# Command line options:
#   ('--namespacedef', 'xmlns:http://payfac.vantivcnp.com/api/merchant/onboard')
#   ('-o', 'generatedClass.py')
#
# Command line arguments:
#   /usr/local/litle-home/cchang/git/payfac-mp-sdk-python/schema/merchant-onboard-api-v13.xsd
#
# Command line:
#   /usr/local/litle-home/cchang/git/payfac-mp-sdk-python/env27/bin/generateDS.py --namespacedef="xmlns:http://payfac.vantivcnp.com/api/merchant/onboard" -o "generatedClass.py" /usr/local/litle-home/cchang/git/payfac-mp-sdk-python/schema/merchant-onboard-api-v13.xsd
#
# Current working directory (os.getcwd()):
#   tools
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class businessNameAddressPhoneAssociationCode(object):
    NOT_VERIFIED='NOT_VERIFIED'
    WRONG_PHONE='WRONG_PHONE'
    NAME_OR_ADDRESS='NAME_OR_ADDRESS'
    BAD_NAME='BAD_NAME'
    BAD_ADDRESS='BAD_ADDRESS'
    MISSING_ADDRESS='MISSING_ADDRESS'
    NAME_AND_ADDRESS_BAD_PHONE='NAME_AND_ADDRESS_BAD_PHONE'
    NAME_AND_ADDRESS_NO_PHONE='NAME_AND_ADDRESS_NO_PHONE'
    NAME_ADDRESS_PHONE='NAME_ADDRESS_PHONE'


class businessOverallScore(object):
    _0='0'
    _1_0='10'
    _2_0='20'
    _3_0='30'
    _4_0='40'
    _5_0='50'


class businessToPrincipalScore(object):
    _0='0'
    _1_0='10'
    _2_0='20'
    _3_0='30'
    _4_0='40'
    _5_0='50'


class legalEntityAgreementType(object):
    MERCHANT_AGREEMENT='MERCHANT_AGREEMENT'


class legalEntityOwnershipType(object):
    PUBLIC='PUBLIC'
    PRIVATE='PRIVATE'


class legalEntityType(object):
    INDIVIDUAL_SOLE_PROPRIETORSHIP='INDIVIDUAL_SOLE_PROPRIETORSHIP'
    CORPORATION='CORPORATION'
    LIMITED_LIABILITY_COMPANY='LIMITED_LIABILITY_COMPANY'
    PARTNERSHIP='PARTNERSHIP'
    LIMITED_PARTNERSHIP='LIMITED_PARTNERSHIP'
    GENERAL_PARTNERSHIP='GENERAL_PARTNERSHIP'
    TAX_EXEMPT_ORGANIZATION='TAX_EXEMPT_ORGANIZATION'
    GOVERNMENT_AGENCY='GOVERNMENT_AGENCY'


class nameAddressSsnAssociationCode(object):
    NOTHING='NOTHING'
    WRONG_SSN='WRONG_SSN'
    FIRST_LAST='FIRST_LAST'
    FIRST_ADDRESS='FIRST_ADDRESS'
    FIRST_SSN='FIRST_SSN'
    LAST_ADDRESS='LAST_ADDRESS'
    ADDRESS_SSN='ADDRESS_SSN'
    LAST_SSN='LAST_SSN'
    FIRST_LAST_ADDRESS='FIRST_LAST_ADDRESS'
    FIRST_LAST_SSN='FIRST_LAST_SSN'
    FIRST_ADDRESS_SSN='FIRST_ADDRESS_SSN'
    LAST_ADDRESS_SSN='LAST_ADDRESS_SSN'
    FIRST_LAST_ADDRESS_SSN='FIRST_LAST_ADDRESS_SSN'


class nameAddressTaxIdAssociationCode(object):
    NOT_VERIFIED='NOT_VERIFIED'
    WRONG_TAX_ID='WRONG_TAX_ID'
    NAME_OR_ADDRESS='NAME_OR_ADDRESS'
    BAD_NAME='BAD_NAME'
    BAD_ADDRESS='BAD_ADDRESS'
    MISSING_ADDRESS='MISSING_ADDRESS'
    NAME_AND_ADDRESS_BAD_TAX_ID='NAME_AND_ADDRESS_BAD_TAX_ID'
    NAME_AND_ADDRESS_NO_TAX_ID='NAME_AND_ADDRESS_NO_TAX_ID'
    NAME_ADDRESS_TAX_ID='NAME_ADDRESS_TAX_ID'


class principalNameAddressPhoneAssociationCode(object):
    NOTHING='NOTHING'
    WRONG_PHONE='WRONG_PHONE'
    FIRST_LAST='FIRST_LAST'
    FIRST_ADDRESS='FIRST_ADDRESS'
    FIRST_PHONE='FIRST_PHONE'
    LAST_ADDRESS='LAST_ADDRESS'
    ADDRESS_PHONE='ADDRESS_PHONE'
    LAST_PHONE='LAST_PHONE'
    FIRST_LAST_ADDRESS='FIRST_LAST_ADDRESS'
    FIRST_LAST_PHONE='FIRST_LAST_PHONE'
    FIRST_ADDRESS_PHONE='FIRST_ADDRESS_PHONE'
    LAST_ADDRESS_PHONE='LAST_ADDRESS_PHONE'
    FIRST_LAST_ADDRESS_PHONE='FIRST_LAST_ADDRESS_PHONE'


class principalOverallScore(object):
    _0='0'
    _1_0='10'
    _2_0='20'
    _3_0='30'
    _4_0='40'
    _5_0='50'


class riskIndicatorCode(object):
    UNKNOWN='UNKNOWN'
    SSN_DECEASED='SSN_DECEASED'
    SSN_PRIOR_TO_DOB='SSN_PRIOR_TO_DOB'
    SSN_ADDRESS_PHONE_NOT_MATCH='SSN_ADDRESS_PHONE_NOT_MATCH'
    SSN_INVALID='SSN_INVALID'
    PHONE_NUMBER_DISCONNECTED='PHONE_NUMBER_DISCONNECTED'
    PHONE_NUMBER_INVALID='PHONE_NUMBER_INVALID'
    PHONE_NUMBER_PAGER='PHONE_NUMBER_PAGER'
    PHONE_NUMBER_MOBILE='PHONE_NUMBER_MOBILE'
    ADDRESS_INVALID='ADDRESS_INVALID'
    ZIP_BELONGS_POST_OFFICE='ZIP_BELONGS_POST_OFFICE'
    ADDRESS_INVALID_APARTMENT_DESIGNATION='ADDRESS_INVALID_APARTMENT_DESIGNATION'
    ADDRESS_COMMERCIAL='ADDRESS_COMMERCIAL'
    PHONE_NUMBER_COMMERCIAL='PHONE_NUMBER_COMMERCIAL'
    PHONE_NUMBER_ZIP_INVALID='PHONE_NUMBER_ZIP_INVALID'
    UNABLE_TO_VERIFY_NAS='UNABLE_TO_VERIFY_NAS'
    UNABLE_TO_VERIFY_ADDRESS='UNABLE_TO_VERIFY_ADDRESS'
    UNABLE_TO_VERIFY_SSN='UNABLE_TO_VERIFY_SSN'
    UNABLE_TO_VERIFY_PHONE='UNABLE_TO_VERIFY_PHONE'
    UNABLE_TO_VERIFY_DOB='UNABLE_TO_VERIFY_DOB'
    SSN_MISKEYED='SSN_MISKEYED'
    ADDRESS_MISKEYED='ADDRESS_MISKEYED'
    PHONE_NUMBER_MISKEYED='PHONE_NUMBER_MISKEYED'
    NAME_MATCHES_OFAC='NAME_MATCHES_OFAC'
    UNABLE_TO_VERIFY_NAME='UNABLE_TO_VERIFY_NAME'
    SSN_MATCHES_MULTI_NAMES='SSN_MATCHES_MULTI_NAMES'
    SSN_RECENTLY_ISSUED='SSN_RECENTLY_ISSUED'
    ZIP_CORPORATE_MILITARY='ZIP_CORPORATE_MILITARY'
    DLL_INVALID='DLL_INVALID'
    NAME_ADDRESS_MATCH_BANKRUPTCY='NAME_ADDRESS_MATCH_BANKRUPTCY'
    PHONE_AREA_CODE_CHANGING='PHONE_AREA_CODE_CHANGING'
    WORK_PHONE_PAGER='WORK_PHONE_PAGER'
    UNABLE_TO_VERIFY_FIRST_NAME='UNABLE_TO_VERIFY_FIRST_NAME'
    PHONE_ADDRESS_DISTANT='PHONE_ADDRESS_DISTANT'
    ADDRESS_MATCHES_PRISON='ADDRESS_MATCHES_PRISON'
    SSN_LAST_NAME_NO_MATCH='SSN_LAST_NAME_NO_MATCH'
    SSN_FIRST_NAME_NO_MATCH='SSN_FIRST_NAME_NO_MATCH'
    WORK_HOME_PHONE_DISTANT='WORK_HOME_PHONE_DISTANT'
    NAME_ADDRESS_TIN_MISMATCH='NAME_ADDRESS_TIN_MISMATCH'
    WORK_PHONE_INVALID='WORK_PHONE_INVALID'
    WORK_PHONE_DISCONNECTED='WORK_PHONE_DISCONNECTED'
    WORK_PHONE_MOBILE='WORK_PHONE_MOBILE'
    ADDRESS_RETURNS_DIFF_PHONE='ADDRESS_RETURNS_DIFF_PHONE'
    SSN_LNAME_NOT_MATCHED_FNAME_MATCHED='SSN_LNAME_NOT_MATCHED_FNAME_MATCHED'
    PHONE_RESIDENTIAL_LISTING='PHONE_RESIDENTIAL_LISTING'
    SINGLE_FAMILY_DWELLING='SINGLE_FAMILY_DWELLING'
    SSN_NOT_FOUND='SSN_NOT_FOUND'
    SSN_BELONGS_TO_DIFF_NAME_ADDRESS='SSN_BELONGS_TO_DIFF_NAME_ADDRESS'
    PHONE_BELONGS_TO_DIFF_NAME_ADDRESS='PHONE_BELONGS_TO_DIFF_NAME_ADDRESS'
    NAME_ADDRESS_UNLISTED='NAME_ADDRESS_UNLISTED'
    NAME_MISKEYED='NAME_MISKEYED'
    NAME_MISSING='NAME_MISSING'
    ADDRESS_MISSING='ADDRESS_MISSING'
    SSN_MISSING='SSN_MISSING'
    PHONE_NUMBER_MISSING='PHONE_NUMBER_MISSING'
    DOB_MISSING='DOB_MISSING'
    NAME_ADDRESS_RETURN_DIFF_PHONE='NAME_ADDRESS_RETURN_DIFF_PHONE'
    DOB_MISKEYED='DOB_MISKEYED'
    SSN_NON_US_CITIZEN='SSN_NON_US_CITIZEN'
    ALTERNATE_BUSINESS_NAME_FOUND='ALTERNATE_BUSINESS_NAME_FOUND'
    DBA_MATCH_PUBLIC_RECORDS='DBA_MATCH_PUBLIC_RECORDS'
    SSN_RECENT='SSN_RECENT'
    SSN_TOO_OLD='SSN_TOO_OLD'
    TIN_NAME_ADDRESS_MISMATCH='TIN_NAME_ADDRESS_MISMATCH'
    BUSINESS_NOT_IN_GOOD_STANDING='BUSINESS_NOT_IN_GOOD_STANDING'
    NAME_ADDRESS_MATCH_JUDGMENT='NAME_ADDRESS_MATCH_JUDGMENT'
    BUSINESS_INACTIVE='BUSINESS_INACTIVE'
    NO_UPDATE_IN_LAST_THREE_YEARS='NO_UPDATE_IN_LAST_THREE_YEARS'
    SSN_NOT_PRIMARY='SSN_NOT_PRIMARY'
    ZIP_CORP_ONLY='ZIP_CORP_ONLY'
    ADDRESS_MISMATCH='ADDRESS_MISMATCH'
    DL_DIFFERENT='DL_DIFFERENT'
    DL_NOT_FOUND='DL_NOT_FOUND'
    DL_MISKEYED='DL_MISKEYED'
    UNABLE_TO_VERIFY_DL='UNABLE_TO_VERIFY_DL'
    SSN_INVALID_SSA='SSN_INVALID_SSA'
    SSN_IS_ITIN='SSN_IS_ITIN'
    SSN_MULTI_IDENTITY='SSN_MULTI_IDENTITY'
    ZIP_MILITARY='ZIP_MILITARY'
    MULTIPLE_SSN_FOUND='MULTIPLE_SSN_FOUND'
    ADDRESS_DISCREPANCY='ADDRESS_DISCREPANCY'
    ADDRESS_PO_BOX='ADDRESS_PO_BOX'
    SSN_RANDOM_SSA='SSN_RANDOM_SSA'
    ADDRESS_MISMATCH_SECONDARY='ADDRESS_MISMATCH_SECONDARY'
    NAME_MATCHES_NON_OFAC='NAME_MATCHES_NON_OFAC'
    UNABLE_TO_VERIFY_ZIP_CODE='UNABLE_TO_VERIFY_ZIP_CODE'
    IP_ADDRESS_UNKNOWN='IP_ADDRESS_UNKNOWN'
    IP_ADDRESS_DIFFERENT_STATE='IP_ADDRESS_DIFFERENT_STATE'
    IP_ADDRESS_DIFFERENT_ZIP='IP_ADDRESS_DIFFERENT_ZIP'
    IP_ADDRESS_DIFFERENT_PHONE='IP_ADDRESS_DIFFERENT_PHONE'
    IP_ADDRESS_DOMAIN_UNKNOWN='IP_ADDRESS_DOMAIN_UNKNOWN'
    IP_ADDRESS_NOT_ASSIGNED_TO_USA='IP_ADDRESS_NOT_ASSIGNED_TO_USA'
    IP_ADDRESS_NON_ROUTABLE='IP_ADDRESS_NON_ROUTABLE'


class legalEntityCreateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityName=None, legalEntityType=None, legalEntityOwnershipType=None, doingBusinessAs=None, taxId=None, contactPhone=None, annualCreditCardSalesVolume=None, hasAcceptedCreditCards=None, address=None, principal=None, yearsInBusiness=None, extensiontype_=None):
        self.original_tagname_ = None
        self.legalEntityName = legalEntityName
        self.validate_legalEntityNameType(self.legalEntityName)
        self.legalEntityType = legalEntityType
        self.validate_legalEntityType(self.legalEntityType)
        self.legalEntityOwnershipType = legalEntityOwnershipType
        self.validate_legalEntityOwnershipType(self.legalEntityOwnershipType)
        self.doingBusinessAs = doingBusinessAs
        self.validate_doingBusinessAsType(self.doingBusinessAs)
        self.taxId = taxId
        self.validate_taxIdType(self.taxId)
        self.contactPhone = contactPhone
        self.validate_contactPhoneType(self.contactPhone)
        self.annualCreditCardSalesVolume = annualCreditCardSalesVolume
        self.hasAcceptedCreditCards = hasAcceptedCreditCards
        self.address = address
        self.principal = principal
        self.yearsInBusiness = yearsInBusiness
        self.validate_yearsInBusinessType(self.yearsInBusiness)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityCreateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityCreateRequest.subclass:
            return legalEntityCreateRequest.subclass(*args_, **kwargs_)
        else:
            return legalEntityCreateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityName(self): return self.legalEntityName
    def set_legalEntityName(self, legalEntityName): self.legalEntityName = legalEntityName
    def get_legalEntityType(self): return self.legalEntityType
    def set_legalEntityType(self, legalEntityType): self.legalEntityType = legalEntityType
    def get_legalEntityOwnershipType(self): return self.legalEntityOwnershipType
    def set_legalEntityOwnershipType(self, legalEntityOwnershipType): self.legalEntityOwnershipType = legalEntityOwnershipType
    def get_doingBusinessAs(self): return self.doingBusinessAs
    def set_doingBusinessAs(self, doingBusinessAs): self.doingBusinessAs = doingBusinessAs
    def get_taxId(self): return self.taxId
    def set_taxId(self, taxId): self.taxId = taxId
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_annualCreditCardSalesVolume(self): return self.annualCreditCardSalesVolume
    def set_annualCreditCardSalesVolume(self, annualCreditCardSalesVolume): self.annualCreditCardSalesVolume = annualCreditCardSalesVolume
    def get_hasAcceptedCreditCards(self): return self.hasAcceptedCreditCards
    def set_hasAcceptedCreditCards(self, hasAcceptedCreditCards): self.hasAcceptedCreditCards = hasAcceptedCreditCards
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_yearsInBusiness(self): return self.yearsInBusiness
    def set_yearsInBusiness(self, yearsInBusiness): self.yearsInBusiness = yearsInBusiness
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_legalEntityNameType(self, value):
        # Validate type legalEntityNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityNameType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_legalEntityNameType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_legalEntityNameType_patterns_, ))
    validate_legalEntityNameType_patterns_ = [[u'^\\p{IsBasicLatin}*$']]
    def validate_legalEntityType(self, value):
        # Validate type legalEntityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INDIVIDUAL_SOLE_PROPRIETORSHIP', 'CORPORATION', 'LIMITED_LIABILITY_COMPANY', 'PARTNERSHIP', 'LIMITED_PARTNERSHIP', 'GENERAL_PARTNERSHIP', 'TAX_EXEMPT_ORGANIZATION', 'GOVERNMENT_AGENCY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on legalEntityType' % {"value" : value.encode("utf-8")} )
    def validate_legalEntityOwnershipType(self, value):
        # Validate type legalEntityOwnershipType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PUBLIC', 'PRIVATE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on legalEntityOwnershipType' % {"value" : value.encode("utf-8")} )
    def validate_doingBusinessAsType(self, value):
        # Validate type doingBusinessAsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on doingBusinessAsType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on doingBusinessAsType' % {"value" : value.encode("utf-8")} )
    def validate_taxIdType(self, value):
        # Validate type taxIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on taxIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 9:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on taxIdType' % {"value" : value.encode("utf-8")} )
    def validate_contactPhoneType(self, value):
        # Validate type contactPhoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on contactPhoneType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on contactPhoneType' % {"value" : value.encode("utf-8")} )
    def validate_yearsInBusinessType(self, value):
        # Validate type yearsInBusinessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on yearsInBusinessType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on yearsInBusinessType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_yearsInBusinessType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_yearsInBusinessType_patterns_, ))
    validate_yearsInBusinessType_patterns_ = [[u'^[0-9]{0,3}$']]
    def hasContent_(self):
        if (
            self.legalEntityName is not None or
            self.legalEntityType is not None or
            self.legalEntityOwnershipType is not None or
            self.doingBusinessAs is not None or
            self.taxId is not None or
            self.contactPhone is not None or
            self.annualCreditCardSalesVolume is not None or
            self.hasAcceptedCreditCards is not None or
            self.address is not None or
            self.principal is not None or
            self.yearsInBusiness is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityCreateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityCreateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityCreateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityCreateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityCreateRequest'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityCreateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityName>%s</tns:legalEntityName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityName), input_name='legalEntityName')), eol_))
        if self.legalEntityType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityType>%s</tns:legalEntityType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityType), input_name='legalEntityType')), eol_))
        if self.legalEntityOwnershipType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityOwnershipType>%s</tns:legalEntityOwnershipType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityOwnershipType), input_name='legalEntityOwnershipType')), eol_))
        if self.doingBusinessAs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:doingBusinessAs>%s</tns:doingBusinessAs>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.doingBusinessAs), input_name='doingBusinessAs')), eol_))
        if self.taxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxId>%s</tns:taxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxId), input_name='taxId')), eol_))
        if self.contactPhone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:contactPhone>%s</tns:contactPhone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.contactPhone), input_name='contactPhone')), eol_))
        if self.annualCreditCardSalesVolume is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:annualCreditCardSalesVolume>%s</tns:annualCreditCardSalesVolume>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.annualCreditCardSalesVolume), input_name='annualCreditCardSalesVolume')), eol_))
        if self.hasAcceptedCreditCards is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:hasAcceptedCreditCards>%s</tns:hasAcceptedCreditCards>%s' % (self.gds_format_boolean(self.hasAcceptedCreditCards, input_name='hasAcceptedCreditCards'), eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
        if self.yearsInBusiness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:yearsInBusiness>%s</tns:yearsInBusiness>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.yearsInBusiness), input_name='yearsInBusiness')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityName':
            legalEntityName_ = child_.text
            legalEntityName_ = self.gds_validate_string(legalEntityName_, node, 'legalEntityName')
            self.legalEntityName = legalEntityName_
            # validate type legalEntityNameType
            self.validate_legalEntityNameType(self.legalEntityName)
        elif nodeName_ == 'legalEntityType':
            legalEntityType_ = child_.text
            legalEntityType_ = self.gds_validate_string(legalEntityType_, node, 'legalEntityType')
            self.legalEntityType = legalEntityType_
            # validate type legalEntityType
            self.validate_legalEntityType(self.legalEntityType)
        elif nodeName_ == 'legalEntityOwnershipType':
            legalEntityOwnershipType_ = child_.text
            legalEntityOwnershipType_ = self.gds_validate_string(legalEntityOwnershipType_, node, 'legalEntityOwnershipType')
            self.legalEntityOwnershipType = legalEntityOwnershipType_
            # validate type legalEntityOwnershipType
            self.validate_legalEntityOwnershipType(self.legalEntityOwnershipType)
        elif nodeName_ == 'doingBusinessAs':
            doingBusinessAs_ = child_.text
            doingBusinessAs_ = self.gds_validate_string(doingBusinessAs_, node, 'doingBusinessAs')
            self.doingBusinessAs = doingBusinessAs_
            # validate type doingBusinessAsType
            self.validate_doingBusinessAsType(self.doingBusinessAs)
        elif nodeName_ == 'taxId':
            taxId_ = child_.text
            taxId_ = self.gds_validate_string(taxId_, node, 'taxId')
            self.taxId = taxId_
            # validate type taxIdType
            self.validate_taxIdType(self.taxId)
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
            # validate type contactPhoneType
            self.validate_contactPhoneType(self.contactPhone)
        elif nodeName_ == 'annualCreditCardSalesVolume':
            annualCreditCardSalesVolume_ = child_.text
            annualCreditCardSalesVolume_ = self.gds_validate_string(annualCreditCardSalesVolume_, node, 'annualCreditCardSalesVolume')
            self.annualCreditCardSalesVolume = annualCreditCardSalesVolume_
        elif nodeName_ == 'hasAcceptedCreditCards':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasAcceptedCreditCards')
            self.hasAcceptedCreditCards = ival_
        elif nodeName_ == 'address':
            obj_ = address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'principal':
            obj_ = legalEntityPrincipal.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        elif nodeName_ == 'yearsInBusiness':
            yearsInBusiness_ = child_.text
            yearsInBusiness_ = self.gds_validate_string(yearsInBusiness_, node, 'yearsInBusiness')
            self.yearsInBusiness = yearsInBusiness_
            # validate type yearsInBusinessType
            self.validate_yearsInBusinessType(self.yearsInBusiness)
# end class legalEntityCreateRequest


class address(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, streetAddress1=None, streetAddress2=None, city=None, stateProvince=None, postalCode=None, countryCode=None):
        self.original_tagname_ = None
        self.streetAddress1 = streetAddress1
        self.validate_streetAddress1Type(self.streetAddress1)
        self.streetAddress2 = streetAddress2
        self.validate_streetAddress2Type(self.streetAddress2)
        self.city = city
        self.validate_cityType(self.city)
        self.stateProvince = stateProvince
        self.validate_stateProvinceType(self.stateProvince)
        self.postalCode = postalCode
        self.validate_postalCodeType(self.postalCode)
        self.countryCode = countryCode
        self.validate_countryCodeType(self.countryCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if address.subclass:
            return address.subclass(*args_, **kwargs_)
        else:
            return address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress1(self): return self.streetAddress1
    def set_streetAddress1(self, streetAddress1): self.streetAddress1 = streetAddress1
    def get_streetAddress2(self): return self.streetAddress2
    def set_streetAddress2(self, streetAddress2): self.streetAddress2 = streetAddress2
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_stateProvince(self): return self.stateProvince
    def set_stateProvince(self, stateProvince): self.stateProvince = stateProvince
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_countryCode(self): return self.countryCode
    def set_countryCode(self, countryCode): self.countryCode = countryCode
    def validate_streetAddress1Type(self, value):
        # Validate type streetAddress1Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress1Type' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress1Type' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress2Type(self, value):
        # Validate type streetAddress2Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress2Type' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress2Type' % {"value" : value.encode("utf-8")} )
    def validate_cityType(self, value):
        # Validate type cityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cityType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cityType' % {"value" : value.encode("utf-8")} )
    def validate_stateProvinceType(self, value):
        # Validate type stateProvinceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on stateProvinceType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on stateProvinceType' % {"value" : value.encode("utf-8")} )
    def validate_postalCodeType(self, value):
        # Validate type postalCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 7:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on postalCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on postalCodeType' % {"value" : value.encode("utf-8")} )
    def validate_countryCodeType(self, value):
        # Validate type countryCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on countryCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on countryCodeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress1 is not None or
            self.streetAddress2 is not None or
            self.city is not None or
            self.stateProvince is not None or
            self.postalCode is not None or
            self.countryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='address', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('address')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='address')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='address', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='address'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='address', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress1>%s</tns:streetAddress1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress1), input_name='streetAddress1')), eol_))
        if self.streetAddress2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress2>%s</tns:streetAddress2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress2), input_name='streetAddress2')), eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:city>%s</tns:city>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), eol_))
        if self.stateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stateProvince>%s</tns:stateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.stateProvince), input_name='stateProvince')), eol_))
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:postalCode>%s</tns:postalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), eol_))
        if self.countryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:countryCode>%s</tns:countryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress1':
            streetAddress1_ = child_.text
            streetAddress1_ = self.gds_validate_string(streetAddress1_, node, 'streetAddress1')
            self.streetAddress1 = streetAddress1_
            # validate type streetAddress1Type
            self.validate_streetAddress1Type(self.streetAddress1)
        elif nodeName_ == 'streetAddress2':
            streetAddress2_ = child_.text
            streetAddress2_ = self.gds_validate_string(streetAddress2_, node, 'streetAddress2')
            self.streetAddress2 = streetAddress2_
            # validate type streetAddress2Type
            self.validate_streetAddress2Type(self.streetAddress2)
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type cityType
            self.validate_cityType(self.city)
        elif nodeName_ == 'stateProvince':
            stateProvince_ = child_.text
            stateProvince_ = self.gds_validate_string(stateProvince_, node, 'stateProvince')
            self.stateProvince = stateProvince_
            # validate type stateProvinceType
            self.validate_stateProvinceType(self.stateProvince)
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type postalCodeType
            self.validate_postalCodeType(self.postalCode)
        elif nodeName_ == 'countryCode':
            countryCode_ = child_.text
            countryCode_ = self.gds_validate_string(countryCode_, node, 'countryCode')
            self.countryCode = countryCode_
            # validate type countryCodeType
            self.validate_countryCodeType(self.countryCode)
# end class address


class legalEntityPrincipal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, principalId=None, title=None, firstName=None, lastName=None, emailAddress=None, ssn=None, contactPhone=None, dateOfBirth=None, driversLicense=None, driversLicenseState=None, address=None, stakePercent=None, principal=None):
        self.original_tagname_ = None
        self.principalId = principalId
        self.title = title
        self.validate_titleType(self.title)
        self.firstName = firstName
        self.validate_firstNameType(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType(self.lastName)
        self.emailAddress = emailAddress
        self.validate_emailAddressType(self.emailAddress)
        self.ssn = ssn
        self.validate_ssnType(self.ssn)
        self.contactPhone = contactPhone
        self.validate_contactPhoneType1(self.contactPhone)
        if isinstance(dateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = dateOfBirth
        self.dateOfBirth = initvalue_
        self.driversLicense = driversLicense
        self.validate_driversLicenseType(self.driversLicense)
        self.driversLicenseState = driversLicenseState
        self.validate_driversLicenseStateType(self.driversLicenseState)
        self.address = address
        self.stakePercent = stakePercent
        self.validate_stakePercentType(self.stakePercent)
        self.principal = principal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipal.subclass:
            return legalEntityPrincipal.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def get_ssn(self): return self.ssn
    def set_ssn(self, ssn): self.ssn = ssn
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_driversLicense(self): return self.driversLicense
    def set_driversLicense(self, driversLicense): self.driversLicense = driversLicense
    def get_driversLicenseState(self): return self.driversLicenseState
    def set_driversLicenseState(self, driversLicenseState): self.driversLicenseState = driversLicenseState
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_stakePercent(self): return self.stakePercent
    def set_stakePercent(self, stakePercent): self.stakePercent = stakePercent
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def validate_titleType(self, value):
        # Validate type titleType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on titleType' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on titleType' % {"value" : value.encode("utf-8")} )
    def validate_firstNameType(self, value):
        # Validate type firstNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType(self, value):
        # Validate type lastNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType' % {"value" : value.encode("utf-8")} )
    def validate_emailAddressType(self, value):
        # Validate type emailAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailAddressType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailAddressType' % {"value" : value.encode("utf-8")} )
    def validate_ssnType(self, value):
        # Validate type ssnType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ssnType' % {"value" : value.encode("utf-8")} )
            if len(value) < 9:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ssnType' % {"value" : value.encode("utf-8")} )
    def validate_contactPhoneType1(self, value):
        # Validate type contactPhoneType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on contactPhoneType1' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on contactPhoneType1' % {"value" : value.encode("utf-8")} )
    def validate_driversLicenseType(self, value):
        # Validate type driversLicenseType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on driversLicenseType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on driversLicenseType' % {"value" : value.encode("utf-8")} )
    def validate_driversLicenseStateType(self, value):
        # Validate type driversLicenseStateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on driversLicenseStateType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on driversLicenseStateType' % {"value" : value.encode("utf-8")} )
    def validate_stakePercentType(self, value):
        # Validate type stakePercentType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on stakePercentType' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on stakePercentType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.principalId is not None or
            self.title is not None or
            self.firstName is not None or
            self.lastName is not None or
            self.emailAddress is not None or
            self.ssn is not None or
            self.contactPhone is not None or
            self.dateOfBirth is not None or
            self.driversLicense is not None or
            self.driversLicenseState is not None or
            self.address is not None or
            self.stakePercent is not None or
            self.principal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipal', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipal'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:title>%s</tns:title>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
        if self.emailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:emailAddress>%s</tns:emailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.emailAddress), input_name='emailAddress')), eol_))
        if self.ssn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:ssn>%s</tns:ssn>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ssn), input_name='ssn')), eol_))
        if self.contactPhone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:contactPhone>%s</tns:contactPhone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.contactPhone), input_name='contactPhone')), eol_))
        if self.dateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:dateOfBirth>%s</tns:dateOfBirth>%s' % (self.gds_format_date(self.dateOfBirth, input_name='dateOfBirth'), eol_))
        if self.driversLicense is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:driversLicense>%s</tns:driversLicense>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.driversLicense), input_name='driversLicense')), eol_))
        if self.driversLicenseState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:driversLicenseState>%s</tns:driversLicenseState>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.driversLicenseState), input_name='driversLicenseState')), eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.stakePercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stakePercent>%s</tns:stakePercent>%s' % (self.gds_format_integer(self.stakePercent, input_name='stakePercent'), eol_))
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
            # validate type titleType
            self.validate_titleType(self.title)
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType
            self.validate_firstNameType(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType
            self.validate_lastNameType(self.lastName)
        elif nodeName_ == 'emailAddress':
            emailAddress_ = child_.text
            emailAddress_ = self.gds_validate_string(emailAddress_, node, 'emailAddress')
            self.emailAddress = emailAddress_
            # validate type emailAddressType
            self.validate_emailAddressType(self.emailAddress)
        elif nodeName_ == 'ssn':
            ssn_ = child_.text
            ssn_ = self.gds_validate_string(ssn_, node, 'ssn')
            self.ssn = ssn_
            # validate type ssnType
            self.validate_ssnType(self.ssn)
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
            # validate type contactPhoneType1
            self.validate_contactPhoneType1(self.contactPhone)
        elif nodeName_ == 'dateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateOfBirth = dval_
        elif nodeName_ == 'driversLicense':
            driversLicense_ = child_.text
            driversLicense_ = self.gds_validate_string(driversLicense_, node, 'driversLicense')
            self.driversLicense = driversLicense_
            # validate type driversLicenseType
            self.validate_driversLicenseType(self.driversLicense)
        elif nodeName_ == 'driversLicenseState':
            driversLicenseState_ = child_.text
            driversLicenseState_ = self.gds_validate_string(driversLicenseState_, node, 'driversLicenseState')
            self.driversLicenseState = driversLicenseState_
            # validate type driversLicenseStateType
            self.validate_driversLicenseStateType(self.driversLicenseState)
        elif nodeName_ == 'address':
            obj_ = principalAddress.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'stakePercent' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'stakePercent')
            self.stakePercent = ival_
            # validate type stakePercentType
            self.validate_stakePercentType(self.stakePercent)
        elif nodeName_ == 'principal':
            obj_ = principalResult.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
# end class legalEntityPrincipal


class principalAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, streetAddress1=None, streetAddress2=None, city=None, stateProvince=None, postalCode=None, countryCode=None):
        self.original_tagname_ = None
        self.streetAddress1 = streetAddress1
        self.validate_streetAddress1Type2(self.streetAddress1)
        self.streetAddress2 = streetAddress2
        self.validate_streetAddress2Type3(self.streetAddress2)
        self.city = city
        self.validate_cityType4(self.city)
        self.stateProvince = stateProvince
        self.validate_stateProvinceType5(self.stateProvince)
        self.postalCode = postalCode
        self.validate_postalCodeType6(self.postalCode)
        self.countryCode = countryCode
        self.validate_countryCodeType7(self.countryCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalAddress.subclass:
            return principalAddress.subclass(*args_, **kwargs_)
        else:
            return principalAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress1(self): return self.streetAddress1
    def set_streetAddress1(self, streetAddress1): self.streetAddress1 = streetAddress1
    def get_streetAddress2(self): return self.streetAddress2
    def set_streetAddress2(self, streetAddress2): self.streetAddress2 = streetAddress2
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_stateProvince(self): return self.stateProvince
    def set_stateProvince(self, stateProvince): self.stateProvince = stateProvince
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_countryCode(self): return self.countryCode
    def set_countryCode(self, countryCode): self.countryCode = countryCode
    def validate_streetAddress1Type2(self, value):
        # Validate type streetAddress1Type2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress1Type2' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress1Type2' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress2Type3(self, value):
        # Validate type streetAddress2Type3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress2Type3' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress2Type3' % {"value" : value.encode("utf-8")} )
    def validate_cityType4(self, value):
        # Validate type cityType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cityType4' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cityType4' % {"value" : value.encode("utf-8")} )
    def validate_stateProvinceType5(self, value):
        # Validate type stateProvinceType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on stateProvinceType5' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on stateProvinceType5' % {"value" : value.encode("utf-8")} )
    def validate_postalCodeType6(self, value):
        # Validate type postalCodeType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 7:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on postalCodeType6' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on postalCodeType6' % {"value" : value.encode("utf-8")} )
    def validate_countryCodeType7(self, value):
        # Validate type countryCodeType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on countryCodeType7' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on countryCodeType7' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress1 is not None or
            self.streetAddress2 is not None or
            self.city is not None or
            self.stateProvince is not None or
            self.postalCode is not None or
            self.countryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalAddress', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalAddress'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress1>%s</tns:streetAddress1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress1), input_name='streetAddress1')), eol_))
        if self.streetAddress2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress2>%s</tns:streetAddress2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress2), input_name='streetAddress2')), eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:city>%s</tns:city>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), eol_))
        if self.stateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stateProvince>%s</tns:stateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.stateProvince), input_name='stateProvince')), eol_))
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:postalCode>%s</tns:postalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), eol_))
        if self.countryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:countryCode>%s</tns:countryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress1':
            streetAddress1_ = child_.text
            streetAddress1_ = self.gds_validate_string(streetAddress1_, node, 'streetAddress1')
            self.streetAddress1 = streetAddress1_
            # validate type streetAddress1Type2
            self.validate_streetAddress1Type2(self.streetAddress1)
        elif nodeName_ == 'streetAddress2':
            streetAddress2_ = child_.text
            streetAddress2_ = self.gds_validate_string(streetAddress2_, node, 'streetAddress2')
            self.streetAddress2 = streetAddress2_
            # validate type streetAddress2Type3
            self.validate_streetAddress2Type3(self.streetAddress2)
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type cityType4
            self.validate_cityType4(self.city)
        elif nodeName_ == 'stateProvince':
            stateProvince_ = child_.text
            stateProvince_ = self.gds_validate_string(stateProvince_, node, 'stateProvince')
            self.stateProvince = stateProvince_
            # validate type stateProvinceType5
            self.validate_stateProvinceType5(self.stateProvince)
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type postalCodeType6
            self.validate_postalCodeType6(self.postalCode)
        elif nodeName_ == 'countryCode':
            countryCode_ = child_.text
            countryCode_ = self.gds_validate_string(countryCode_, node, 'countryCode')
            self.countryCode = countryCode_
            # validate type countryCodeType7
            self.validate_countryCodeType7(self.countryCode)
# end class principalAddress


class response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transactionId=None, extensiontype_=None):
        self.original_tagname_ = None
        self.transactionId = transactionId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if response.subclass:
            return response.subclass(*args_, **kwargs_)
        else:
            return response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.transactionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='response', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='response'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_format_integer(self.transactionId, input_name='transactionId'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transactionId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'transactionId')
            self.transactionId = ival_
# end class response


class legalEntityPrincipalCreateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, principal=None):
        self.original_tagname_ = None
        self.principal = principal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipalCreateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipalCreateRequest.subclass:
            return legalEntityPrincipalCreateRequest.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipalCreateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def hasContent_(self):
        if (
            self.principal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipalCreateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalCreateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principal':
            obj_ = legalEntityPrincipal.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
# end class legalEntityPrincipalCreateRequest


class legalEntityPrincipalCreateResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, principalId=None, firstName=None, lastName=None):
        self.original_tagname_ = None
        super(legalEntityPrincipalCreateResponse, self).__init__(transactionId, )
        self.principalId = principalId
        self.firstName = firstName
        self.validate_firstNameType8(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType9(self.lastName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipalCreateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipalCreateResponse.subclass:
            return legalEntityPrincipalCreateResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipalCreateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def validate_firstNameType8(self, value):
        # Validate type firstNameType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType8' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType8' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType9(self, value):
        # Validate type lastNameType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType9' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType9' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.principalId is not None or
            self.firstName is not None or
            self.lastName is not None or
            super(legalEntityPrincipalCreateResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipalCreateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalCreateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponse'):
        super(legalEntityPrincipalCreateResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalCreateResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityPrincipalCreateResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(legalEntityPrincipalCreateResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType8
            self.validate_firstNameType8(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType9
            self.validate_lastNameType9(self.lastName)
        super(legalEntityPrincipalCreateResponse, self).buildChildren(child_, node, nodeName_, True)
# end class legalEntityPrincipalCreateResponse


class legalEntityRetrievalResponse(legalEntityCreateRequest):
    subclass = None
    superclass = legalEntityCreateRequest
    def __init__(self, legalEntityName=None, legalEntityType=None, legalEntityOwnershipType=None, doingBusinessAs=None, taxId=None, contactPhone=None, annualCreditCardSalesVolume=None, hasAcceptedCreditCards=None, address=None, principal=None, yearsInBusiness=None, overallStatus=None, legalEntityPrincipal=None, legalEntityId=None, responseCode=None, responseDescription=None, backgroundCheckResults=None, transactionId=None, updateDate=None, decisionDate=None, tinValidationStatus=None, sub_merchant_processing_status=None):
        self.original_tagname_ = None
        super(legalEntityRetrievalResponse, self).__init__(legalEntityName, legalEntityType, legalEntityOwnershipType, doingBusinessAs, taxId, contactPhone, annualCreditCardSalesVolume, hasAcceptedCreditCards, address, principal, yearsInBusiness, )
        self.overallStatus = _cast(None, overallStatus)
        self.legalEntityPrincipal = legalEntityPrincipal
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType10(self.legalEntityId)
        self.responseCode = responseCode
        self.responseDescription = responseDescription
        self.validate_responseDescriptionType11(self.responseDescription)
        self.backgroundCheckResults = backgroundCheckResults
        self.transactionId = transactionId
        self.validate_transactionIdType(self.transactionId)
        if isinstance(updateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updateDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updateDate
        self.updateDate = initvalue_
        if isinstance(decisionDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(decisionDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = decisionDate
        self.decisionDate = initvalue_
        self.tinValidationStatus = tinValidationStatus
        self.validate_tinValidationStatusType(self.tinValidationStatus)
        self.sub_merchant_processing_status = sub_merchant_processing_status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityRetrievalResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityRetrievalResponse.subclass:
            return legalEntityRetrievalResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityRetrievalResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityPrincipal(self): return self.legalEntityPrincipal
    def set_legalEntityPrincipal(self, legalEntityPrincipal): self.legalEntityPrincipal = legalEntityPrincipal
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_responseCode(self): return self.responseCode
    def set_responseCode(self, responseCode): self.responseCode = responseCode
    def get_responseDescription(self): return self.responseDescription
    def set_responseDescription(self, responseDescription): self.responseDescription = responseDescription
    def get_backgroundCheckResults(self): return self.backgroundCheckResults
    def set_backgroundCheckResults(self, backgroundCheckResults): self.backgroundCheckResults = backgroundCheckResults
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_updateDate(self): return self.updateDate
    def set_updateDate(self, updateDate): self.updateDate = updateDate
    def get_decisionDate(self): return self.decisionDate
    def set_decisionDate(self, decisionDate): self.decisionDate = decisionDate
    def get_tinValidationStatus(self): return self.tinValidationStatus
    def set_tinValidationStatus(self, tinValidationStatus): self.tinValidationStatus = tinValidationStatus
    def get_sub_merchant_processing_status(self): return self.sub_merchant_processing_status
    def set_sub_merchant_processing_status(self, sub_merchant_processing_status): self.sub_merchant_processing_status = sub_merchant_processing_status
    def get_overallStatus(self): return self.overallStatus
    def set_overallStatus(self, overallStatus): self.overallStatus = overallStatus
    def validate_legalEntityIdType10(self, value):
        # Validate type legalEntityIdType10, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType10' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType10' % {"value" : value.encode("utf-8")} )
    def validate_responseDescriptionType11(self, value):
        # Validate type responseDescriptionType11, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on responseDescriptionType11' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on responseDescriptionType11' % {"value" : value.encode("utf-8")} )
    def validate_transactionIdType(self, value):
        # Validate type transactionIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on transactionIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on transactionIdType' % {"value" : value.encode("utf-8")} )
    def validate_tinValidationStatusType(self, value):
        # Validate type tinValidationStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tinValidationStatusType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tinValidationStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityPrincipal is not None or
            self.legalEntityId is not None or
            self.responseCode is not None or
            self.responseDescription is not None or
            self.backgroundCheckResults is not None or
            self.transactionId is not None or
            self.updateDate is not None or
            self.decisionDate is not None or
            self.tinValidationStatus is not None or
            self.sub_merchant_processing_status is not None or
            super(legalEntityRetrievalResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityRetrievalResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityRetrievalResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityRetrievalResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityRetrievalResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityRetrievalResponse'):
        super(legalEntityRetrievalResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityRetrievalResponse')
        if self.overallStatus is not None and 'overallStatus' not in already_processed:
            already_processed.add('overallStatus')
            outfile.write(' overallStatus=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.overallStatus), input_name='overallStatus')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityRetrievalResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityRetrievalResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityPrincipal is not None:
            self.legalEntityPrincipal.export(outfile, level, namespaceprefix_, name_='legalEntityPrincipal', pretty_print=pretty_print)
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.responseCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseCode>%s</tns:responseCode>%s' % (self.gds_format_integer(self.responseCode, input_name='responseCode'), eol_))
        if self.responseDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseDescription>%s</tns:responseDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.responseDescription), input_name='responseDescription')), eol_))
        if self.backgroundCheckResults is not None:
            self.backgroundCheckResults.export(outfile, level, namespaceprefix_='tns:', name_='backgroundCheckResults', pretty_print=pretty_print)
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), eol_))
        if self.updateDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:updateDate>%s</tns:updateDate>%s' % (self.gds_format_datetime(self.updateDate, input_name='updateDate'), eol_))
        if self.decisionDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:decisionDate>%s</tns:decisionDate>%s' % (self.gds_format_datetime(self.decisionDate, input_name='decisionDate'), eol_))
        if self.tinValidationStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:tinValidationStatus>%s</tns:tinValidationStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tinValidationStatus), input_name='tinValidationStatus')), eol_))
        if self.sub_merchant_processing_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:sub_merchant_processing_status>%s</tns:sub_merchant_processing_status>%s' % (self.gds_format_boolean(self.sub_merchant_processing_status, input_name='sub_merchant_processing_status'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('overallStatus', node)
        if value is not None and 'overallStatus' not in already_processed:
            already_processed.add('overallStatus')
            self.overallStatus = value
        super(legalEntityRetrievalResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityPrincipal':
            obj_ = legalEntityPrincipal.factory()
            obj_.build(child_)
            self.legalEntityPrincipal = obj_
            obj_.original_tagname_ = 'legalEntityPrincipal'
        elif nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType10
            self.validate_legalEntityIdType10(self.legalEntityId)
        elif nodeName_ == 'responseCode' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'responseCode')
            self.responseCode = ival_
        elif nodeName_ == 'responseDescription':
            responseDescription_ = child_.text
            responseDescription_ = self.gds_validate_string(responseDescription_, node, 'responseDescription')
            self.responseDescription = responseDescription_
            # validate type responseDescriptionType11
            self.validate_responseDescriptionType11(self.responseDescription)
        elif nodeName_ == 'backgroundCheckResults':
            obj_ = backgroundCheckResults.factory()
            obj_.build(child_)
            self.backgroundCheckResults = obj_
            obj_.original_tagname_ = 'backgroundCheckResults'
        elif nodeName_ == 'transactionId':
            transactionId_ = child_.text
            transactionId_ = self.gds_validate_string(transactionId_, node, 'transactionId')
            self.transactionId = transactionId_
            # validate type transactionIdType
            self.validate_transactionIdType(self.transactionId)
        elif nodeName_ == 'updateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updateDate = dval_
        elif nodeName_ == 'decisionDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.decisionDate = dval_
        elif nodeName_ == 'tinValidationStatus':
            tinValidationStatus_ = child_.text
            tinValidationStatus_ = self.gds_validate_string(tinValidationStatus_, node, 'tinValidationStatus')
            self.tinValidationStatus = tinValidationStatus_
            # validate type tinValidationStatusType
            self.validate_tinValidationStatusType(self.tinValidationStatus)
        elif nodeName_ == 'sub_merchant_processing_status':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sub_merchant_processing_status')
            self.sub_merchant_processing_status = ival_
        super(legalEntityRetrievalResponse, self).buildChildren(child_, node, nodeName_, True)
# end class legalEntityRetrievalResponse


class backgroundCheckResults(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, business=None, principal=None, businessToPrincipalAssociation=None, backgroundCheckDecisionNotes=None, bankruptcyData=None, lienResult=None):
        self.original_tagname_ = None
        self.business = business
        self.principal = principal
        self.businessToPrincipalAssociation = businessToPrincipalAssociation
        self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes
        self.validate_backgroundCheckDecisionNotesType(self.backgroundCheckDecisionNotes)
        self.bankruptcyData = bankruptcyData
        self.lienResult = lienResult
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, backgroundCheckResults)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if backgroundCheckResults.subclass:
            return backgroundCheckResults.subclass(*args_, **kwargs_)
        else:
            return backgroundCheckResults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_business(self): return self.business
    def set_business(self, business): self.business = business
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_businessToPrincipalAssociation(self): return self.businessToPrincipalAssociation
    def set_businessToPrincipalAssociation(self, businessToPrincipalAssociation): self.businessToPrincipalAssociation = businessToPrincipalAssociation
    def get_backgroundCheckDecisionNotes(self): return self.backgroundCheckDecisionNotes
    def set_backgroundCheckDecisionNotes(self, backgroundCheckDecisionNotes): self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes
    def get_bankruptcyData(self): return self.bankruptcyData
    def set_bankruptcyData(self, bankruptcyData): self.bankruptcyData = bankruptcyData
    def get_lienResult(self): return self.lienResult
    def set_lienResult(self, lienResult): self.lienResult = lienResult
    def validate_backgroundCheckDecisionNotesType(self, value):
        # Validate type backgroundCheckDecisionNotesType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on backgroundCheckDecisionNotesType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on backgroundCheckDecisionNotesType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.business is not None or
            self.principal is not None or
            self.businessToPrincipalAssociation is not None or
            self.backgroundCheckDecisionNotes is not None or
            self.bankruptcyData is not None or
            self.lienResult is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='backgroundCheckResults', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('backgroundCheckResults')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='backgroundCheckResults')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='backgroundCheckResults', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='backgroundCheckResults'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='backgroundCheckResults', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.business is not None:
            self.business.export(outfile, level, namespaceprefix_, name_='business', pretty_print=pretty_print)
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
        if self.businessToPrincipalAssociation is not None:
            self.businessToPrincipalAssociation.export(outfile, level, namespaceprefix_, name_='businessToPrincipalAssociation', pretty_print=pretty_print)
        if self.backgroundCheckDecisionNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:backgroundCheckDecisionNotes>%s</tns:backgroundCheckDecisionNotes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.backgroundCheckDecisionNotes), input_name='backgroundCheckDecisionNotes')), eol_))
        if self.bankruptcyData is not None:
            self.bankruptcyData.export(outfile, level, namespaceprefix_, name_='bankruptcyData', pretty_print=pretty_print)
        if self.lienResult is not None:
            self.lienResult.export(outfile, level, namespaceprefix_, name_='lienResult', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'business':
            obj_ = businessResult.factory()
            obj_.build(child_)
            self.business = obj_
            obj_.original_tagname_ = 'business'
        elif nodeName_ == 'principal':
            obj_ = principalResult.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        elif nodeName_ == 'businessToPrincipalAssociation':
            obj_ = businessToPrincipalAssociation.factory()
            obj_.build(child_)
            self.businessToPrincipalAssociation = obj_
            obj_.original_tagname_ = 'businessToPrincipalAssociation'
        elif nodeName_ == 'backgroundCheckDecisionNotes':
            backgroundCheckDecisionNotes_ = child_.text
            backgroundCheckDecisionNotes_ = self.gds_validate_string(backgroundCheckDecisionNotes_, node, 'backgroundCheckDecisionNotes')
            self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes_
            # validate type backgroundCheckDecisionNotesType
            self.validate_backgroundCheckDecisionNotesType(self.backgroundCheckDecisionNotes)
        elif nodeName_ == 'bankruptcyData':
            obj_ = bankruptcyResult.factory()
            obj_.build(child_)
            self.bankruptcyData = obj_
            obj_.original_tagname_ = 'bankruptcyData'
        elif nodeName_ == 'lienResult':
            obj_ = lienResult.factory()
            obj_.build(child_)
            self.lienResult = obj_
            obj_.original_tagname_ = 'lienResult'
# end class backgroundCheckResults


class businessResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, verificationResult=None):
        self.original_tagname_ = None
        self.verificationResult = verificationResult
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessResult.subclass:
            return businessResult.subclass(*args_, **kwargs_)
        else:
            return businessResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verificationResult(self): return self.verificationResult
    def set_verificationResult(self, verificationResult): self.verificationResult = verificationResult
    def hasContent_(self):
        if (
            self.verificationResult is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.verificationResult is not None:
            self.verificationResult.export(outfile, level, namespaceprefix_, name_='verificationResult', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'verificationResult':
            obj_ = businessVerificationResult.factory()
            obj_.build(child_)
            self.verificationResult = obj_
            obj_.original_tagname_ = 'verificationResult'
# end class businessResult


class businessVerificationResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, overallScore=None, nameAddressTaxIdAssociation=None, nameAddressPhoneAssociation=None, verificationIndicators=None, riskIndicators=None):
        self.original_tagname_ = None
        self.overallScore = overallScore
        self.nameAddressTaxIdAssociation = nameAddressTaxIdAssociation
        self.nameAddressPhoneAssociation = nameAddressPhoneAssociation
        self.verificationIndicators = verificationIndicators
        self.riskIndicators = riskIndicators
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessVerificationResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessVerificationResult.subclass:
            return businessVerificationResult.subclass(*args_, **kwargs_)
        else:
            return businessVerificationResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_overallScore(self): return self.overallScore
    def set_overallScore(self, overallScore): self.overallScore = overallScore
    def get_nameAddressTaxIdAssociation(self): return self.nameAddressTaxIdAssociation
    def set_nameAddressTaxIdAssociation(self, nameAddressTaxIdAssociation): self.nameAddressTaxIdAssociation = nameAddressTaxIdAssociation
    def get_nameAddressPhoneAssociation(self): return self.nameAddressPhoneAssociation
    def set_nameAddressPhoneAssociation(self, nameAddressPhoneAssociation): self.nameAddressPhoneAssociation = nameAddressPhoneAssociation
    def get_verificationIndicators(self): return self.verificationIndicators
    def set_verificationIndicators(self, verificationIndicators): self.verificationIndicators = verificationIndicators
    def get_riskIndicators(self): return self.riskIndicators
    def set_riskIndicators(self, riskIndicators): self.riskIndicators = riskIndicators
    def hasContent_(self):
        if (
            self.overallScore is not None or
            self.nameAddressTaxIdAssociation is not None or
            self.nameAddressPhoneAssociation is not None or
            self.verificationIndicators is not None or
            self.riskIndicators is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessVerificationResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessVerificationResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessVerificationResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessVerificationResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessVerificationResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessVerificationResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.overallScore is not None:
            self.overallScore.export(outfile, level, namespaceprefix_, name_='overallScore', pretty_print=pretty_print)
        if self.nameAddressTaxIdAssociation is not None:
            self.nameAddressTaxIdAssociation.export(outfile, level, namespaceprefix_, name_='nameAddressTaxIdAssociation', pretty_print=pretty_print)
        if self.nameAddressPhoneAssociation is not None:
            self.nameAddressPhoneAssociation.export(outfile, level, namespaceprefix_, name_='nameAddressPhoneAssociation', pretty_print=pretty_print)
        if self.verificationIndicators is not None:
            self.verificationIndicators.export(outfile, level, namespaceprefix_, name_='verificationIndicators', pretty_print=pretty_print)
        if self.riskIndicators is not None:
            self.riskIndicators.export(outfile, level, namespaceprefix_, name_='riskIndicators', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'overallScore':
            obj_ = businessScore.factory()
            obj_.build(child_)
            self.overallScore = obj_
            obj_.original_tagname_ = 'overallScore'
        elif nodeName_ == 'nameAddressTaxIdAssociation':
            obj_ = nameAddressTaxIdAssociation.factory()
            obj_.build(child_)
            self.nameAddressTaxIdAssociation = obj_
            obj_.original_tagname_ = 'nameAddressTaxIdAssociation'
        elif nodeName_ == 'nameAddressPhoneAssociation':
            obj_ = businessNameAddressPhoneAssociation.factory()
            obj_.build(child_)
            self.nameAddressPhoneAssociation = obj_
            obj_.original_tagname_ = 'nameAddressPhoneAssociation'
        elif nodeName_ == 'verificationIndicators':
            obj_ = businessVerificationIndicators.factory()
            obj_.build(child_)
            self.verificationIndicators = obj_
            obj_.original_tagname_ = 'verificationIndicators'
        elif nodeName_ == 'riskIndicators':
            obj_ = riskIndicatorsType.factory()
            obj_.build(child_)
            self.riskIndicators = obj_
            obj_.original_tagname_ = 'riskIndicators'
# end class businessVerificationResult


class businessScore(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, score=None, description=None):
        self.original_tagname_ = None
        self.score = score
        self.validate_businessOverallScore(self.score)
        self.description = description
        self.validate_descriptionType(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessScore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessScore.subclass:
            return businessScore.subclass(*args_, **kwargs_)
        else:
            return businessScore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_businessOverallScore(self, value):
        # Validate type businessOverallScore, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '10', '20', '30', '40', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on businessOverallScore' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType(self, value):
        # Validate type descriptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 110:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessScore', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessScore')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessScore')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessScore', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessScore'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessScore', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:score>%s</tns:score>%s' % (self.gds_format_integer(self.score, input_name='score'), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'score')
            self.score = ival_
            # validate type businessOverallScore
            self.validate_businessOverallScore(self.score)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType
            self.validate_descriptionType(self.description)
# end class businessScore


class nameAddressTaxIdAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = code
        self.validate_nameAddressTaxIdAssociationCode(self.code)
        self.description = description
        self.validate_descriptionType12(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameAddressTaxIdAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameAddressTaxIdAssociation.subclass:
            return nameAddressTaxIdAssociation.subclass(*args_, **kwargs_)
        else:
            return nameAddressTaxIdAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_nameAddressTaxIdAssociationCode(self, value):
        # Validate type nameAddressTaxIdAssociationCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOT_VERIFIED', 'WRONG_TAX_ID', 'NAME_OR_ADDRESS', 'BAD_NAME', 'BAD_ADDRESS', 'MISSING_ADDRESS', 'NAME_AND_ADDRESS_BAD_TAX_ID', 'NAME_AND_ADDRESS_NO_TAX_ID', 'NAME_ADDRESS_TAX_ID']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on nameAddressTaxIdAssociationCode' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType12(self, value):
        # Validate type descriptionType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType12' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType12' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='nameAddressTaxIdAssociation', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameAddressTaxIdAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nameAddressTaxIdAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='nameAddressTaxIdAssociation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='nameAddressTaxIdAssociation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='nameAddressTaxIdAssociation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:code>%s</tns:code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
            # validate type nameAddressTaxIdAssociationCode
            self.validate_nameAddressTaxIdAssociationCode(self.code)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType12
            self.validate_descriptionType12(self.description)
# end class nameAddressTaxIdAssociation


class businessNameAddressPhoneAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = code
        self.validate_businessNameAddressPhoneAssociationCode(self.code)
        self.description = description
        self.validate_descriptionType13(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessNameAddressPhoneAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessNameAddressPhoneAssociation.subclass:
            return businessNameAddressPhoneAssociation.subclass(*args_, **kwargs_)
        else:
            return businessNameAddressPhoneAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_businessNameAddressPhoneAssociationCode(self, value):
        # Validate type businessNameAddressPhoneAssociationCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOT_VERIFIED', 'WRONG_PHONE', 'NAME_OR_ADDRESS', 'BAD_NAME', 'BAD_ADDRESS', 'MISSING_ADDRESS', 'NAME_AND_ADDRESS_BAD_PHONE', 'NAME_AND_ADDRESS_NO_PHONE', 'NAME_ADDRESS_PHONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on businessNameAddressPhoneAssociationCode' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType13(self, value):
        # Validate type descriptionType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType13' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType13' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessNameAddressPhoneAssociation', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessNameAddressPhoneAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessNameAddressPhoneAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessNameAddressPhoneAssociation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessNameAddressPhoneAssociation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessNameAddressPhoneAssociation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:code>%s</tns:code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
            # validate type businessNameAddressPhoneAssociationCode
            self.validate_businessNameAddressPhoneAssociationCode(self.code)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType13
            self.validate_descriptionType13(self.description)
# end class businessNameAddressPhoneAssociation


class businessVerificationIndicators(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nameVerified=None, addressVerified=None, cityVerified=None, stateVerified=None, zipVerified=None, phoneVerified=None, taxIdVerified=None):
        self.original_tagname_ = None
        self.nameVerified = nameVerified
        self.addressVerified = addressVerified
        self.cityVerified = cityVerified
        self.stateVerified = stateVerified
        self.zipVerified = zipVerified
        self.phoneVerified = phoneVerified
        self.taxIdVerified = taxIdVerified
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessVerificationIndicators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessVerificationIndicators.subclass:
            return businessVerificationIndicators.subclass(*args_, **kwargs_)
        else:
            return businessVerificationIndicators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nameVerified(self): return self.nameVerified
    def set_nameVerified(self, nameVerified): self.nameVerified = nameVerified
    def get_addressVerified(self): return self.addressVerified
    def set_addressVerified(self, addressVerified): self.addressVerified = addressVerified
    def get_cityVerified(self): return self.cityVerified
    def set_cityVerified(self, cityVerified): self.cityVerified = cityVerified
    def get_stateVerified(self): return self.stateVerified
    def set_stateVerified(self, stateVerified): self.stateVerified = stateVerified
    def get_zipVerified(self): return self.zipVerified
    def set_zipVerified(self, zipVerified): self.zipVerified = zipVerified
    def get_phoneVerified(self): return self.phoneVerified
    def set_phoneVerified(self, phoneVerified): self.phoneVerified = phoneVerified
    def get_taxIdVerified(self): return self.taxIdVerified
    def set_taxIdVerified(self, taxIdVerified): self.taxIdVerified = taxIdVerified
    def hasContent_(self):
        if (
            self.nameVerified is not None or
            self.addressVerified is not None or
            self.cityVerified is not None or
            self.stateVerified is not None or
            self.zipVerified is not None or
            self.phoneVerified is not None or
            self.taxIdVerified is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessVerificationIndicators', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessVerificationIndicators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessVerificationIndicators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessVerificationIndicators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessVerificationIndicators'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessVerificationIndicators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nameVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:nameVerified>%s</tns:nameVerified>%s' % (self.gds_format_boolean(self.nameVerified, input_name='nameVerified'), eol_))
        if self.addressVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:addressVerified>%s</tns:addressVerified>%s' % (self.gds_format_boolean(self.addressVerified, input_name='addressVerified'), eol_))
        if self.cityVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:cityVerified>%s</tns:cityVerified>%s' % (self.gds_format_boolean(self.cityVerified, input_name='cityVerified'), eol_))
        if self.stateVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stateVerified>%s</tns:stateVerified>%s' % (self.gds_format_boolean(self.stateVerified, input_name='stateVerified'), eol_))
        if self.zipVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:zipVerified>%s</tns:zipVerified>%s' % (self.gds_format_boolean(self.zipVerified, input_name='zipVerified'), eol_))
        if self.phoneVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:phoneVerified>%s</tns:phoneVerified>%s' % (self.gds_format_boolean(self.phoneVerified, input_name='phoneVerified'), eol_))
        if self.taxIdVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxIdVerified>%s</tns:taxIdVerified>%s' % (self.gds_format_boolean(self.taxIdVerified, input_name='taxIdVerified'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nameVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nameVerified')
            self.nameVerified = ival_
        elif nodeName_ == 'addressVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'addressVerified')
            self.addressVerified = ival_
        elif nodeName_ == 'cityVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'cityVerified')
            self.cityVerified = ival_
        elif nodeName_ == 'stateVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'stateVerified')
            self.stateVerified = ival_
        elif nodeName_ == 'zipVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'zipVerified')
            self.zipVerified = ival_
        elif nodeName_ == 'phoneVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'phoneVerified')
            self.phoneVerified = ival_
        elif nodeName_ == 'taxIdVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'taxIdVerified')
            self.taxIdVerified = ival_
# end class businessVerificationIndicators


class potentialRiskIndicator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = code
        self.validate_riskIndicatorCode(self.code)
        self.description = description
        self.validate_descriptionType14(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, potentialRiskIndicator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if potentialRiskIndicator.subclass:
            return potentialRiskIndicator.subclass(*args_, **kwargs_)
        else:
            return potentialRiskIndicator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_riskIndicatorCode(self, value):
        # Validate type riskIndicatorCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNKNOWN', 'SSN_DECEASED', 'SSN_PRIOR_TO_DOB', 'SSN_ADDRESS_PHONE_NOT_MATCH', 'SSN_INVALID', 'PHONE_NUMBER_DISCONNECTED', 'PHONE_NUMBER_INVALID', 'PHONE_NUMBER_PAGER', 'PHONE_NUMBER_MOBILE', 'ADDRESS_INVALID', 'ZIP_BELONGS_POST_OFFICE', 'ADDRESS_INVALID_APARTMENT_DESIGNATION', 'ADDRESS_COMMERCIAL', 'PHONE_NUMBER_COMMERCIAL', 'PHONE_NUMBER_ZIP_INVALID', 'UNABLE_TO_VERIFY_NAS', 'UNABLE_TO_VERIFY_ADDRESS', 'UNABLE_TO_VERIFY_SSN', 'UNABLE_TO_VERIFY_PHONE', 'UNABLE_TO_VERIFY_DOB', 'SSN_MISKEYED', 'ADDRESS_MISKEYED', 'PHONE_NUMBER_MISKEYED', 'NAME_MATCHES_OFAC', 'UNABLE_TO_VERIFY_NAME', 'SSN_MATCHES_MULTI_NAMES', 'SSN_RECENTLY_ISSUED', 'ZIP_CORPORATE_MILITARY', 'DLL_INVALID', 'NAME_ADDRESS_MATCH_BANKRUPTCY', 'PHONE_AREA_CODE_CHANGING', 'WORK_PHONE_PAGER', 'UNABLE_TO_VERIFY_FIRST_NAME', 'PHONE_ADDRESS_DISTANT', 'ADDRESS_MATCHES_PRISON', 'SSN_LAST_NAME_NO_MATCH', 'SSN_FIRST_NAME_NO_MATCH', 'WORK_HOME_PHONE_DISTANT', 'NAME_ADDRESS_TIN_MISMATCH', 'WORK_PHONE_INVALID', 'WORK_PHONE_DISCONNECTED', 'WORK_PHONE_MOBILE', 'ADDRESS_RETURNS_DIFF_PHONE', 'SSN_LNAME_NOT_MATCHED_FNAME_MATCHED', 'PHONE_RESIDENTIAL_LISTING', 'SINGLE_FAMILY_DWELLING', 'SSN_NOT_FOUND', 'SSN_BELONGS_TO_DIFF_NAME_ADDRESS', 'PHONE_BELONGS_TO_DIFF_NAME_ADDRESS', 'NAME_ADDRESS_UNLISTED', 'NAME_MISKEYED', 'NAME_MISSING', 'ADDRESS_MISSING', 'SSN_MISSING', 'PHONE_NUMBER_MISSING', 'DOB_MISSING', 'NAME_ADDRESS_RETURN_DIFF_PHONE', 'DOB_MISKEYED', 'SSN_NON_US_CITIZEN', 'ALTERNATE_BUSINESS_NAME_FOUND', 'DBA_MATCH_PUBLIC_RECORDS', 'SSN_RECENT', 'SSN_TOO_OLD', 'TIN_NAME_ADDRESS_MISMATCH', 'BUSINESS_NOT_IN_GOOD_STANDING', 'NAME_ADDRESS_MATCH_JUDGMENT', 'BUSINESS_INACTIVE', 'NO_UPDATE_IN_LAST_THREE_YEARS', 'SSN_NOT_PRIMARY', 'ZIP_CORP_ONLY', 'ADDRESS_MISMATCH', 'DL_DIFFERENT', 'DL_NOT_FOUND', 'DL_MISKEYED', 'UNABLE_TO_VERIFY_DL', 'SSN_INVALID_SSA', 'SSN_IS_ITIN', 'SSN_MULTI_IDENTITY', 'ZIP_MILITARY', 'MULTIPLE_SSN_FOUND', 'ADDRESS_DISCREPANCY', 'ADDRESS_PO_BOX', 'SSN_RANDOM_SSA', 'ADDRESS_MISMATCH_SECONDARY', 'NAME_MATCHES_NON_OFAC', 'UNABLE_TO_VERIFY_ZIP_CODE', 'IP_ADDRESS_UNKNOWN', 'IP_ADDRESS_DIFFERENT_STATE', 'IP_ADDRESS_DIFFERENT_ZIP', 'IP_ADDRESS_DIFFERENT_PHONE', 'IP_ADDRESS_DOMAIN_UNKNOWN', 'IP_ADDRESS_NOT_ASSIGNED_TO_USA', 'IP_ADDRESS_NON_ROUTABLE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on riskIndicatorCode' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType14(self, value):
        # Validate type descriptionType14, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType14' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType14' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='potentialRiskIndicator', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('potentialRiskIndicator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='potentialRiskIndicator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='potentialRiskIndicator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='potentialRiskIndicator'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='potentialRiskIndicator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:code>%s</tns:code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
            # validate type riskIndicatorCode
            self.validate_riskIndicatorCode(self.code)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType14
            self.validate_descriptionType14(self.description)
# end class potentialRiskIndicator


class principalResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, verificationResult=None, backgroundCheckDecisionNotes=None):
        self.original_tagname_ = None
        self.verificationResult = verificationResult
        self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes
        self.validate_backgroundCheckDecisionNotesType15(self.backgroundCheckDecisionNotes)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalResult.subclass:
            return principalResult.subclass(*args_, **kwargs_)
        else:
            return principalResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_verificationResult(self): return self.verificationResult
    def set_verificationResult(self, verificationResult): self.verificationResult = verificationResult
    def get_backgroundCheckDecisionNotes(self): return self.backgroundCheckDecisionNotes
    def set_backgroundCheckDecisionNotes(self, backgroundCheckDecisionNotes): self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes
    def validate_backgroundCheckDecisionNotesType15(self, value):
        # Validate type backgroundCheckDecisionNotesType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on backgroundCheckDecisionNotesType15' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on backgroundCheckDecisionNotesType15' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.verificationResult is not None or
            self.backgroundCheckDecisionNotes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.verificationResult is not None:
            self.verificationResult.export(outfile, level, namespaceprefix_, name_='verificationResult', pretty_print=pretty_print)
        if self.backgroundCheckDecisionNotes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:backgroundCheckDecisionNotes>%s</tns:backgroundCheckDecisionNotes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.backgroundCheckDecisionNotes), input_name='backgroundCheckDecisionNotes')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'verificationResult':
            obj_ = principalVerificationResult.factory()
            obj_.build(child_)
            self.verificationResult = obj_
            obj_.original_tagname_ = 'verificationResult'
        elif nodeName_ == 'backgroundCheckDecisionNotes':
            backgroundCheckDecisionNotes_ = child_.text
            backgroundCheckDecisionNotes_ = self.gds_validate_string(backgroundCheckDecisionNotes_, node, 'backgroundCheckDecisionNotes')
            self.backgroundCheckDecisionNotes = backgroundCheckDecisionNotes_
            # validate type backgroundCheckDecisionNotesType15
            self.validate_backgroundCheckDecisionNotesType15(self.backgroundCheckDecisionNotes)
# end class principalResult


class principalVerificationResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, overallScore=None, nameAddressSsnAssociation=None, nameAddressPhoneAssociation=None, verificationIndicators=None, riskIndicators=None):
        self.original_tagname_ = None
        self.overallScore = overallScore
        self.nameAddressSsnAssociation = nameAddressSsnAssociation
        self.nameAddressPhoneAssociation = nameAddressPhoneAssociation
        self.verificationIndicators = verificationIndicators
        self.riskIndicators = riskIndicators
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalVerificationResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalVerificationResult.subclass:
            return principalVerificationResult.subclass(*args_, **kwargs_)
        else:
            return principalVerificationResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_overallScore(self): return self.overallScore
    def set_overallScore(self, overallScore): self.overallScore = overallScore
    def get_nameAddressSsnAssociation(self): return self.nameAddressSsnAssociation
    def set_nameAddressSsnAssociation(self, nameAddressSsnAssociation): self.nameAddressSsnAssociation = nameAddressSsnAssociation
    def get_nameAddressPhoneAssociation(self): return self.nameAddressPhoneAssociation
    def set_nameAddressPhoneAssociation(self, nameAddressPhoneAssociation): self.nameAddressPhoneAssociation = nameAddressPhoneAssociation
    def get_verificationIndicators(self): return self.verificationIndicators
    def set_verificationIndicators(self, verificationIndicators): self.verificationIndicators = verificationIndicators
    def get_riskIndicators(self): return self.riskIndicators
    def set_riskIndicators(self, riskIndicators): self.riskIndicators = riskIndicators
    def hasContent_(self):
        if (
            self.overallScore is not None or
            self.nameAddressSsnAssociation is not None or
            self.nameAddressPhoneAssociation is not None or
            self.verificationIndicators is not None or
            self.riskIndicators is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalVerificationResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalVerificationResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalVerificationResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalVerificationResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalVerificationResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalVerificationResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.overallScore is not None:
            self.overallScore.export(outfile, level, namespaceprefix_, name_='overallScore', pretty_print=pretty_print)
        if self.nameAddressSsnAssociation is not None:
            self.nameAddressSsnAssociation.export(outfile, level, namespaceprefix_, name_='nameAddressSsnAssociation', pretty_print=pretty_print)
        if self.nameAddressPhoneAssociation is not None:
            self.nameAddressPhoneAssociation.export(outfile, level, namespaceprefix_, name_='nameAddressPhoneAssociation', pretty_print=pretty_print)
        if self.verificationIndicators is not None:
            self.verificationIndicators.export(outfile, level, namespaceprefix_, name_='verificationIndicators', pretty_print=pretty_print)
        if self.riskIndicators is not None:
            self.riskIndicators.export(outfile, level, namespaceprefix_, name_='riskIndicators', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'overallScore':
            obj_ = principalScore.factory()
            obj_.build(child_)
            self.overallScore = obj_
            obj_.original_tagname_ = 'overallScore'
        elif nodeName_ == 'nameAddressSsnAssociation':
            obj_ = nameAddressSsnAssociation.factory()
            obj_.build(child_)
            self.nameAddressSsnAssociation = obj_
            obj_.original_tagname_ = 'nameAddressSsnAssociation'
        elif nodeName_ == 'nameAddressPhoneAssociation':
            obj_ = principalNameAddressPhoneAssociation.factory()
            obj_.build(child_)
            self.nameAddressPhoneAssociation = obj_
            obj_.original_tagname_ = 'nameAddressPhoneAssociation'
        elif nodeName_ == 'verificationIndicators':
            obj_ = principalVerificationIndicators.factory()
            obj_.build(child_)
            self.verificationIndicators = obj_
            obj_.original_tagname_ = 'verificationIndicators'
        elif nodeName_ == 'riskIndicators':
            obj_ = riskIndicatorsType16.factory()
            obj_.build(child_)
            self.riskIndicators = obj_
            obj_.original_tagname_ = 'riskIndicators'
# end class principalVerificationResult


class principalScore(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, score=None, description=None):
        self.original_tagname_ = None
        self.score = score
        self.validate_principalOverallScore(self.score)
        self.description = description
        self.validate_descriptionType17(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalScore)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalScore.subclass:
            return principalScore.subclass(*args_, **kwargs_)
        else:
            return principalScore(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_principalOverallScore(self, value):
        # Validate type principalOverallScore, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '10', '20', '30', '40', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on principalOverallScore' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType17(self, value):
        # Validate type descriptionType17, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType17' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType17' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalScore', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalScore')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalScore')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalScore', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalScore'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalScore', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:score>%s</tns:score>%s' % (self.gds_format_integer(self.score, input_name='score'), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'score')
            self.score = ival_
            # validate type principalOverallScore
            self.validate_principalOverallScore(self.score)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType17
            self.validate_descriptionType17(self.description)
# end class principalScore


class nameAddressSsnAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = code
        self.validate_nameAddressSsnAssociationCode(self.code)
        self.description = description
        self.validate_descriptionType18(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameAddressSsnAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameAddressSsnAssociation.subclass:
            return nameAddressSsnAssociation.subclass(*args_, **kwargs_)
        else:
            return nameAddressSsnAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_nameAddressSsnAssociationCode(self, value):
        # Validate type nameAddressSsnAssociationCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOTHING', 'WRONG_SSN', 'FIRST_LAST', 'FIRST_ADDRESS', 'FIRST_SSN', 'LAST_ADDRESS', 'ADDRESS_SSN', 'LAST_SSN', 'FIRST_LAST_ADDRESS', 'FIRST_LAST_SSN', 'FIRST_ADDRESS_SSN', 'LAST_ADDRESS_SSN', 'FIRST_LAST_ADDRESS_SSN']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on nameAddressSsnAssociationCode' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType18(self, value):
        # Validate type descriptionType18, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType18' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType18' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='nameAddressSsnAssociation', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameAddressSsnAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nameAddressSsnAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='nameAddressSsnAssociation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='nameAddressSsnAssociation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='nameAddressSsnAssociation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:code>%s</tns:code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
            # validate type nameAddressSsnAssociationCode
            self.validate_nameAddressSsnAssociationCode(self.code)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType18
            self.validate_descriptionType18(self.description)
# end class nameAddressSsnAssociation


class principalNameAddressPhoneAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, description=None):
        self.original_tagname_ = None
        self.code = code
        self.validate_principalNameAddressPhoneAssociationCode(self.code)
        self.description = description
        self.validate_descriptionType19(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalNameAddressPhoneAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalNameAddressPhoneAssociation.subclass:
            return principalNameAddressPhoneAssociation.subclass(*args_, **kwargs_)
        else:
            return principalNameAddressPhoneAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_principalNameAddressPhoneAssociationCode(self, value):
        # Validate type principalNameAddressPhoneAssociationCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NOTHING', 'WRONG_PHONE', 'FIRST_LAST', 'FIRST_ADDRESS', 'FIRST_PHONE', 'LAST_ADDRESS', 'ADDRESS_PHONE', 'LAST_PHONE', 'FIRST_LAST_ADDRESS', 'FIRST_LAST_PHONE', 'FIRST_ADDRESS_PHONE', 'LAST_ADDRESS_PHONE', 'FIRST_LAST_ADDRESS_PHONE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on principalNameAddressPhoneAssociationCode' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType19(self, value):
        # Validate type descriptionType19, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType19' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType19' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.code is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalNameAddressPhoneAssociation', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalNameAddressPhoneAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalNameAddressPhoneAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalNameAddressPhoneAssociation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalNameAddressPhoneAssociation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalNameAddressPhoneAssociation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:code>%s</tns:code>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
            # validate type principalNameAddressPhoneAssociationCode
            self.validate_principalNameAddressPhoneAssociationCode(self.code)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType19
            self.validate_descriptionType19(self.description)
# end class principalNameAddressPhoneAssociation


class principalVerificationIndicators(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nameVerified=None, addressVerified=None, phoneVerified=None, ssnVerified=None, dobVerified=None):
        self.original_tagname_ = None
        self.nameVerified = nameVerified
        self.addressVerified = addressVerified
        self.phoneVerified = phoneVerified
        self.ssnVerified = ssnVerified
        self.dobVerified = dobVerified
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalVerificationIndicators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalVerificationIndicators.subclass:
            return principalVerificationIndicators.subclass(*args_, **kwargs_)
        else:
            return principalVerificationIndicators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nameVerified(self): return self.nameVerified
    def set_nameVerified(self, nameVerified): self.nameVerified = nameVerified
    def get_addressVerified(self): return self.addressVerified
    def set_addressVerified(self, addressVerified): self.addressVerified = addressVerified
    def get_phoneVerified(self): return self.phoneVerified
    def set_phoneVerified(self, phoneVerified): self.phoneVerified = phoneVerified
    def get_ssnVerified(self): return self.ssnVerified
    def set_ssnVerified(self, ssnVerified): self.ssnVerified = ssnVerified
    def get_dobVerified(self): return self.dobVerified
    def set_dobVerified(self, dobVerified): self.dobVerified = dobVerified
    def hasContent_(self):
        if (
            self.nameVerified is not None or
            self.addressVerified is not None or
            self.phoneVerified is not None or
            self.ssnVerified is not None or
            self.dobVerified is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalVerificationIndicators', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalVerificationIndicators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalVerificationIndicators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalVerificationIndicators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalVerificationIndicators'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalVerificationIndicators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nameVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:nameVerified>%s</tns:nameVerified>%s' % (self.gds_format_boolean(self.nameVerified, input_name='nameVerified'), eol_))
        if self.addressVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:addressVerified>%s</tns:addressVerified>%s' % (self.gds_format_boolean(self.addressVerified, input_name='addressVerified'), eol_))
        if self.phoneVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:phoneVerified>%s</tns:phoneVerified>%s' % (self.gds_format_boolean(self.phoneVerified, input_name='phoneVerified'), eol_))
        if self.ssnVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:ssnVerified>%s</tns:ssnVerified>%s' % (self.gds_format_boolean(self.ssnVerified, input_name='ssnVerified'), eol_))
        if self.dobVerified is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:dobVerified>%s</tns:dobVerified>%s' % (self.gds_format_boolean(self.dobVerified, input_name='dobVerified'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nameVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'nameVerified')
            self.nameVerified = ival_
        elif nodeName_ == 'addressVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'addressVerified')
            self.addressVerified = ival_
        elif nodeName_ == 'phoneVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'phoneVerified')
            self.phoneVerified = ival_
        elif nodeName_ == 'ssnVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ssnVerified')
            self.ssnVerified = ival_
        elif nodeName_ == 'dobVerified':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'dobVerified')
            self.dobVerified = ival_
# end class principalVerificationIndicators


class businessToPrincipalAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, score=None, description=None):
        self.original_tagname_ = None
        self.score = score
        self.validate_businessToPrincipalScore(self.score)
        self.description = description
        self.validate_descriptionType20(self.description)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, businessToPrincipalAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if businessToPrincipalAssociation.subclass:
            return businessToPrincipalAssociation.subclass(*args_, **kwargs_)
        else:
            return businessToPrincipalAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def validate_businessToPrincipalScore(self, value):
        # Validate type businessToPrincipalScore, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '10', '20', '30', '40', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on businessToPrincipalScore' % {"value" : value.encode("utf-8")} )
    def validate_descriptionType20(self, value):
        # Validate type descriptionType20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 95:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descriptionType20' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descriptionType20' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='businessToPrincipalAssociation', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('businessToPrincipalAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='businessToPrincipalAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='businessToPrincipalAssociation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='businessToPrincipalAssociation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='businessToPrincipalAssociation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:score>%s</tns:score>%s' % (self.gds_format_integer(self.score, input_name='score'), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:description>%s</tns:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'score')
            self.score = ival_
            # validate type businessToPrincipalScore
            self.validate_businessToPrincipalScore(self.score)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            # validate type descriptionType20
            self.validate_descriptionType20(self.description)
# end class businessToPrincipalAssociation


class bankruptcyResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bankruptcyType=None, bankruptcyCount=None, companyName=None, streetAddress1=None, streetAddress2=None, city=None, state=None, zip=None, zip4=None, filingDate=None):
        self.original_tagname_ = None
        self.bankruptcyType = bankruptcyType
        self.validate_bankruptcyTypeType(self.bankruptcyType)
        self.bankruptcyCount = bankruptcyCount
        self.companyName = companyName
        self.validate_companyNameType(self.companyName)
        self.streetAddress1 = streetAddress1
        self.validate_streetAddress1Type21(self.streetAddress1)
        self.streetAddress2 = streetAddress2
        self.validate_streetAddress2Type22(self.streetAddress2)
        self.city = city
        self.validate_cityType23(self.city)
        self.state = state
        self.validate_stateType(self.state)
        self.zip = zip
        self.validate_zipType(self.zip)
        self.zip4 = zip4
        self.validate_zip4Type(self.zip4)
        if isinstance(filingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(filingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = filingDate
        self.filingDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankruptcyResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankruptcyResult.subclass:
            return bankruptcyResult.subclass(*args_, **kwargs_)
        else:
            return bankruptcyResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bankruptcyType(self): return self.bankruptcyType
    def set_bankruptcyType(self, bankruptcyType): self.bankruptcyType = bankruptcyType
    def get_bankruptcyCount(self): return self.bankruptcyCount
    def set_bankruptcyCount(self, bankruptcyCount): self.bankruptcyCount = bankruptcyCount
    def get_companyName(self): return self.companyName
    def set_companyName(self, companyName): self.companyName = companyName
    def get_streetAddress1(self): return self.streetAddress1
    def set_streetAddress1(self, streetAddress1): self.streetAddress1 = streetAddress1
    def get_streetAddress2(self): return self.streetAddress2
    def set_streetAddress2(self, streetAddress2): self.streetAddress2 = streetAddress2
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_zip(self): return self.zip
    def set_zip(self, zip): self.zip = zip
    def get_zip4(self): return self.zip4
    def set_zip4(self, zip4): self.zip4 = zip4
    def get_filingDate(self): return self.filingDate
    def set_filingDate(self, filingDate): self.filingDate = filingDate
    def validate_bankruptcyTypeType(self, value):
        # Validate type bankruptcyTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on bankruptcyTypeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on bankruptcyTypeType' % {"value" : value.encode("utf-8")} )
    def validate_companyNameType(self, value):
        # Validate type companyNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on companyNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on companyNameType' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress1Type21(self, value):
        # Validate type streetAddress1Type21, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress1Type21' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress1Type21' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress2Type22(self, value):
        # Validate type streetAddress2Type22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress2Type22' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress2Type22' % {"value" : value.encode("utf-8")} )
    def validate_cityType23(self, value):
        # Validate type cityType23, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cityType23' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cityType23' % {"value" : value.encode("utf-8")} )
    def validate_stateType(self, value):
        # Validate type stateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on stateType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on stateType' % {"value" : value.encode("utf-8")} )
    def validate_zipType(self, value):
        # Validate type zipType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on zipType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on zipType' % {"value" : value.encode("utf-8")} )
    def validate_zip4Type(self, value):
        # Validate type zip4Type, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on zip4Type' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on zip4Type' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.bankruptcyType is not None or
            self.bankruptcyCount is not None or
            self.companyName is not None or
            self.streetAddress1 is not None or
            self.streetAddress2 is not None or
            self.city is not None or
            self.state is not None or
            self.zip is not None or
            self.zip4 is not None or
            self.filingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='bankruptcyResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankruptcyResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bankruptcyResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='bankruptcyResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='bankruptcyResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='bankruptcyResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bankruptcyType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankruptcyType>%s</tns:bankruptcyType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bankruptcyType), input_name='bankruptcyType')), eol_))
        if self.bankruptcyCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankruptcyCount>%s</tns:bankruptcyCount>%s' % (self.gds_format_integer(self.bankruptcyCount, input_name='bankruptcyCount'), eol_))
        if self.companyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:companyName>%s</tns:companyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.companyName), input_name='companyName')), eol_))
        if self.streetAddress1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress1>%s</tns:streetAddress1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress1), input_name='streetAddress1')), eol_))
        if self.streetAddress2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress2>%s</tns:streetAddress2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress2), input_name='streetAddress2')), eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:city>%s</tns:city>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:state>%s</tns:state>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), eol_))
        if self.zip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:zip>%s</tns:zip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.zip), input_name='zip')), eol_))
        if self.zip4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:zip4>%s</tns:zip4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.zip4), input_name='zip4')), eol_))
        if self.filingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:filingDate>%s</tns:filingDate>%s' % (self.gds_format_date(self.filingDate, input_name='filingDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bankruptcyType':
            bankruptcyType_ = child_.text
            bankruptcyType_ = self.gds_validate_string(bankruptcyType_, node, 'bankruptcyType')
            self.bankruptcyType = bankruptcyType_
            # validate type bankruptcyTypeType
            self.validate_bankruptcyTypeType(self.bankruptcyType)
        elif nodeName_ == 'bankruptcyCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bankruptcyCount')
            self.bankruptcyCount = ival_
        elif nodeName_ == 'companyName':
            companyName_ = child_.text
            companyName_ = self.gds_validate_string(companyName_, node, 'companyName')
            self.companyName = companyName_
            # validate type companyNameType
            self.validate_companyNameType(self.companyName)
        elif nodeName_ == 'streetAddress1':
            streetAddress1_ = child_.text
            streetAddress1_ = self.gds_validate_string(streetAddress1_, node, 'streetAddress1')
            self.streetAddress1 = streetAddress1_
            # validate type streetAddress1Type21
            self.validate_streetAddress1Type21(self.streetAddress1)
        elif nodeName_ == 'streetAddress2':
            streetAddress2_ = child_.text
            streetAddress2_ = self.gds_validate_string(streetAddress2_, node, 'streetAddress2')
            self.streetAddress2 = streetAddress2_
            # validate type streetAddress2Type22
            self.validate_streetAddress2Type22(self.streetAddress2)
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type cityType23
            self.validate_cityType23(self.city)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            # validate type stateType
            self.validate_stateType(self.state)
        elif nodeName_ == 'zip':
            zip_ = child_.text
            zip_ = self.gds_validate_string(zip_, node, 'zip')
            self.zip = zip_
            # validate type zipType
            self.validate_zipType(self.zip)
        elif nodeName_ == 'zip4':
            zip4_ = child_.text
            zip4_ = self.gds_validate_string(zip4_, node, 'zip4')
            self.zip4 = zip4_
            # validate type zip4Type
            self.validate_zip4Type(self.zip4)
        elif nodeName_ == 'filingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.filingDate = dval_
# end class bankruptcyResult


class lienResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lienType=None, releasedCount=None, unreleasedCount=None, companyName=None, streetAddress1=None, streetAddress2=None, city=None, state=None, zip=None, zip4=None, filingDate=None):
        self.original_tagname_ = None
        self.lienType = lienType
        self.validate_lienTypeType(self.lienType)
        self.releasedCount = releasedCount
        self.unreleasedCount = unreleasedCount
        self.companyName = companyName
        self.validate_companyNameType24(self.companyName)
        self.streetAddress1 = streetAddress1
        self.validate_streetAddress1Type25(self.streetAddress1)
        self.streetAddress2 = streetAddress2
        self.validate_streetAddress2Type26(self.streetAddress2)
        self.city = city
        self.validate_cityType27(self.city)
        self.state = state
        self.validate_stateType28(self.state)
        self.zip = zip
        self.validate_zipType29(self.zip)
        self.zip4 = zip4
        self.validate_zip4Type30(self.zip4)
        if isinstance(filingDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(filingDate, '%Y-%m-%d').date()
        else:
            initvalue_ = filingDate
        self.filingDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lienResult)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lienResult.subclass:
            return lienResult.subclass(*args_, **kwargs_)
        else:
            return lienResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lienType(self): return self.lienType
    def set_lienType(self, lienType): self.lienType = lienType
    def get_releasedCount(self): return self.releasedCount
    def set_releasedCount(self, releasedCount): self.releasedCount = releasedCount
    def get_unreleasedCount(self): return self.unreleasedCount
    def set_unreleasedCount(self, unreleasedCount): self.unreleasedCount = unreleasedCount
    def get_companyName(self): return self.companyName
    def set_companyName(self, companyName): self.companyName = companyName
    def get_streetAddress1(self): return self.streetAddress1
    def set_streetAddress1(self, streetAddress1): self.streetAddress1 = streetAddress1
    def get_streetAddress2(self): return self.streetAddress2
    def set_streetAddress2(self, streetAddress2): self.streetAddress2 = streetAddress2
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_zip(self): return self.zip
    def set_zip(self, zip): self.zip = zip
    def get_zip4(self): return self.zip4
    def set_zip4(self, zip4): self.zip4 = zip4
    def get_filingDate(self): return self.filingDate
    def set_filingDate(self, filingDate): self.filingDate = filingDate
    def validate_lienTypeType(self, value):
        # Validate type lienTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lienTypeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lienTypeType' % {"value" : value.encode("utf-8")} )
    def validate_companyNameType24(self, value):
        # Validate type companyNameType24, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on companyNameType24' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on companyNameType24' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress1Type25(self, value):
        # Validate type streetAddress1Type25, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress1Type25' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress1Type25' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress2Type26(self, value):
        # Validate type streetAddress2Type26, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress2Type26' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress2Type26' % {"value" : value.encode("utf-8")} )
    def validate_cityType27(self, value):
        # Validate type cityType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cityType27' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cityType27' % {"value" : value.encode("utf-8")} )
    def validate_stateType28(self, value):
        # Validate type stateType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on stateType28' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on stateType28' % {"value" : value.encode("utf-8")} )
    def validate_zipType29(self, value):
        # Validate type zipType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on zipType29' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on zipType29' % {"value" : value.encode("utf-8")} )
    def validate_zip4Type30(self, value):
        # Validate type zip4Type30, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on zip4Type30' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on zip4Type30' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.lienType is not None or
            self.releasedCount is not None or
            self.unreleasedCount is not None or
            self.companyName is not None or
            self.streetAddress1 is not None or
            self.streetAddress2 is not None or
            self.city is not None or
            self.state is not None or
            self.zip is not None or
            self.zip4 is not None or
            self.filingDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='lienResult', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lienResult')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lienResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='lienResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='lienResult'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='lienResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lienType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lienType>%s</tns:lienType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lienType), input_name='lienType')), eol_))
        if self.releasedCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:releasedCount>%s</tns:releasedCount>%s' % (self.gds_format_integer(self.releasedCount, input_name='releasedCount'), eol_))
        if self.unreleasedCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:unreleasedCount>%s</tns:unreleasedCount>%s' % (self.gds_format_integer(self.unreleasedCount, input_name='unreleasedCount'), eol_))
        if self.companyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:companyName>%s</tns:companyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.companyName), input_name='companyName')), eol_))
        if self.streetAddress1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress1>%s</tns:streetAddress1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress1), input_name='streetAddress1')), eol_))
        if self.streetAddress2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress2>%s</tns:streetAddress2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress2), input_name='streetAddress2')), eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:city>%s</tns:city>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), eol_))
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:state>%s</tns:state>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), eol_))
        if self.zip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:zip>%s</tns:zip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.zip), input_name='zip')), eol_))
        if self.zip4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:zip4>%s</tns:zip4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.zip4), input_name='zip4')), eol_))
        if self.filingDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:filingDate>%s</tns:filingDate>%s' % (self.gds_format_date(self.filingDate, input_name='filingDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lienType':
            lienType_ = child_.text
            lienType_ = self.gds_validate_string(lienType_, node, 'lienType')
            self.lienType = lienType_
            # validate type lienTypeType
            self.validate_lienTypeType(self.lienType)
        elif nodeName_ == 'releasedCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'releasedCount')
            self.releasedCount = ival_
        elif nodeName_ == 'unreleasedCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'unreleasedCount')
            self.unreleasedCount = ival_
        elif nodeName_ == 'companyName':
            companyName_ = child_.text
            companyName_ = self.gds_validate_string(companyName_, node, 'companyName')
            self.companyName = companyName_
            # validate type companyNameType24
            self.validate_companyNameType24(self.companyName)
        elif nodeName_ == 'streetAddress1':
            streetAddress1_ = child_.text
            streetAddress1_ = self.gds_validate_string(streetAddress1_, node, 'streetAddress1')
            self.streetAddress1 = streetAddress1_
            # validate type streetAddress1Type25
            self.validate_streetAddress1Type25(self.streetAddress1)
        elif nodeName_ == 'streetAddress2':
            streetAddress2_ = child_.text
            streetAddress2_ = self.gds_validate_string(streetAddress2_, node, 'streetAddress2')
            self.streetAddress2 = streetAddress2_
            # validate type streetAddress2Type26
            self.validate_streetAddress2Type26(self.streetAddress2)
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type cityType27
            self.validate_cityType27(self.city)
        elif nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
            # validate type stateType28
            self.validate_stateType28(self.state)
        elif nodeName_ == 'zip':
            zip_ = child_.text
            zip_ = self.gds_validate_string(zip_, node, 'zip')
            self.zip = zip_
            # validate type zipType29
            self.validate_zipType29(self.zip)
        elif nodeName_ == 'zip4':
            zip4_ = child_.text
            zip4_ = self.gds_validate_string(zip4_, node, 'zip4')
            self.zip4 = zip4_
            # validate type zip4Type30
            self.validate_zip4Type30(self.zip4)
        elif nodeName_ == 'filingDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.filingDate = dval_
# end class lienResult


class legalEntityUpdateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, address=None, contactPhone=None, doingBusinessAs=None, annualCreditCardSalesVolume=None, hasAcceptedCreditCards=None, principal=None, backgroundCheckFields=None, legalEntityOwnershipType=None, yearsInBusiness=None):
        self.original_tagname_ = None
        self.address = address
        self.contactPhone = contactPhone
        self.validate_contactPhoneType31(self.contactPhone)
        self.doingBusinessAs = doingBusinessAs
        self.validate_doingBusinessAsType32(self.doingBusinessAs)
        self.annualCreditCardSalesVolume = annualCreditCardSalesVolume
        self.hasAcceptedCreditCards = hasAcceptedCreditCards
        self.principal = principal
        self.backgroundCheckFields = backgroundCheckFields
        self.legalEntityOwnershipType = legalEntityOwnershipType
        self.validate_legalEntityOwnershipType(self.legalEntityOwnershipType)
        self.yearsInBusiness = yearsInBusiness
        self.validate_yearsInBusinessType33(self.yearsInBusiness)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityUpdateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityUpdateRequest.subclass:
            return legalEntityUpdateRequest.subclass(*args_, **kwargs_)
        else:
            return legalEntityUpdateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_doingBusinessAs(self): return self.doingBusinessAs
    def set_doingBusinessAs(self, doingBusinessAs): self.doingBusinessAs = doingBusinessAs
    def get_annualCreditCardSalesVolume(self): return self.annualCreditCardSalesVolume
    def set_annualCreditCardSalesVolume(self, annualCreditCardSalesVolume): self.annualCreditCardSalesVolume = annualCreditCardSalesVolume
    def get_hasAcceptedCreditCards(self): return self.hasAcceptedCreditCards
    def set_hasAcceptedCreditCards(self, hasAcceptedCreditCards): self.hasAcceptedCreditCards = hasAcceptedCreditCards
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_backgroundCheckFields(self): return self.backgroundCheckFields
    def set_backgroundCheckFields(self, backgroundCheckFields): self.backgroundCheckFields = backgroundCheckFields
    def get_legalEntityOwnershipType(self): return self.legalEntityOwnershipType
    def set_legalEntityOwnershipType(self, legalEntityOwnershipType): self.legalEntityOwnershipType = legalEntityOwnershipType
    def get_yearsInBusiness(self): return self.yearsInBusiness
    def set_yearsInBusiness(self, yearsInBusiness): self.yearsInBusiness = yearsInBusiness
    def validate_contactPhoneType31(self, value):
        # Validate type contactPhoneType31, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on contactPhoneType31' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on contactPhoneType31' % {"value" : value.encode("utf-8")} )
    def validate_doingBusinessAsType32(self, value):
        # Validate type doingBusinessAsType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on doingBusinessAsType32' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on doingBusinessAsType32' % {"value" : value.encode("utf-8")} )
    def validate_legalEntityOwnershipType(self, value):
        # Validate type legalEntityOwnershipType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PUBLIC', 'PRIVATE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on legalEntityOwnershipType' % {"value" : value.encode("utf-8")} )
    def validate_yearsInBusinessType33(self, value):
        # Validate type yearsInBusinessType33, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on yearsInBusinessType33' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on yearsInBusinessType33' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_yearsInBusinessType33_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_yearsInBusinessType33_patterns_, ))
    validate_yearsInBusinessType33_patterns_ = [[u'^[0-9]{0,3}$']]
    def hasContent_(self):
        if (
            self.address is not None or
            self.contactPhone is not None or
            self.doingBusinessAs is not None or
            self.annualCreditCardSalesVolume is not None or
            self.hasAcceptedCreditCards is not None or
            self.principal is not None or
            self.backgroundCheckFields is not None or
            self.legalEntityOwnershipType is not None or
            self.yearsInBusiness is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityUpdateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityUpdateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityUpdateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityUpdateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityUpdateRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityUpdateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.contactPhone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:contactPhone>%s</tns:contactPhone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.contactPhone), input_name='contactPhone')), eol_))
        if self.doingBusinessAs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:doingBusinessAs>%s</tns:doingBusinessAs>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.doingBusinessAs), input_name='doingBusinessAs')), eol_))
        if self.annualCreditCardSalesVolume is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:annualCreditCardSalesVolume>%s</tns:annualCreditCardSalesVolume>%s' % (self.gds_format_integer(self.annualCreditCardSalesVolume, input_name='annualCreditCardSalesVolume'), eol_))
        if self.hasAcceptedCreditCards is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:hasAcceptedCreditCards>%s</tns:hasAcceptedCreditCards>%s' % (self.gds_format_boolean(self.hasAcceptedCreditCards, input_name='hasAcceptedCreditCards'), eol_))
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
        if self.backgroundCheckFields is not None:
            self.backgroundCheckFields.export(outfile, level, namespaceprefix_, name_='backgroundCheckFields', pretty_print=pretty_print)
        if self.legalEntityOwnershipType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityOwnershipType>%s</tns:legalEntityOwnershipType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityOwnershipType), input_name='legalEntityOwnershipType')), eol_))
        if self.yearsInBusiness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:yearsInBusiness>%s</tns:yearsInBusiness>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.yearsInBusiness), input_name='yearsInBusiness')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            obj_ = addressUpdatable.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
            # validate type contactPhoneType31
            self.validate_contactPhoneType31(self.contactPhone)
        elif nodeName_ == 'doingBusinessAs':
            doingBusinessAs_ = child_.text
            doingBusinessAs_ = self.gds_validate_string(doingBusinessAs_, node, 'doingBusinessAs')
            self.doingBusinessAs = doingBusinessAs_
            # validate type doingBusinessAsType32
            self.validate_doingBusinessAsType32(self.doingBusinessAs)
        elif nodeName_ == 'annualCreditCardSalesVolume' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'annualCreditCardSalesVolume')
            self.annualCreditCardSalesVolume = ival_
        elif nodeName_ == 'hasAcceptedCreditCards':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasAcceptedCreditCards')
            self.hasAcceptedCreditCards = ival_
        elif nodeName_ == 'principal':
            obj_ = legalEntityPrincipalUpdatable.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        elif nodeName_ == 'backgroundCheckFields':
            obj_ = legalEntityBackgroundCheckFields.factory()
            obj_.build(child_)
            self.backgroundCheckFields = obj_
            obj_.original_tagname_ = 'backgroundCheckFields'
        elif nodeName_ == 'legalEntityOwnershipType':
            legalEntityOwnershipType_ = child_.text
            legalEntityOwnershipType_ = self.gds_validate_string(legalEntityOwnershipType_, node, 'legalEntityOwnershipType')
            self.legalEntityOwnershipType = legalEntityOwnershipType_
            # validate type legalEntityOwnershipType
            self.validate_legalEntityOwnershipType(self.legalEntityOwnershipType)
        elif nodeName_ == 'yearsInBusiness':
            yearsInBusiness_ = child_.text
            yearsInBusiness_ = self.gds_validate_string(yearsInBusiness_, node, 'yearsInBusiness')
            self.yearsInBusiness = yearsInBusiness_
            # validate type yearsInBusinessType33
            self.validate_yearsInBusinessType33(self.yearsInBusiness)
# end class legalEntityUpdateRequest


class addressUpdatable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, streetAddress1=None, streetAddress2=None, city=None, stateProvince=None, postalCode=None, countryCode=None):
        self.original_tagname_ = None
        self.streetAddress1 = streetAddress1
        self.validate_streetAddress1Type34(self.streetAddress1)
        self.streetAddress2 = streetAddress2
        self.validate_streetAddress2Type35(self.streetAddress2)
        self.city = city
        self.validate_cityType36(self.city)
        self.stateProvince = stateProvince
        self.validate_stateProvinceType37(self.stateProvince)
        self.postalCode = postalCode
        self.validate_postalCodeType38(self.postalCode)
        self.countryCode = countryCode
        self.validate_countryCodeType39(self.countryCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressUpdatable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressUpdatable.subclass:
            return addressUpdatable.subclass(*args_, **kwargs_)
        else:
            return addressUpdatable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_streetAddress1(self): return self.streetAddress1
    def set_streetAddress1(self, streetAddress1): self.streetAddress1 = streetAddress1
    def get_streetAddress2(self): return self.streetAddress2
    def set_streetAddress2(self, streetAddress2): self.streetAddress2 = streetAddress2
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_stateProvince(self): return self.stateProvince
    def set_stateProvince(self, stateProvince): self.stateProvince = stateProvince
    def get_postalCode(self): return self.postalCode
    def set_postalCode(self, postalCode): self.postalCode = postalCode
    def get_countryCode(self): return self.countryCode
    def set_countryCode(self, countryCode): self.countryCode = countryCode
    def validate_streetAddress1Type34(self, value):
        # Validate type streetAddress1Type34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress1Type34' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress1Type34' % {"value" : value.encode("utf-8")} )
    def validate_streetAddress2Type35(self, value):
        # Validate type streetAddress2Type35, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on streetAddress2Type35' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on streetAddress2Type35' % {"value" : value.encode("utf-8")} )
    def validate_cityType36(self, value):
        # Validate type cityType36, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cityType36' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cityType36' % {"value" : value.encode("utf-8")} )
    def validate_stateProvinceType37(self, value):
        # Validate type stateProvinceType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on stateProvinceType37' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on stateProvinceType37' % {"value" : value.encode("utf-8")} )
    def validate_postalCodeType38(self, value):
        # Validate type postalCodeType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 7:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on postalCodeType38' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on postalCodeType38' % {"value" : value.encode("utf-8")} )
    def validate_countryCodeType39(self, value):
        # Validate type countryCodeType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on countryCodeType39' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on countryCodeType39' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.streetAddress1 is not None or
            self.streetAddress2 is not None or
            self.city is not None or
            self.stateProvince is not None or
            self.postalCode is not None or
            self.countryCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='addressUpdatable', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressUpdatable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressUpdatable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='addressUpdatable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='addressUpdatable'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='addressUpdatable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.streetAddress1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress1>%s</tns:streetAddress1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress1), input_name='streetAddress1')), eol_))
        if self.streetAddress2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:streetAddress2>%s</tns:streetAddress2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.streetAddress2), input_name='streetAddress2')), eol_))
        if self.city is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:city>%s</tns:city>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.city), input_name='city')), eol_))
        if self.stateProvince is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stateProvince>%s</tns:stateProvince>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.stateProvince), input_name='stateProvince')), eol_))
        if self.postalCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:postalCode>%s</tns:postalCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.postalCode), input_name='postalCode')), eol_))
        if self.countryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:countryCode>%s</tns:countryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.countryCode), input_name='countryCode')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'streetAddress1':
            streetAddress1_ = child_.text
            streetAddress1_ = self.gds_validate_string(streetAddress1_, node, 'streetAddress1')
            self.streetAddress1 = streetAddress1_
            # validate type streetAddress1Type34
            self.validate_streetAddress1Type34(self.streetAddress1)
        elif nodeName_ == 'streetAddress2':
            streetAddress2_ = child_.text
            streetAddress2_ = self.gds_validate_string(streetAddress2_, node, 'streetAddress2')
            self.streetAddress2 = streetAddress2_
            # validate type streetAddress2Type35
            self.validate_streetAddress2Type35(self.streetAddress2)
        elif nodeName_ == 'city':
            city_ = child_.text
            city_ = self.gds_validate_string(city_, node, 'city')
            self.city = city_
            # validate type cityType36
            self.validate_cityType36(self.city)
        elif nodeName_ == 'stateProvince':
            stateProvince_ = child_.text
            stateProvince_ = self.gds_validate_string(stateProvince_, node, 'stateProvince')
            self.stateProvince = stateProvince_
            # validate type stateProvinceType37
            self.validate_stateProvinceType37(self.stateProvince)
        elif nodeName_ == 'postalCode':
            postalCode_ = child_.text
            postalCode_ = self.gds_validate_string(postalCode_, node, 'postalCode')
            self.postalCode = postalCode_
            # validate type postalCodeType38
            self.validate_postalCodeType38(self.postalCode)
        elif nodeName_ == 'countryCode':
            countryCode_ = child_.text
            countryCode_ = self.gds_validate_string(countryCode_, node, 'countryCode')
            self.countryCode = countryCode_
            # validate type countryCodeType39
            self.validate_countryCodeType39(self.countryCode)
# end class addressUpdatable


class legalEntityPrincipalUpdatable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, principalId=None, title=None, emailAddress=None, contactPhone=None, address=None, stakePercent=None, backgroundCheckFields=None):
        self.original_tagname_ = None
        self.principalId = principalId
        self.title = title
        self.validate_titleType40(self.title)
        self.emailAddress = emailAddress
        self.validate_emailAddressType41(self.emailAddress)
        self.contactPhone = contactPhone
        self.validate_contactPhoneType42(self.contactPhone)
        self.address = address
        self.stakePercent = stakePercent
        self.validate_stakePercentType43(self.stakePercent)
        self.backgroundCheckFields = backgroundCheckFields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipalUpdatable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipalUpdatable.subclass:
            return legalEntityPrincipalUpdatable.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipalUpdatable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def get_contactPhone(self): return self.contactPhone
    def set_contactPhone(self, contactPhone): self.contactPhone = contactPhone
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_stakePercent(self): return self.stakePercent
    def set_stakePercent(self, stakePercent): self.stakePercent = stakePercent
    def get_backgroundCheckFields(self): return self.backgroundCheckFields
    def set_backgroundCheckFields(self, backgroundCheckFields): self.backgroundCheckFields = backgroundCheckFields
    def validate_titleType40(self, value):
        # Validate type titleType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on titleType40' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on titleType40' % {"value" : value.encode("utf-8")} )
    def validate_emailAddressType41(self, value):
        # Validate type emailAddressType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailAddressType41' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailAddressType41' % {"value" : value.encode("utf-8")} )
    def validate_contactPhoneType42(self, value):
        # Validate type contactPhoneType42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on contactPhoneType42' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on contactPhoneType42' % {"value" : value.encode("utf-8")} )
    def validate_stakePercentType43(self, value):
        # Validate type stakePercentType43, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on stakePercentType43' % {"value" : value} )
            if value > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on stakePercentType43' % {"value" : value} )
    def hasContent_(self):
        if (
            self.principalId is not None or
            self.title is not None or
            self.emailAddress is not None or
            self.contactPhone is not None or
            self.address is not None or
            self.stakePercent is not None or
            self.backgroundCheckFields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalUpdatable', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipalUpdatable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalUpdatable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipalUpdatable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipalUpdatable'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalUpdatable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:title>%s</tns:title>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), eol_))
        if self.emailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:emailAddress>%s</tns:emailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.emailAddress), input_name='emailAddress')), eol_))
        if self.contactPhone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:contactPhone>%s</tns:contactPhone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.contactPhone), input_name='contactPhone')), eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.stakePercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:stakePercent>%s</tns:stakePercent>%s' % (self.gds_format_integer(self.stakePercent, input_name='stakePercent'), eol_))
        if self.backgroundCheckFields is not None:
            self.backgroundCheckFields.export(outfile, level, namespaceprefix_, name_='backgroundCheckFields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
            # validate type titleType40
            self.validate_titleType40(self.title)
        elif nodeName_ == 'emailAddress':
            emailAddress_ = child_.text
            emailAddress_ = self.gds_validate_string(emailAddress_, node, 'emailAddress')
            self.emailAddress = emailAddress_
            # validate type emailAddressType41
            self.validate_emailAddressType41(self.emailAddress)
        elif nodeName_ == 'contactPhone':
            contactPhone_ = child_.text
            contactPhone_ = self.gds_validate_string(contactPhone_, node, 'contactPhone')
            self.contactPhone = contactPhone_
            # validate type contactPhoneType42
            self.validate_contactPhoneType42(self.contactPhone)
        elif nodeName_ == 'address':
            obj_ = principalAddress.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'stakePercent' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'stakePercent')
            self.stakePercent = ival_
            # validate type stakePercentType43
            self.validate_stakePercentType43(self.stakePercent)
        elif nodeName_ == 'backgroundCheckFields':
            obj_ = principalBackgroundCheckFields.factory()
            obj_.build(child_)
            self.backgroundCheckFields = obj_
            obj_.original_tagname_ = 'backgroundCheckFields'
# end class legalEntityPrincipalUpdatable


class principalBackgroundCheckFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, firstName=None, lastName=None, ssn=None, dateOfBirth=None, driversLicense=None, driversLicenseState=None):
        self.original_tagname_ = None
        self.firstName = firstName
        self.validate_firstNameType44(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType45(self.lastName)
        self.ssn = ssn
        self.validate_ssnType46(self.ssn)
        if isinstance(dateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = dateOfBirth
        self.dateOfBirth = initvalue_
        self.driversLicense = driversLicense
        self.validate_driversLicenseType47(self.driversLicense)
        self.driversLicenseState = driversLicenseState
        self.validate_driversLicenseStateType48(self.driversLicenseState)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalBackgroundCheckFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalBackgroundCheckFields.subclass:
            return principalBackgroundCheckFields.subclass(*args_, **kwargs_)
        else:
            return principalBackgroundCheckFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_ssn(self): return self.ssn
    def set_ssn(self, ssn): self.ssn = ssn
    def get_dateOfBirth(self): return self.dateOfBirth
    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth
    def get_driversLicense(self): return self.driversLicense
    def set_driversLicense(self, driversLicense): self.driversLicense = driversLicense
    def get_driversLicenseState(self): return self.driversLicenseState
    def set_driversLicenseState(self, driversLicenseState): self.driversLicenseState = driversLicenseState
    def validate_firstNameType44(self, value):
        # Validate type firstNameType44, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType44' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType44' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType45(self, value):
        # Validate type lastNameType45, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType45' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType45' % {"value" : value.encode("utf-8")} )
    def validate_ssnType46(self, value):
        # Validate type ssnType46, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on ssnType46' % {"value" : value.encode("utf-8")} )
            if len(value) < 9:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on ssnType46' % {"value" : value.encode("utf-8")} )
    def validate_driversLicenseType47(self, value):
        # Validate type driversLicenseType47, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on driversLicenseType47' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on driversLicenseType47' % {"value" : value.encode("utf-8")} )
    def validate_driversLicenseStateType48(self, value):
        # Validate type driversLicenseStateType48, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on driversLicenseStateType48' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on driversLicenseStateType48' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.firstName is not None or
            self.lastName is not None or
            self.ssn is not None or
            self.dateOfBirth is not None or
            self.driversLicense is not None or
            self.driversLicenseState is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalBackgroundCheckFields', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalBackgroundCheckFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalBackgroundCheckFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalBackgroundCheckFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalBackgroundCheckFields'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalBackgroundCheckFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
        if self.ssn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:ssn>%s</tns:ssn>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ssn), input_name='ssn')), eol_))
        if self.dateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:dateOfBirth>%s</tns:dateOfBirth>%s' % (self.gds_format_date(self.dateOfBirth, input_name='dateOfBirth'), eol_))
        if self.driversLicense is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:driversLicense>%s</tns:driversLicense>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.driversLicense), input_name='driversLicense')), eol_))
        if self.driversLicenseState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:driversLicenseState>%s</tns:driversLicenseState>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.driversLicenseState), input_name='driversLicenseState')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType44
            self.validate_firstNameType44(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType45
            self.validate_lastNameType45(self.lastName)
        elif nodeName_ == 'ssn':
            ssn_ = child_.text
            ssn_ = self.gds_validate_string(ssn_, node, 'ssn')
            self.ssn = ssn_
            # validate type ssnType46
            self.validate_ssnType46(self.ssn)
        elif nodeName_ == 'dateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.dateOfBirth = dval_
        elif nodeName_ == 'driversLicense':
            driversLicense_ = child_.text
            driversLicense_ = self.gds_validate_string(driversLicense_, node, 'driversLicense')
            self.driversLicense = driversLicense_
            # validate type driversLicenseType47
            self.validate_driversLicenseType47(self.driversLicense)
        elif nodeName_ == 'driversLicenseState':
            driversLicenseState_ = child_.text
            driversLicenseState_ = self.gds_validate_string(driversLicenseState_, node, 'driversLicenseState')
            self.driversLicenseState = driversLicenseState_
            # validate type driversLicenseStateType48
            self.validate_driversLicenseStateType48(self.driversLicenseState)
# end class principalBackgroundCheckFields


class legalEntityBackgroundCheckFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityName=None, legalEntityType=None, taxId=None):
        self.original_tagname_ = None
        self.legalEntityName = legalEntityName
        self.validate_legalEntityNameType49(self.legalEntityName)
        self.legalEntityType = legalEntityType
        self.validate_legalEntityType(self.legalEntityType)
        self.taxId = taxId
        self.validate_taxIdType50(self.taxId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityBackgroundCheckFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityBackgroundCheckFields.subclass:
            return legalEntityBackgroundCheckFields.subclass(*args_, **kwargs_)
        else:
            return legalEntityBackgroundCheckFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityName(self): return self.legalEntityName
    def set_legalEntityName(self, legalEntityName): self.legalEntityName = legalEntityName
    def get_legalEntityType(self): return self.legalEntityType
    def set_legalEntityType(self, legalEntityType): self.legalEntityType = legalEntityType
    def get_taxId(self): return self.taxId
    def set_taxId(self, taxId): self.taxId = taxId
    def validate_legalEntityNameType49(self, value):
        # Validate type legalEntityNameType49, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityNameType49' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityNameType49' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_legalEntityNameType49_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_legalEntityNameType49_patterns_, ))
    validate_legalEntityNameType49_patterns_ = [[u'^\\p{IsBasicLatin}*$']]
    def validate_legalEntityType(self, value):
        # Validate type legalEntityType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INDIVIDUAL_SOLE_PROPRIETORSHIP', 'CORPORATION', 'LIMITED_LIABILITY_COMPANY', 'PARTNERSHIP', 'LIMITED_PARTNERSHIP', 'GENERAL_PARTNERSHIP', 'TAX_EXEMPT_ORGANIZATION', 'GOVERNMENT_AGENCY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on legalEntityType' % {"value" : value.encode("utf-8")} )
    def validate_taxIdType50(self, value):
        # Validate type taxIdType50, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on taxIdType50' % {"value" : value.encode("utf-8")} )
            if len(value) < 9:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on taxIdType50' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityName is not None or
            self.legalEntityType is not None or
            self.taxId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityBackgroundCheckFields', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityBackgroundCheckFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityBackgroundCheckFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityBackgroundCheckFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityBackgroundCheckFields'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityBackgroundCheckFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityName>%s</tns:legalEntityName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityName), input_name='legalEntityName')), eol_))
        if self.legalEntityType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityType>%s</tns:legalEntityType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityType), input_name='legalEntityType')), eol_))
        if self.taxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxId>%s</tns:taxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxId), input_name='taxId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityName':
            legalEntityName_ = child_.text
            legalEntityName_ = self.gds_validate_string(legalEntityName_, node, 'legalEntityName')
            self.legalEntityName = legalEntityName_
            # validate type legalEntityNameType49
            self.validate_legalEntityNameType49(self.legalEntityName)
        elif nodeName_ == 'legalEntityType':
            legalEntityType_ = child_.text
            legalEntityType_ = self.gds_validate_string(legalEntityType_, node, 'legalEntityType')
            self.legalEntityType = legalEntityType_
            # validate type legalEntityType
            self.validate_legalEntityType(self.legalEntityType)
        elif nodeName_ == 'taxId':
            taxId_ = child_.text
            taxId_ = self.gds_validate_string(taxId_, node, 'taxId')
            self.taxId = taxId_
            # validate type taxIdType50
            self.validate_taxIdType50(self.taxId)
# end class legalEntityBackgroundCheckFields


class subMerchantCreateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, merchantName=None, amexMid=None, discoverConveyedMid=None, url=None, customerServiceNumber=None, hardCodedBillingDescriptor=None, maxTransactionAmount=None, purchaseCurrency=None, merchantCategoryCode=None, taxAuthority=None, taxAuthorityState=None, bankRoutingNumber=None, bankAccountNumber=None, pspMerchantId=None, fraud=None, amexAcquired=None, address=None, primaryContact=None, createCredentials=None, eCheck=None, subMerchantFunding=None, settlementCurrency=None, extensiontype_=None):
        self.original_tagname_ = None
        self.merchantName = merchantName
        self.validate_merchantNameType(self.merchantName)
        self.amexMid = amexMid
        self.validate_amexMidType(self.amexMid)
        self.discoverConveyedMid = discoverConveyedMid
        self.validate_discoverConveyedMidType(self.discoverConveyedMid)
        self.url = url
        self.validate_urlType(self.url)
        self.customerServiceNumber = customerServiceNumber
        self.validate_customerServiceNumberType(self.customerServiceNumber)
        self.hardCodedBillingDescriptor = hardCodedBillingDescriptor
        self.validate_hardCodedBillingDescriptorType(self.hardCodedBillingDescriptor)
        self.maxTransactionAmount = maxTransactionAmount
        self.validate_maxTransactionAmountType(self.maxTransactionAmount)
        self.purchaseCurrency = purchaseCurrency
        self.validate_purchaseCurrencyType(self.purchaseCurrency)
        self.merchantCategoryCode = merchantCategoryCode
        self.validate_merchantCategoryCodeType(self.merchantCategoryCode)
        self.taxAuthority = taxAuthority
        self.taxAuthorityState = taxAuthorityState
        self.bankRoutingNumber = bankRoutingNumber
        self.validate_bankRoutingNumberType(self.bankRoutingNumber)
        self.bankAccountNumber = bankAccountNumber
        self.validate_bankAccountNumberType(self.bankAccountNumber)
        self.pspMerchantId = pspMerchantId
        self.validate_pspMerchantIdType(self.pspMerchantId)
        self.fraud = fraud
        self.amexAcquired = amexAcquired
        self.address = address
        self.primaryContact = primaryContact
        self.createCredentials = createCredentials
        self.eCheck = eCheck
        self.subMerchantFunding = subMerchantFunding
        self.settlementCurrency = settlementCurrency
        self.validate_settlementCurrencyType(self.settlementCurrency)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantCreateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantCreateRequest.subclass:
            return subMerchantCreateRequest.subclass(*args_, **kwargs_)
        else:
            return subMerchantCreateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merchantName(self): return self.merchantName
    def set_merchantName(self, merchantName): self.merchantName = merchantName
    def get_amexMid(self): return self.amexMid
    def set_amexMid(self, amexMid): self.amexMid = amexMid
    def get_discoverConveyedMid(self): return self.discoverConveyedMid
    def set_discoverConveyedMid(self, discoverConveyedMid): self.discoverConveyedMid = discoverConveyedMid
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_customerServiceNumber(self): return self.customerServiceNumber
    def set_customerServiceNumber(self, customerServiceNumber): self.customerServiceNumber = customerServiceNumber
    def get_hardCodedBillingDescriptor(self): return self.hardCodedBillingDescriptor
    def set_hardCodedBillingDescriptor(self, hardCodedBillingDescriptor): self.hardCodedBillingDescriptor = hardCodedBillingDescriptor
    def get_maxTransactionAmount(self): return self.maxTransactionAmount
    def set_maxTransactionAmount(self, maxTransactionAmount): self.maxTransactionAmount = maxTransactionAmount
    def get_purchaseCurrency(self): return self.purchaseCurrency
    def set_purchaseCurrency(self, purchaseCurrency): self.purchaseCurrency = purchaseCurrency
    def get_merchantCategoryCode(self): return self.merchantCategoryCode
    def set_merchantCategoryCode(self, merchantCategoryCode): self.merchantCategoryCode = merchantCategoryCode
    def get_taxAuthority(self): return self.taxAuthority
    def set_taxAuthority(self, taxAuthority): self.taxAuthority = taxAuthority
    def get_taxAuthorityState(self): return self.taxAuthorityState
    def set_taxAuthorityState(self, taxAuthorityState): self.taxAuthorityState = taxAuthorityState
    def get_bankRoutingNumber(self): return self.bankRoutingNumber
    def set_bankRoutingNumber(self, bankRoutingNumber): self.bankRoutingNumber = bankRoutingNumber
    def get_bankAccountNumber(self): return self.bankAccountNumber
    def set_bankAccountNumber(self, bankAccountNumber): self.bankAccountNumber = bankAccountNumber
    def get_pspMerchantId(self): return self.pspMerchantId
    def set_pspMerchantId(self, pspMerchantId): self.pspMerchantId = pspMerchantId
    def get_fraud(self): return self.fraud
    def set_fraud(self, fraud): self.fraud = fraud
    def get_amexAcquired(self): return self.amexAcquired
    def set_amexAcquired(self, amexAcquired): self.amexAcquired = amexAcquired
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_primaryContact(self): return self.primaryContact
    def set_primaryContact(self, primaryContact): self.primaryContact = primaryContact
    def get_createCredentials(self): return self.createCredentials
    def set_createCredentials(self, createCredentials): self.createCredentials = createCredentials
    def get_eCheck(self): return self.eCheck
    def set_eCheck(self, eCheck): self.eCheck = eCheck
    def get_subMerchantFunding(self): return self.subMerchantFunding
    def set_subMerchantFunding(self, subMerchantFunding): self.subMerchantFunding = subMerchantFunding
    def get_settlementCurrency(self): return self.settlementCurrency
    def set_settlementCurrency(self, settlementCurrency): self.settlementCurrency = settlementCurrency
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_merchantNameType(self, value):
        # Validate type merchantNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on merchantNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on merchantNameType' % {"value" : value.encode("utf-8")} )
    def validate_amexMidType(self, value):
        # Validate type amexMidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on amexMidType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on amexMidType' % {"value" : value.encode("utf-8")} )
    def validate_discoverConveyedMidType(self, value):
        # Validate type discoverConveyedMidType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on discoverConveyedMidType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on discoverConveyedMidType' % {"value" : value.encode("utf-8")} )
    def validate_urlType(self, value):
        # Validate type urlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on urlType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on urlType' % {"value" : value.encode("utf-8")} )
    def validate_customerServiceNumberType(self, value):
        # Validate type customerServiceNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on customerServiceNumberType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on customerServiceNumberType' % {"value" : value.encode("utf-8")} )
    def validate_hardCodedBillingDescriptorType(self, value):
        # Validate type hardCodedBillingDescriptorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on hardCodedBillingDescriptorType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on hardCodedBillingDescriptorType' % {"value" : value.encode("utf-8")} )
    def validate_maxTransactionAmountType(self, value):
        # Validate type maxTransactionAmountType, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on maxTransactionAmountType' % {"value" : value} )
    def validate_purchaseCurrencyType(self, value):
        # Validate type purchaseCurrencyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on purchaseCurrencyType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on purchaseCurrencyType' % {"value" : value.encode("utf-8")} )
    def validate_merchantCategoryCodeType(self, value):
        # Validate type merchantCategoryCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on merchantCategoryCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on merchantCategoryCodeType' % {"value" : value.encode("utf-8")} )
    def validate_bankRoutingNumberType(self, value):
        # Validate type bankRoutingNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on bankRoutingNumberType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on bankRoutingNumberType' % {"value" : value.encode("utf-8")} )
    def validate_bankAccountNumberType(self, value):
        # Validate type bankAccountNumberType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on bankAccountNumberType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on bankAccountNumberType' % {"value" : value.encode("utf-8")} )
    def validate_pspMerchantIdType(self, value):
        # Validate type pspMerchantIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pspMerchantIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pspMerchantIdType' % {"value" : value.encode("utf-8")} )
    def validate_settlementCurrencyType(self, value):
        # Validate type settlementCurrencyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on settlementCurrencyType' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on settlementCurrencyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.merchantName is not None or
            self.amexMid is not None or
            self.discoverConveyedMid is not None or
            self.url is not None or
            self.customerServiceNumber is not None or
            self.hardCodedBillingDescriptor is not None or
            self.maxTransactionAmount is not None or
            self.purchaseCurrency is not None or
            self.merchantCategoryCode is not None or
            self.taxAuthority is not None or
            self.taxAuthorityState is not None or
            self.bankRoutingNumber is not None or
            self.bankAccountNumber is not None or
            self.pspMerchantId is not None or
            self.fraud is not None or
            self.amexAcquired is not None or
            self.address is not None or
            self.primaryContact is not None or
            self.createCredentials is not None or
            self.eCheck is not None or
            self.subMerchantFunding is not None or
            self.settlementCurrency is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCreateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantCreateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantCreateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantCreateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantCreateRequest'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCreateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.merchantName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:merchantName>%s</tns:merchantName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.merchantName), input_name='merchantName')), eol_))
        if self.amexMid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:amexMid>%s</tns:amexMid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.amexMid), input_name='amexMid')), eol_))
        if self.discoverConveyedMid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:discoverConveyedMid>%s</tns:discoverConveyedMid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.discoverConveyedMid), input_name='discoverConveyedMid')), eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:url>%s</tns:url>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), eol_))
        if self.customerServiceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:customerServiceNumber>%s</tns:customerServiceNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.customerServiceNumber), input_name='customerServiceNumber')), eol_))
        if self.hardCodedBillingDescriptor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:hardCodedBillingDescriptor>%s</tns:hardCodedBillingDescriptor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.hardCodedBillingDescriptor), input_name='hardCodedBillingDescriptor')), eol_))
        if self.maxTransactionAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:maxTransactionAmount>%s</tns:maxTransactionAmount>%s' % (self.gds_format_integer(self.maxTransactionAmount, input_name='maxTransactionAmount'), eol_))
        if self.purchaseCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:purchaseCurrency>%s</tns:purchaseCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.purchaseCurrency), input_name='purchaseCurrency')), eol_))
        if self.merchantCategoryCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:merchantCategoryCode>%s</tns:merchantCategoryCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.merchantCategoryCode), input_name='merchantCategoryCode')), eol_))
        if self.taxAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxAuthority>%s</tns:taxAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxAuthority), input_name='taxAuthority')), eol_))
        if self.taxAuthorityState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxAuthorityState>%s</tns:taxAuthorityState>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxAuthorityState), input_name='taxAuthorityState')), eol_))
        if self.bankRoutingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankRoutingNumber>%s</tns:bankRoutingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bankRoutingNumber), input_name='bankRoutingNumber')), eol_))
        if self.bankAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankAccountNumber>%s</tns:bankAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bankAccountNumber), input_name='bankAccountNumber')), eol_))
        if self.pspMerchantId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:pspMerchantId>%s</tns:pspMerchantId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pspMerchantId), input_name='pspMerchantId')), eol_))
        if self.fraud is not None:
            self.fraud.export(outfile, level, namespaceprefix_, name_='fraud', pretty_print=pretty_print)
        if self.amexAcquired is not None:
            self.amexAcquired.export(outfile, level, namespaceprefix_, name_='amexAcquired', pretty_print=pretty_print)
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.primaryContact is not None:
            self.primaryContact.export(outfile, level, namespaceprefix_, name_='primaryContact', pretty_print=pretty_print)
        if self.createCredentials is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:createCredentials>%s</tns:createCredentials>%s' % (self.gds_format_boolean(self.createCredentials, input_name='createCredentials'), eol_))
        if self.eCheck is not None:
            self.eCheck.export(outfile, level, namespaceprefix_, name_='eCheck', pretty_print=pretty_print)
        if self.subMerchantFunding is not None:
            self.subMerchantFunding.export(outfile, level, namespaceprefix_, name_='subMerchantFunding', pretty_print=pretty_print)
        if self.settlementCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:settlementCurrency>%s</tns:settlementCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.settlementCurrency), input_name='settlementCurrency')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'merchantName':
            merchantName_ = child_.text
            merchantName_ = self.gds_validate_string(merchantName_, node, 'merchantName')
            self.merchantName = merchantName_
            # validate type merchantNameType
            self.validate_merchantNameType(self.merchantName)
        elif nodeName_ == 'amexMid':
            amexMid_ = child_.text
            amexMid_ = self.gds_validate_string(amexMid_, node, 'amexMid')
            self.amexMid = amexMid_
            # validate type amexMidType
            self.validate_amexMidType(self.amexMid)
        elif nodeName_ == 'discoverConveyedMid':
            discoverConveyedMid_ = child_.text
            discoverConveyedMid_ = self.gds_validate_string(discoverConveyedMid_, node, 'discoverConveyedMid')
            self.discoverConveyedMid = discoverConveyedMid_
            # validate type discoverConveyedMidType
            self.validate_discoverConveyedMidType(self.discoverConveyedMid)
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
            # validate type urlType
            self.validate_urlType(self.url)
        elif nodeName_ == 'customerServiceNumber':
            customerServiceNumber_ = child_.text
            customerServiceNumber_ = self.gds_validate_string(customerServiceNumber_, node, 'customerServiceNumber')
            self.customerServiceNumber = customerServiceNumber_
            # validate type customerServiceNumberType
            self.validate_customerServiceNumberType(self.customerServiceNumber)
        elif nodeName_ == 'hardCodedBillingDescriptor':
            hardCodedBillingDescriptor_ = child_.text
            hardCodedBillingDescriptor_ = self.gds_validate_string(hardCodedBillingDescriptor_, node, 'hardCodedBillingDescriptor')
            self.hardCodedBillingDescriptor = hardCodedBillingDescriptor_
            # validate type hardCodedBillingDescriptorType
            self.validate_hardCodedBillingDescriptorType(self.hardCodedBillingDescriptor)
        elif nodeName_ == 'maxTransactionAmount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxTransactionAmount')
            self.maxTransactionAmount = ival_
            # validate type maxTransactionAmountType
            self.validate_maxTransactionAmountType(self.maxTransactionAmount)
        elif nodeName_ == 'purchaseCurrency':
            purchaseCurrency_ = child_.text
            purchaseCurrency_ = self.gds_validate_string(purchaseCurrency_, node, 'purchaseCurrency')
            self.purchaseCurrency = purchaseCurrency_
            # validate type purchaseCurrencyType
            self.validate_purchaseCurrencyType(self.purchaseCurrency)
        elif nodeName_ == 'merchantCategoryCode':
            merchantCategoryCode_ = child_.text
            merchantCategoryCode_ = self.gds_validate_string(merchantCategoryCode_, node, 'merchantCategoryCode')
            self.merchantCategoryCode = merchantCategoryCode_
            # validate type merchantCategoryCodeType
            self.validate_merchantCategoryCodeType(self.merchantCategoryCode)
        elif nodeName_ == 'taxAuthority':
            taxAuthority_ = child_.text
            taxAuthority_ = self.gds_validate_string(taxAuthority_, node, 'taxAuthority')
            self.taxAuthority = taxAuthority_
        elif nodeName_ == 'taxAuthorityState':
            taxAuthorityState_ = child_.text
            taxAuthorityState_ = self.gds_validate_string(taxAuthorityState_, node, 'taxAuthorityState')
            self.taxAuthorityState = taxAuthorityState_
        elif nodeName_ == 'bankRoutingNumber':
            bankRoutingNumber_ = child_.text
            bankRoutingNumber_ = self.gds_validate_string(bankRoutingNumber_, node, 'bankRoutingNumber')
            self.bankRoutingNumber = bankRoutingNumber_
            # validate type bankRoutingNumberType
            self.validate_bankRoutingNumberType(self.bankRoutingNumber)
        elif nodeName_ == 'bankAccountNumber':
            bankAccountNumber_ = child_.text
            bankAccountNumber_ = self.gds_validate_string(bankAccountNumber_, node, 'bankAccountNumber')
            self.bankAccountNumber = bankAccountNumber_
            # validate type bankAccountNumberType
            self.validate_bankAccountNumberType(self.bankAccountNumber)
        elif nodeName_ == 'pspMerchantId':
            pspMerchantId_ = child_.text
            pspMerchantId_ = self.gds_validate_string(pspMerchantId_, node, 'pspMerchantId')
            self.pspMerchantId = pspMerchantId_
            # validate type pspMerchantIdType
            self.validate_pspMerchantIdType(self.pspMerchantId)
        elif nodeName_ == 'fraud':
            obj_ = subMerchantFraudFeature.factory()
            obj_.build(child_)
            self.fraud = obj_
            obj_.original_tagname_ = 'fraud'
        elif nodeName_ == 'amexAcquired':
            obj_ = subMerchantAmexAcquiredFeature.factory()
            obj_.build(child_)
            self.amexAcquired = obj_
            obj_.original_tagname_ = 'amexAcquired'
        elif nodeName_ == 'address':
            obj_ = address.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'primaryContact':
            obj_ = subMerchantPrimaryContact.factory()
            obj_.build(child_)
            self.primaryContact = obj_
            obj_.original_tagname_ = 'primaryContact'
        elif nodeName_ == 'createCredentials':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'createCredentials')
            self.createCredentials = ival_
        elif nodeName_ == 'eCheck':
            obj_ = subMerchantECheckFeature.factory()
            obj_.build(child_)
            self.eCheck = obj_
            obj_.original_tagname_ = 'eCheck'
        elif nodeName_ == 'subMerchantFunding':
            obj_ = subMerchantFunding.factory()
            obj_.build(child_)
            self.subMerchantFunding = obj_
            obj_.original_tagname_ = 'subMerchantFunding'
        elif nodeName_ == 'settlementCurrency':
            settlementCurrency_ = child_.text
            settlementCurrency_ = self.gds_validate_string(settlementCurrency_, node, 'settlementCurrency')
            self.settlementCurrency = settlementCurrency_
            # validate type settlementCurrencyType
            self.validate_settlementCurrencyType(self.settlementCurrency)
# end class subMerchantCreateRequest


class subMerchantFraudFeature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None):
        self.original_tagname_ = None
        self.enabled = _cast(bool, enabled)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantFraudFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantFraudFeature.subclass:
            return subMerchantFraudFeature.subclass(*args_, **kwargs_)
        else:
            return subMerchantFraudFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantFraudFeature', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantFraudFeature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantFraudFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantFraudFeature', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantFraudFeature'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantFraudFeature', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subMerchantFraudFeature


class subMerchantAmexAcquiredFeature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None):
        self.original_tagname_ = None
        self.enabled = _cast(bool, enabled)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantAmexAcquiredFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantAmexAcquiredFeature.subclass:
            return subMerchantAmexAcquiredFeature.subclass(*args_, **kwargs_)
        else:
            return subMerchantAmexAcquiredFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantAmexAcquiredFeature', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantAmexAcquiredFeature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantAmexAcquiredFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantAmexAcquiredFeature', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantAmexAcquiredFeature'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantAmexAcquiredFeature', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subMerchantAmexAcquiredFeature


class subMerchantPrimaryContact(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, firstName=None, lastName=None, emailAddress=None, phone=None):
        self.original_tagname_ = None
        self.firstName = firstName
        self.validate_firstNameType51(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType52(self.lastName)
        self.emailAddress = emailAddress
        self.validate_emailAddressType53(self.emailAddress)
        self.phone = phone
        self.validate_phoneType(self.phone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantPrimaryContact)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantPrimaryContact.subclass:
            return subMerchantPrimaryContact.subclass(*args_, **kwargs_)
        else:
            return subMerchantPrimaryContact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def validate_firstNameType51(self, value):
        # Validate type firstNameType51, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType51' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType51' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType52(self, value):
        # Validate type lastNameType52, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType52' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType52' % {"value" : value.encode("utf-8")} )
    def validate_emailAddressType53(self, value):
        # Validate type emailAddressType53, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailAddressType53' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailAddressType53' % {"value" : value.encode("utf-8")} )
    def validate_phoneType(self, value):
        # Validate type phoneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on phoneType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on phoneType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.firstName is not None or
            self.lastName is not None or
            self.emailAddress is not None or
            self.phone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantPrimaryContact', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantPrimaryContact')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantPrimaryContact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantPrimaryContact', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantPrimaryContact'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantPrimaryContact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
        if self.emailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:emailAddress>%s</tns:emailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.emailAddress), input_name='emailAddress')), eol_))
        if self.phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:phone>%s</tns:phone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.phone), input_name='phone')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType51
            self.validate_firstNameType51(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType52
            self.validate_lastNameType52(self.lastName)
        elif nodeName_ == 'emailAddress':
            emailAddress_ = child_.text
            emailAddress_ = self.gds_validate_string(emailAddress_, node, 'emailAddress')
            self.emailAddress = emailAddress_
            # validate type emailAddressType53
            self.validate_emailAddressType53(self.emailAddress)
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
            # validate type phoneType
            self.validate_phoneType(self.phone)
# end class subMerchantPrimaryContact


class subMerchantECheckFeature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, eCheckCompanyName=None, eCheckBillingDescriptor=None):
        self.original_tagname_ = None
        self.enabled = _cast(bool, enabled)
        self.eCheckCompanyName = eCheckCompanyName
        self.validate_eCheckCompanyNameType(self.eCheckCompanyName)
        self.eCheckBillingDescriptor = eCheckBillingDescriptor
        self.validate_eCheckBillingDescriptorType(self.eCheckBillingDescriptor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantECheckFeature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantECheckFeature.subclass:
            return subMerchantECheckFeature.subclass(*args_, **kwargs_)
        else:
            return subMerchantECheckFeature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eCheckCompanyName(self): return self.eCheckCompanyName
    def set_eCheckCompanyName(self, eCheckCompanyName): self.eCheckCompanyName = eCheckCompanyName
    def get_eCheckBillingDescriptor(self): return self.eCheckBillingDescriptor
    def set_eCheckBillingDescriptor(self, eCheckBillingDescriptor): self.eCheckBillingDescriptor = eCheckBillingDescriptor
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def validate_eCheckCompanyNameType(self, value):
        # Validate type eCheckCompanyNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 16:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on eCheckCompanyNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on eCheckCompanyNameType' % {"value" : value.encode("utf-8")} )
    def validate_eCheckBillingDescriptorType(self, value):
        # Validate type eCheckBillingDescriptorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on eCheckBillingDescriptorType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on eCheckBillingDescriptorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.eCheckCompanyName is not None or
            self.eCheckBillingDescriptor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantECheckFeature', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantECheckFeature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantECheckFeature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantECheckFeature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantECheckFeature'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantECheckFeature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eCheckCompanyName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:eCheckCompanyName>%s</tns:eCheckCompanyName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.eCheckCompanyName), input_name='eCheckCompanyName')), eol_))
        if self.eCheckBillingDescriptor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:eCheckBillingDescriptor>%s</tns:eCheckBillingDescriptor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.eCheckBillingDescriptor), input_name='eCheckBillingDescriptor')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eCheckCompanyName':
            eCheckCompanyName_ = child_.text
            eCheckCompanyName_ = self.gds_validate_string(eCheckCompanyName_, node, 'eCheckCompanyName')
            self.eCheckCompanyName = eCheckCompanyName_
            # validate type eCheckCompanyNameType
            self.validate_eCheckCompanyNameType(self.eCheckCompanyName)
        elif nodeName_ == 'eCheckBillingDescriptor':
            eCheckBillingDescriptor_ = child_.text
            eCheckBillingDescriptor_ = self.gds_validate_string(eCheckBillingDescriptor_, node, 'eCheckBillingDescriptor')
            self.eCheckBillingDescriptor = eCheckBillingDescriptor_
            # validate type eCheckBillingDescriptorType
            self.validate_eCheckBillingDescriptorType(self.eCheckBillingDescriptor)
# end class subMerchantECheckFeature


class subMerchantFunding(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, feeProfile=None, fundingSubmerchantId=None):
        self.original_tagname_ = None
        self.enabled = _cast(bool, enabled)
        self.feeProfile = feeProfile
        self.validate_feeProfileType(self.feeProfile)
        self.fundingSubmerchantId = fundingSubmerchantId
        self.validate_fundingSubmerchantIdType(self.fundingSubmerchantId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantFunding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantFunding.subclass:
            return subMerchantFunding.subclass(*args_, **kwargs_)
        else:
            return subMerchantFunding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_feeProfile(self): return self.feeProfile
    def set_feeProfile(self, feeProfile): self.feeProfile = feeProfile
    def get_fundingSubmerchantId(self): return self.fundingSubmerchantId
    def set_fundingSubmerchantId(self, fundingSubmerchantId): self.fundingSubmerchantId = fundingSubmerchantId
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def validate_feeProfileType(self, value):
        # Validate type feeProfileType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 150:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on feeProfileType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on feeProfileType' % {"value" : value.encode("utf-8")} )
    def validate_fundingSubmerchantIdType(self, value):
        # Validate type fundingSubmerchantIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on fundingSubmerchantIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on fundingSubmerchantIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.feeProfile is not None or
            self.fundingSubmerchantId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantFunding', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantFunding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantFunding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantFunding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantFunding'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantFunding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.feeProfile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:feeProfile>%s</tns:feeProfile>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.feeProfile), input_name='feeProfile')), eol_))
        if self.fundingSubmerchantId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:fundingSubmerchantId>%s</tns:fundingSubmerchantId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fundingSubmerchantId), input_name='fundingSubmerchantId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'feeProfile':
            feeProfile_ = child_.text
            feeProfile_ = self.gds_validate_string(feeProfile_, node, 'feeProfile')
            self.feeProfile = feeProfile_
            # validate type feeProfileType
            self.validate_feeProfileType(self.feeProfile)
        elif nodeName_ == 'fundingSubmerchantId':
            fundingSubmerchantId_ = child_.text
            fundingSubmerchantId_ = self.gds_validate_string(fundingSubmerchantId_, node, 'fundingSubmerchantId')
            self.fundingSubmerchantId = fundingSubmerchantId_
            # validate type fundingSubmerchantIdType
            self.validate_fundingSubmerchantIdType(self.fundingSubmerchantId)
# end class subMerchantFunding


class subMerchantCreateResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, duplicate=None, subMerchantId=None, merchantIdentString=None, originalSubMerchant=None, credentials=None, paypageCredentials=None, amexSellerId=None):
        self.original_tagname_ = None
        super(subMerchantCreateResponse, self).__init__(transactionId, )
        self.duplicate = _cast(bool, duplicate)
        self.subMerchantId = subMerchantId
        self.validate_subMerchantIdType(self.subMerchantId)
        self.merchantIdentString = merchantIdentString
        self.validate_merchantIdentStringType(self.merchantIdentString)
        self.originalSubMerchant = originalSubMerchant
        self.credentials = credentials
        self.paypageCredentials = paypageCredentials
        self.amexSellerId = amexSellerId
        self.validate_amexSellerIdType(self.amexSellerId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantCreateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantCreateResponse.subclass:
            return subMerchantCreateResponse.subclass(*args_, **kwargs_)
        else:
            return subMerchantCreateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subMerchantId(self): return self.subMerchantId
    def set_subMerchantId(self, subMerchantId): self.subMerchantId = subMerchantId
    def get_merchantIdentString(self): return self.merchantIdentString
    def set_merchantIdentString(self, merchantIdentString): self.merchantIdentString = merchantIdentString
    def get_originalSubMerchant(self): return self.originalSubMerchant
    def set_originalSubMerchant(self, originalSubMerchant): self.originalSubMerchant = originalSubMerchant
    def get_credentials(self): return self.credentials
    def set_credentials(self, credentials): self.credentials = credentials
    def get_paypageCredentials(self): return self.paypageCredentials
    def set_paypageCredentials(self, paypageCredentials): self.paypageCredentials = paypageCredentials
    def get_amexSellerId(self): return self.amexSellerId
    def set_amexSellerId(self, amexSellerId): self.amexSellerId = amexSellerId
    def get_duplicate(self): return self.duplicate
    def set_duplicate(self, duplicate): self.duplicate = duplicate
    def validate_subMerchantIdType(self, value):
        # Validate type subMerchantIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on subMerchantIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on subMerchantIdType' % {"value" : value.encode("utf-8")} )
    def validate_merchantIdentStringType(self, value):
        # Validate type merchantIdentStringType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on merchantIdentStringType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on merchantIdentStringType' % {"value" : value.encode("utf-8")} )
    def validate_amexSellerIdType(self, value):
        # Validate type amexSellerIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on amexSellerIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on amexSellerIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.subMerchantId is not None or
            self.merchantIdentString is not None or
            self.originalSubMerchant is not None or
            self.credentials is not None or
            self.paypageCredentials is not None or
            self.amexSellerId is not None or
            super(subMerchantCreateResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCreateResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantCreateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantCreateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantCreateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantCreateResponse'):
        super(subMerchantCreateResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantCreateResponse')
        if self.duplicate is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            outfile.write(' duplicate="%s"' % self.gds_format_boolean(self.duplicate, input_name='duplicate'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCreateResponse', fromsubclass_=False, pretty_print=True):
        super(subMerchantCreateResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subMerchantId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:subMerchantId>%s</tns:subMerchantId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.subMerchantId), input_name='subMerchantId')), eol_))
        if self.merchantIdentString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:merchantIdentString>%s</tns:merchantIdentString>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.merchantIdentString), input_name='merchantIdentString')), eol_))
        if self.originalSubMerchant is not None:
            self.originalSubMerchant.export(outfile, level, namespaceprefix_, name_='originalSubMerchant', pretty_print=pretty_print)
        if self.credentials is not None:
            self.credentials.export(outfile, level, namespaceprefix_, name_='credentials', pretty_print=pretty_print)
        if self.paypageCredentials is not None:
            self.paypageCredentials.export(outfile, level, namespaceprefix_, name_='paypageCredentials', pretty_print=pretty_print)
        if self.amexSellerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:amexSellerId>%s</tns:amexSellerId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.amexSellerId), input_name='amexSellerId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duplicate', node)
        if value is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            if value in ('true', '1'):
                self.duplicate = True
            elif value in ('false', '0'):
                self.duplicate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(subMerchantCreateResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subMerchantId':
            subMerchantId_ = child_.text
            subMerchantId_ = self.gds_validate_string(subMerchantId_, node, 'subMerchantId')
            self.subMerchantId = subMerchantId_
            # validate type subMerchantIdType
            self.validate_subMerchantIdType(self.subMerchantId)
        elif nodeName_ == 'merchantIdentString':
            merchantIdentString_ = child_.text
            merchantIdentString_ = self.gds_validate_string(merchantIdentString_, node, 'merchantIdentString')
            self.merchantIdentString = merchantIdentString_
            # validate type merchantIdentStringType
            self.validate_merchantIdentStringType(self.merchantIdentString)
        elif nodeName_ == 'originalSubMerchant':
            obj_ = subMerchantRetrievalResponse.factory()
            obj_.build(child_)
            self.originalSubMerchant = obj_
            obj_.original_tagname_ = 'originalSubMerchant'
        elif nodeName_ == 'credentials':
            obj_ = subMerchantCredentials.factory()
            obj_.build(child_)
            self.credentials = obj_
            obj_.original_tagname_ = 'credentials'
        elif nodeName_ == 'paypageCredentials':
            obj_ = paypageCredentialsType.factory()
            obj_.build(child_)
            self.paypageCredentials = obj_
            obj_.original_tagname_ = 'paypageCredentials'
        elif nodeName_ == 'amexSellerId':
            amexSellerId_ = child_.text
            amexSellerId_ = self.gds_validate_string(amexSellerId_, node, 'amexSellerId')
            self.amexSellerId = amexSellerId_
            # validate type amexSellerIdType
            self.validate_amexSellerIdType(self.amexSellerId)
        super(subMerchantCreateResponse, self).buildChildren(child_, node, nodeName_, True)
# end class subMerchantCreateResponse


class subMerchantRetrievalResponse(subMerchantCreateRequest):
    subclass = None
    superclass = subMerchantCreateRequest
    def __init__(self, merchantName=None, amexMid=None, discoverConveyedMid=None, url=None, customerServiceNumber=None, hardCodedBillingDescriptor=None, maxTransactionAmount=None, purchaseCurrency=None, merchantCategoryCode=None, taxAuthority=None, taxAuthorityState=None, bankRoutingNumber=None, bankAccountNumber=None, pspMerchantId=None, fraud=None, amexAcquired=None, address=None, primaryContact=None, createCredentials=None, eCheck=None, subMerchantFunding=None, settlementCurrency=None, subMerchantId=None, amexSellerId=None, disabled=None, transactionId=None, merchantIdentString=None, credentials=None, paypageCredentials=None, updateDate=None):
        self.original_tagname_ = None
        super(subMerchantRetrievalResponse, self).__init__(merchantName, amexMid, discoverConveyedMid, url, customerServiceNumber, hardCodedBillingDescriptor, maxTransactionAmount, purchaseCurrency, merchantCategoryCode, taxAuthority, taxAuthorityState, bankRoutingNumber, bankAccountNumber, pspMerchantId, fraud, amexAcquired, address, primaryContact, createCredentials, eCheck, subMerchantFunding, settlementCurrency, )
        self.subMerchantId = subMerchantId
        self.validate_subMerchantIdType54(self.subMerchantId)
        self.amexSellerId = amexSellerId
        self.validate_amexSellerIdType55(self.amexSellerId)
        self.disabled = disabled
        self.transactionId = transactionId
        self.validate_transactionIdType56(self.transactionId)
        self.merchantIdentString = merchantIdentString
        self.validate_merchantIdentStringType57(self.merchantIdentString)
        self.credentials = credentials
        self.paypageCredentials = paypageCredentials
        if isinstance(updateDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updateDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updateDate
        self.updateDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantRetrievalResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantRetrievalResponse.subclass:
            return subMerchantRetrievalResponse.subclass(*args_, **kwargs_)
        else:
            return subMerchantRetrievalResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subMerchantId(self): return self.subMerchantId
    def set_subMerchantId(self, subMerchantId): self.subMerchantId = subMerchantId
    def get_amexSellerId(self): return self.amexSellerId
    def set_amexSellerId(self, amexSellerId): self.amexSellerId = amexSellerId
    def get_disabled(self): return self.disabled
    def set_disabled(self, disabled): self.disabled = disabled
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_merchantIdentString(self): return self.merchantIdentString
    def set_merchantIdentString(self, merchantIdentString): self.merchantIdentString = merchantIdentString
    def get_credentials(self): return self.credentials
    def set_credentials(self, credentials): self.credentials = credentials
    def get_paypageCredentials(self): return self.paypageCredentials
    def set_paypageCredentials(self, paypageCredentials): self.paypageCredentials = paypageCredentials
    def get_updateDate(self): return self.updateDate
    def set_updateDate(self, updateDate): self.updateDate = updateDate
    def validate_subMerchantIdType54(self, value):
        # Validate type subMerchantIdType54, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on subMerchantIdType54' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on subMerchantIdType54' % {"value" : value.encode("utf-8")} )
    def validate_amexSellerIdType55(self, value):
        # Validate type amexSellerIdType55, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on amexSellerIdType55' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on amexSellerIdType55' % {"value" : value.encode("utf-8")} )
    def validate_transactionIdType56(self, value):
        # Validate type transactionIdType56, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on transactionIdType56' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on transactionIdType56' % {"value" : value.encode("utf-8")} )
    def validate_merchantIdentStringType57(self, value):
        # Validate type merchantIdentStringType57, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on merchantIdentStringType57' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on merchantIdentStringType57' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.subMerchantId is not None or
            self.amexSellerId is not None or
            self.disabled is not None or
            self.transactionId is not None or
            self.merchantIdentString is not None or
            self.credentials is not None or
            self.paypageCredentials is not None or
            self.updateDate is not None or
            super(subMerchantRetrievalResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantRetrievalResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantRetrievalResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantRetrievalResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantRetrievalResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantRetrievalResponse'):
        super(subMerchantRetrievalResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantRetrievalResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantRetrievalResponse', fromsubclass_=False, pretty_print=True):
        super(subMerchantRetrievalResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subMerchantId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:subMerchantId>%s</tns:subMerchantId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.subMerchantId), input_name='subMerchantId')), eol_))
        if self.amexSellerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:amexSellerId>%s</tns:amexSellerId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.amexSellerId), input_name='amexSellerId')), eol_))
        if self.disabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:disabled>%s</tns:disabled>%s' % (self.gds_format_boolean(self.disabled, input_name='disabled'), eol_))
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.transactionId), input_name='transactionId')), eol_))
        if self.merchantIdentString is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:merchantIdentString>%s</tns:merchantIdentString>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.merchantIdentString), input_name='merchantIdentString')), eol_))
        if self.credentials is not None:
            self.credentials.export(outfile, level, namespaceprefix_, name_='credentials', pretty_print=pretty_print)
        if self.paypageCredentials is not None:
            self.paypageCredentials.export(outfile, level, namespaceprefix_, name_='paypageCredentials', pretty_print=pretty_print)
        if self.updateDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:updateDate>%s</tns:updateDate>%s' % (self.gds_format_datetime(self.updateDate, input_name='updateDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(subMerchantRetrievalResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subMerchantId':
            subMerchantId_ = child_.text
            subMerchantId_ = self.gds_validate_string(subMerchantId_, node, 'subMerchantId')
            self.subMerchantId = subMerchantId_
            # validate type subMerchantIdType54
            self.validate_subMerchantIdType54(self.subMerchantId)
        elif nodeName_ == 'amexSellerId':
            amexSellerId_ = child_.text
            amexSellerId_ = self.gds_validate_string(amexSellerId_, node, 'amexSellerId')
            self.amexSellerId = amexSellerId_
            # validate type amexSellerIdType55
            self.validate_amexSellerIdType55(self.amexSellerId)
        elif nodeName_ == 'disabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'disabled')
            self.disabled = ival_
        elif nodeName_ == 'transactionId':
            transactionId_ = child_.text
            transactionId_ = self.gds_validate_string(transactionId_, node, 'transactionId')
            self.transactionId = transactionId_
            # validate type transactionIdType56
            self.validate_transactionIdType56(self.transactionId)
        elif nodeName_ == 'merchantIdentString':
            merchantIdentString_ = child_.text
            merchantIdentString_ = self.gds_validate_string(merchantIdentString_, node, 'merchantIdentString')
            self.merchantIdentString = merchantIdentString_
            # validate type merchantIdentStringType57
            self.validate_merchantIdentStringType57(self.merchantIdentString)
        elif nodeName_ == 'credentials':
            obj_ = subMerchantCredentials.factory()
            obj_.build(child_)
            self.credentials = obj_
            obj_.original_tagname_ = 'credentials'
        elif nodeName_ == 'paypageCredentials':
            obj_ = paypageCredentialsType58.factory()
            obj_.build(child_)
            self.paypageCredentials = obj_
            obj_.original_tagname_ = 'paypageCredentials'
        elif nodeName_ == 'updateDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updateDate = dval_
        super(subMerchantRetrievalResponse, self).buildChildren(child_, node, nodeName_, True)
# end class subMerchantRetrievalResponse


class subMerchantCredentials(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, username=None, password=None, passwordExpirationDate=None):
        self.original_tagname_ = None
        self.username = username
        self.validate_usernameType(self.username)
        self.password = password
        self.validate_passwordType(self.password)
        if isinstance(passwordExpirationDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(passwordExpirationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = passwordExpirationDate
        self.passwordExpirationDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantCredentials)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantCredentials.subclass:
            return subMerchantCredentials.subclass(*args_, **kwargs_)
        else:
            return subMerchantCredentials(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_passwordExpirationDate(self): return self.passwordExpirationDate
    def set_passwordExpirationDate(self, passwordExpirationDate): self.passwordExpirationDate = passwordExpirationDate
    def validate_usernameType(self, value):
        # Validate type usernameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 72:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on usernameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on usernameType' % {"value" : value.encode("utf-8")} )
    def validate_passwordType(self, value):
        # Validate type passwordType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 72:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on passwordType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on passwordType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.username is not None or
            self.password is not None or
            self.passwordExpirationDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCredentials', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantCredentials')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantCredentials')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantCredentials', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantCredentials'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantCredentials', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:username>%s</tns:username>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:password>%s</tns:password>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), eol_))
        if self.passwordExpirationDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:passwordExpirationDate>%s</tns:passwordExpirationDate>%s' % (self.gds_format_datetime(self.passwordExpirationDate, input_name='passwordExpirationDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
            # validate type usernameType
            self.validate_usernameType(self.username)
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
            # validate type passwordType
            self.validate_passwordType(self.password)
        elif nodeName_ == 'passwordExpirationDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.passwordExpirationDate = dval_
# end class subMerchantCredentials


class paypageCredential(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, username=None, paypageId=None):
        self.original_tagname_ = None
        self.username = username
        self.validate_usernameType59(self.username)
        self.paypageId = paypageId
        self.validate_paypageIdType(self.paypageId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paypageCredential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paypageCredential.subclass:
            return paypageCredential.subclass(*args_, **kwargs_)
        else:
            return paypageCredential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_paypageId(self): return self.paypageId
    def set_paypageId(self, paypageId): self.paypageId = paypageId
    def validate_usernameType59(self, value):
        # Validate type usernameType59, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 72:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on usernameType59' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on usernameType59' % {"value" : value.encode("utf-8")} )
    def validate_paypageIdType(self, value):
        # Validate type paypageIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on paypageIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on paypageIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.username is not None or
            self.paypageId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredential', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paypageCredential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paypageCredential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='paypageCredential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='paypageCredential'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredential', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:username>%s</tns:username>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), eol_))
        if self.paypageId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:paypageId>%s</tns:paypageId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.paypageId), input_name='paypageId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
            # validate type usernameType59
            self.validate_usernameType59(self.username)
        elif nodeName_ == 'paypageId':
            paypageId_ = child_.text
            paypageId_ = self.gds_validate_string(paypageId_, node, 'paypageId')
            self.paypageId = paypageId_
            # validate type paypageIdType
            self.validate_paypageIdType(self.paypageId)
# end class paypageCredential


class subMerchantUpdateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, merchantName=None, amexMid=None, discoverConveyedMid=None, url=None, customerServiceNumber=None, hardCodedBillingDescriptor=None, maxTransactionAmount=None, bankRoutingNumber=None, bankAccountNumber=None, pspMerchantId=None, purchaseCurrency=None, address=None, primaryContact=None, disable=None, fraud=None, amexAcquired=None, eCheck=None, subMerchantFunding=None, taxAuthority=None, taxAuthorityState=None):
        self.original_tagname_ = None
        self.merchantName = merchantName
        self.validate_merchantNameType60(self.merchantName)
        self.amexMid = amexMid
        self.validate_amexMidType61(self.amexMid)
        self.discoverConveyedMid = discoverConveyedMid
        self.validate_discoverConveyedMidType62(self.discoverConveyedMid)
        self.url = url
        self.validate_urlType63(self.url)
        self.customerServiceNumber = customerServiceNumber
        self.validate_customerServiceNumberType64(self.customerServiceNumber)
        self.hardCodedBillingDescriptor = hardCodedBillingDescriptor
        self.validate_hardCodedBillingDescriptorType65(self.hardCodedBillingDescriptor)
        self.maxTransactionAmount = maxTransactionAmount
        self.validate_maxTransactionAmountType66(self.maxTransactionAmount)
        self.bankRoutingNumber = bankRoutingNumber
        self.validate_bankRoutingNumberType67(self.bankRoutingNumber)
        self.bankAccountNumber = bankAccountNumber
        self.validate_bankAccountNumberType68(self.bankAccountNumber)
        self.pspMerchantId = pspMerchantId
        self.validate_pspMerchantIdType69(self.pspMerchantId)
        self.purchaseCurrency = purchaseCurrency
        self.validate_purchaseCurrencyType70(self.purchaseCurrency)
        self.address = address
        self.primaryContact = primaryContact
        self.disable = disable
        self.fraud = fraud
        self.amexAcquired = amexAcquired
        self.eCheck = eCheck
        self.subMerchantFunding = subMerchantFunding
        self.taxAuthority = taxAuthority
        self.taxAuthorityState = taxAuthorityState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantUpdateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantUpdateRequest.subclass:
            return subMerchantUpdateRequest.subclass(*args_, **kwargs_)
        else:
            return subMerchantUpdateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merchantName(self): return self.merchantName
    def set_merchantName(self, merchantName): self.merchantName = merchantName
    def get_amexMid(self): return self.amexMid
    def set_amexMid(self, amexMid): self.amexMid = amexMid
    def get_discoverConveyedMid(self): return self.discoverConveyedMid
    def set_discoverConveyedMid(self, discoverConveyedMid): self.discoverConveyedMid = discoverConveyedMid
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_customerServiceNumber(self): return self.customerServiceNumber
    def set_customerServiceNumber(self, customerServiceNumber): self.customerServiceNumber = customerServiceNumber
    def get_hardCodedBillingDescriptor(self): return self.hardCodedBillingDescriptor
    def set_hardCodedBillingDescriptor(self, hardCodedBillingDescriptor): self.hardCodedBillingDescriptor = hardCodedBillingDescriptor
    def get_maxTransactionAmount(self): return self.maxTransactionAmount
    def set_maxTransactionAmount(self, maxTransactionAmount): self.maxTransactionAmount = maxTransactionAmount
    def get_bankRoutingNumber(self): return self.bankRoutingNumber
    def set_bankRoutingNumber(self, bankRoutingNumber): self.bankRoutingNumber = bankRoutingNumber
    def get_bankAccountNumber(self): return self.bankAccountNumber
    def set_bankAccountNumber(self, bankAccountNumber): self.bankAccountNumber = bankAccountNumber
    def get_pspMerchantId(self): return self.pspMerchantId
    def set_pspMerchantId(self, pspMerchantId): self.pspMerchantId = pspMerchantId
    def get_purchaseCurrency(self): return self.purchaseCurrency
    def set_purchaseCurrency(self, purchaseCurrency): self.purchaseCurrency = purchaseCurrency
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_primaryContact(self): return self.primaryContact
    def set_primaryContact(self, primaryContact): self.primaryContact = primaryContact
    def get_disable(self): return self.disable
    def set_disable(self, disable): self.disable = disable
    def get_fraud(self): return self.fraud
    def set_fraud(self, fraud): self.fraud = fraud
    def get_amexAcquired(self): return self.amexAcquired
    def set_amexAcquired(self, amexAcquired): self.amexAcquired = amexAcquired
    def get_eCheck(self): return self.eCheck
    def set_eCheck(self, eCheck): self.eCheck = eCheck
    def get_subMerchantFunding(self): return self.subMerchantFunding
    def set_subMerchantFunding(self, subMerchantFunding): self.subMerchantFunding = subMerchantFunding
    def get_taxAuthority(self): return self.taxAuthority
    def set_taxAuthority(self, taxAuthority): self.taxAuthority = taxAuthority
    def get_taxAuthorityState(self): return self.taxAuthorityState
    def set_taxAuthorityState(self, taxAuthorityState): self.taxAuthorityState = taxAuthorityState
    def validate_merchantNameType60(self, value):
        # Validate type merchantNameType60, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on merchantNameType60' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on merchantNameType60' % {"value" : value.encode("utf-8")} )
    def validate_amexMidType61(self, value):
        # Validate type amexMidType61, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on amexMidType61' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on amexMidType61' % {"value" : value.encode("utf-8")} )
    def validate_discoverConveyedMidType62(self, value):
        # Validate type discoverConveyedMidType62, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on discoverConveyedMidType62' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on discoverConveyedMidType62' % {"value" : value.encode("utf-8")} )
    def validate_urlType63(self, value):
        # Validate type urlType63, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on urlType63' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on urlType63' % {"value" : value.encode("utf-8")} )
    def validate_customerServiceNumberType64(self, value):
        # Validate type customerServiceNumberType64, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on customerServiceNumberType64' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on customerServiceNumberType64' % {"value" : value.encode("utf-8")} )
    def validate_hardCodedBillingDescriptorType65(self, value):
        # Validate type hardCodedBillingDescriptorType65, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 25:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on hardCodedBillingDescriptorType65' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on hardCodedBillingDescriptorType65' % {"value" : value.encode("utf-8")} )
    def validate_maxTransactionAmountType66(self, value):
        # Validate type maxTransactionAmountType66, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on maxTransactionAmountType66' % {"value" : value} )
    def validate_bankRoutingNumberType67(self, value):
        # Validate type bankRoutingNumberType67, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on bankRoutingNumberType67' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on bankRoutingNumberType67' % {"value" : value.encode("utf-8")} )
    def validate_bankAccountNumberType68(self, value):
        # Validate type bankAccountNumberType68, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on bankAccountNumberType68' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on bankAccountNumberType68' % {"value" : value.encode("utf-8")} )
    def validate_pspMerchantIdType69(self, value):
        # Validate type pspMerchantIdType69, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 32:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pspMerchantIdType69' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pspMerchantIdType69' % {"value" : value.encode("utf-8")} )
    def validate_purchaseCurrencyType70(self, value):
        # Validate type purchaseCurrencyType70, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on purchaseCurrencyType70' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on purchaseCurrencyType70' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.merchantName is not None or
            self.amexMid is not None or
            self.discoverConveyedMid is not None or
            self.url is not None or
            self.customerServiceNumber is not None or
            self.hardCodedBillingDescriptor is not None or
            self.maxTransactionAmount is not None or
            self.bankRoutingNumber is not None or
            self.bankAccountNumber is not None or
            self.pspMerchantId is not None or
            self.purchaseCurrency is not None or
            self.address is not None or
            self.primaryContact is not None or
            self.disable is not None or
            self.fraud is not None or
            self.amexAcquired is not None or
            self.eCheck is not None or
            self.subMerchantFunding is not None or
            self.taxAuthority is not None or
            self.taxAuthorityState is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantUpdateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantUpdateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantUpdateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantUpdateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantUpdateRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantUpdateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.merchantName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:merchantName>%s</tns:merchantName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.merchantName), input_name='merchantName')), eol_))
        if self.amexMid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:amexMid>%s</tns:amexMid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.amexMid), input_name='amexMid')), eol_))
        if self.discoverConveyedMid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:discoverConveyedMid>%s</tns:discoverConveyedMid>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.discoverConveyedMid), input_name='discoverConveyedMid')), eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:url>%s</tns:url>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), eol_))
        if self.customerServiceNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:customerServiceNumber>%s</tns:customerServiceNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.customerServiceNumber), input_name='customerServiceNumber')), eol_))
        if self.hardCodedBillingDescriptor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:hardCodedBillingDescriptor>%s</tns:hardCodedBillingDescriptor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.hardCodedBillingDescriptor), input_name='hardCodedBillingDescriptor')), eol_))
        if self.maxTransactionAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:maxTransactionAmount>%s</tns:maxTransactionAmount>%s' % (self.gds_format_integer(self.maxTransactionAmount, input_name='maxTransactionAmount'), eol_))
        if self.bankRoutingNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankRoutingNumber>%s</tns:bankRoutingNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bankRoutingNumber), input_name='bankRoutingNumber')), eol_))
        if self.bankAccountNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:bankAccountNumber>%s</tns:bankAccountNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.bankAccountNumber), input_name='bankAccountNumber')), eol_))
        if self.pspMerchantId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:pspMerchantId>%s</tns:pspMerchantId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pspMerchantId), input_name='pspMerchantId')), eol_))
        if self.purchaseCurrency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:purchaseCurrency>%s</tns:purchaseCurrency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.purchaseCurrency), input_name='purchaseCurrency')), eol_))
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)
        if self.primaryContact is not None:
            self.primaryContact.export(outfile, level, namespaceprefix_, name_='primaryContact', pretty_print=pretty_print)
        if self.disable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:disable>%s</tns:disable>%s' % (self.gds_format_boolean(self.disable, input_name='disable'), eol_))
        if self.fraud is not None:
            self.fraud.export(outfile, level, namespaceprefix_, name_='fraud', pretty_print=pretty_print)
        if self.amexAcquired is not None:
            self.amexAcquired.export(outfile, level, namespaceprefix_, name_='amexAcquired', pretty_print=pretty_print)
        if self.eCheck is not None:
            self.eCheck.export(outfile, level, namespaceprefix_, name_='eCheck', pretty_print=pretty_print)
        if self.subMerchantFunding is not None:
            self.subMerchantFunding.export(outfile, level, namespaceprefix_, name_='subMerchantFunding', pretty_print=pretty_print)
        if self.taxAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxAuthority>%s</tns:taxAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxAuthority), input_name='taxAuthority')), eol_))
        if self.taxAuthorityState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:taxAuthorityState>%s</tns:taxAuthorityState>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.taxAuthorityState), input_name='taxAuthorityState')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'merchantName':
            merchantName_ = child_.text
            merchantName_ = self.gds_validate_string(merchantName_, node, 'merchantName')
            self.merchantName = merchantName_
            # validate type merchantNameType60
            self.validate_merchantNameType60(self.merchantName)
        elif nodeName_ == 'amexMid':
            amexMid_ = child_.text
            amexMid_ = self.gds_validate_string(amexMid_, node, 'amexMid')
            self.amexMid = amexMid_
            # validate type amexMidType61
            self.validate_amexMidType61(self.amexMid)
        elif nodeName_ == 'discoverConveyedMid':
            discoverConveyedMid_ = child_.text
            discoverConveyedMid_ = self.gds_validate_string(discoverConveyedMid_, node, 'discoverConveyedMid')
            self.discoverConveyedMid = discoverConveyedMid_
            # validate type discoverConveyedMidType62
            self.validate_discoverConveyedMidType62(self.discoverConveyedMid)
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
            # validate type urlType63
            self.validate_urlType63(self.url)
        elif nodeName_ == 'customerServiceNumber':
            customerServiceNumber_ = child_.text
            customerServiceNumber_ = self.gds_validate_string(customerServiceNumber_, node, 'customerServiceNumber')
            self.customerServiceNumber = customerServiceNumber_
            # validate type customerServiceNumberType64
            self.validate_customerServiceNumberType64(self.customerServiceNumber)
        elif nodeName_ == 'hardCodedBillingDescriptor':
            hardCodedBillingDescriptor_ = child_.text
            hardCodedBillingDescriptor_ = self.gds_validate_string(hardCodedBillingDescriptor_, node, 'hardCodedBillingDescriptor')
            self.hardCodedBillingDescriptor = hardCodedBillingDescriptor_
            # validate type hardCodedBillingDescriptorType65
            self.validate_hardCodedBillingDescriptorType65(self.hardCodedBillingDescriptor)
        elif nodeName_ == 'maxTransactionAmount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxTransactionAmount')
            self.maxTransactionAmount = ival_
            # validate type maxTransactionAmountType66
            self.validate_maxTransactionAmountType66(self.maxTransactionAmount)
        elif nodeName_ == 'bankRoutingNumber':
            bankRoutingNumber_ = child_.text
            bankRoutingNumber_ = self.gds_validate_string(bankRoutingNumber_, node, 'bankRoutingNumber')
            self.bankRoutingNumber = bankRoutingNumber_
            # validate type bankRoutingNumberType67
            self.validate_bankRoutingNumberType67(self.bankRoutingNumber)
        elif nodeName_ == 'bankAccountNumber':
            bankAccountNumber_ = child_.text
            bankAccountNumber_ = self.gds_validate_string(bankAccountNumber_, node, 'bankAccountNumber')
            self.bankAccountNumber = bankAccountNumber_
            # validate type bankAccountNumberType68
            self.validate_bankAccountNumberType68(self.bankAccountNumber)
        elif nodeName_ == 'pspMerchantId':
            pspMerchantId_ = child_.text
            pspMerchantId_ = self.gds_validate_string(pspMerchantId_, node, 'pspMerchantId')
            self.pspMerchantId = pspMerchantId_
            # validate type pspMerchantIdType69
            self.validate_pspMerchantIdType69(self.pspMerchantId)
        elif nodeName_ == 'purchaseCurrency':
            purchaseCurrency_ = child_.text
            purchaseCurrency_ = self.gds_validate_string(purchaseCurrency_, node, 'purchaseCurrency')
            self.purchaseCurrency = purchaseCurrency_
            # validate type purchaseCurrencyType70
            self.validate_purchaseCurrencyType70(self.purchaseCurrency)
        elif nodeName_ == 'address':
            obj_ = addressUpdatable.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'primaryContact':
            obj_ = subMerchantPrimaryContactUpdatable.factory()
            obj_.build(child_)
            self.primaryContact = obj_
            obj_.original_tagname_ = 'primaryContact'
        elif nodeName_ == 'disable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'disable')
            self.disable = ival_
        elif nodeName_ == 'fraud':
            obj_ = subMerchantFraudFeature.factory()
            obj_.build(child_)
            self.fraud = obj_
            obj_.original_tagname_ = 'fraud'
        elif nodeName_ == 'amexAcquired':
            obj_ = subMerchantAmexAcquiredFeature.factory()
            obj_.build(child_)
            self.amexAcquired = obj_
            obj_.original_tagname_ = 'amexAcquired'
        elif nodeName_ == 'eCheck':
            obj_ = subMerchantECheckFeature.factory()
            obj_.build(child_)
            self.eCheck = obj_
            obj_.original_tagname_ = 'eCheck'
        elif nodeName_ == 'subMerchantFunding':
            obj_ = subMerchantFunding.factory()
            obj_.build(child_)
            self.subMerchantFunding = obj_
            obj_.original_tagname_ = 'subMerchantFunding'
        elif nodeName_ == 'taxAuthority':
            taxAuthority_ = child_.text
            taxAuthority_ = self.gds_validate_string(taxAuthority_, node, 'taxAuthority')
            self.taxAuthority = taxAuthority_
        elif nodeName_ == 'taxAuthorityState':
            taxAuthorityState_ = child_.text
            taxAuthorityState_ = self.gds_validate_string(taxAuthorityState_, node, 'taxAuthorityState')
            self.taxAuthorityState = taxAuthorityState_
# end class subMerchantUpdateRequest


class subMerchantPrimaryContactUpdatable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, firstName=None, lastName=None, emailAddress=None, phone=None):
        self.original_tagname_ = None
        self.firstName = firstName
        self.validate_firstNameType71(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType72(self.lastName)
        self.emailAddress = emailAddress
        self.validate_emailAddressType73(self.emailAddress)
        self.phone = phone
        self.validate_phoneType74(self.phone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subMerchantPrimaryContactUpdatable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subMerchantPrimaryContactUpdatable.subclass:
            return subMerchantPrimaryContactUpdatable.subclass(*args_, **kwargs_)
        else:
            return subMerchantPrimaryContactUpdatable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def validate_firstNameType71(self, value):
        # Validate type firstNameType71, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType71' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType71' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType72(self, value):
        # Validate type lastNameType72, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType72' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType72' % {"value" : value.encode("utf-8")} )
    def validate_emailAddressType73(self, value):
        # Validate type emailAddressType73, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailAddressType73' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailAddressType73' % {"value" : value.encode("utf-8")} )
    def validate_phoneType74(self, value):
        # Validate type phoneType74, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 13:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on phoneType74' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on phoneType74' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.firstName is not None or
            self.lastName is not None or
            self.emailAddress is not None or
            self.phone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantPrimaryContactUpdatable', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subMerchantPrimaryContactUpdatable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subMerchantPrimaryContactUpdatable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='subMerchantPrimaryContactUpdatable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='subMerchantPrimaryContactUpdatable'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='subMerchantPrimaryContactUpdatable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
        if self.emailAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:emailAddress>%s</tns:emailAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.emailAddress), input_name='emailAddress')), eol_))
        if self.phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:phone>%s</tns:phone>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.phone), input_name='phone')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType71
            self.validate_firstNameType71(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType72
            self.validate_lastNameType72(self.lastName)
        elif nodeName_ == 'emailAddress':
            emailAddress_ = child_.text
            emailAddress_ = self.gds_validate_string(emailAddress_, node, 'emailAddress')
            self.emailAddress = emailAddress_
            # validate type emailAddressType73
            self.validate_emailAddressType73(self.emailAddress)
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
            # validate type phoneType74
            self.validate_phoneType74(self.phone)
# end class subMerchantPrimaryContactUpdatable


class errorResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, errors=None):
        self.original_tagname_ = None
        super(errorResponse, self).__init__(transactionId, )
        self.errors = errors
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, errorResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if errorResponse.subclass:
            return errorResponse.subclass(*args_, **kwargs_)
        else:
            return errorResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_errors(self): return self.errors
    def set_errors(self, errors): self.errors = errors
    def hasContent_(self):
        if (
            self.errors is not None or
            super(errorResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='errorResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('errorResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='errorResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='errorResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='errorResponse'):
        super(errorResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='errorResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='errorResponse', fromsubclass_=False, pretty_print=True):
        super(errorResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errors is not None:
            self.errors.export(outfile, level, namespaceprefix_, name_='errors', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(errorResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'errors':
            obj_ = errorsType.factory()
            obj_.build(child_)
            self.errors = obj_
            obj_.original_tagname_ = 'errors'
        super(errorResponse, self).buildChildren(child_, node, nodeName_, True)
# end class errorResponse


class approvedMccResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, approvedMccs=None):
        self.original_tagname_ = None
        super(approvedMccResponse, self).__init__(transactionId, )
        self.approvedMccs = approvedMccs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, approvedMccResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if approvedMccResponse.subclass:
            return approvedMccResponse.subclass(*args_, **kwargs_)
        else:
            return approvedMccResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvedMccs(self): return self.approvedMccs
    def set_approvedMccs(self, approvedMccs): self.approvedMccs = approvedMccs
    def hasContent_(self):
        if (
            self.approvedMccs is not None or
            super(approvedMccResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='approvedMccResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('approvedMccResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='approvedMccResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='approvedMccResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='approvedMccResponse'):
        super(approvedMccResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='approvedMccResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='approvedMccResponse', fromsubclass_=False, pretty_print=True):
        super(approvedMccResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.approvedMccs is not None:
            self.approvedMccs.export(outfile, level, namespaceprefix_, name_='approvedMccs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(approvedMccResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approvedMccs':
            obj_ = approvedMccsType.factory()
            obj_.build(child_)
            self.approvedMccs = obj_
            obj_.original_tagname_ = 'approvedMccs'
        super(approvedMccResponse, self).buildChildren(child_, node, nodeName_, True)
# end class approvedMccResponse


class legalEntityAgreementCreateRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityAgreement=None):
        self.original_tagname_ = None
        self.legalEntityAgreement = legalEntityAgreement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityAgreementCreateRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityAgreementCreateRequest.subclass:
            return legalEntityAgreementCreateRequest.subclass(*args_, **kwargs_)
        else:
            return legalEntityAgreementCreateRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityAgreement(self): return self.legalEntityAgreement
    def set_legalEntityAgreement(self, legalEntityAgreement): self.legalEntityAgreement = legalEntityAgreement
    def hasContent_(self):
        if (
            self.legalEntityAgreement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementCreateRequest', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityAgreementCreateRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityAgreementCreateRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityAgreementCreateRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityAgreementCreateRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementCreateRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityAgreement is not None:
            self.legalEntityAgreement.export(outfile, level, namespaceprefix_, name_='legalEntityAgreement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityAgreement':
            obj_ = legalEntityAgreement.factory()
            obj_.build(child_)
            self.legalEntityAgreement = obj_
            obj_.original_tagname_ = 'legalEntityAgreement'
# end class legalEntityAgreementCreateRequest


class legalEntityAgreement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityAgreementType=None, agreementVersion=None, userFullName=None, userSystemName=None, userIPAddress=None, manuallyEntered=None, acceptanceDateTime=None):
        self.original_tagname_ = None
        self.legalEntityAgreementType = legalEntityAgreementType
        self.validate_legalEntityAgreementType(self.legalEntityAgreementType)
        self.agreementVersion = agreementVersion
        self.validate_agreementVersionType(self.agreementVersion)
        self.userFullName = userFullName
        self.validate_userFullNameType(self.userFullName)
        self.userSystemName = userSystemName
        self.validate_userSystemNameType(self.userSystemName)
        self.userIPAddress = userIPAddress
        self.validate_userIPAddressType(self.userIPAddress)
        self.manuallyEntered = manuallyEntered
        if isinstance(acceptanceDateTime, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(acceptanceDateTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = acceptanceDateTime
        self.acceptanceDateTime = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityAgreement.subclass:
            return legalEntityAgreement.subclass(*args_, **kwargs_)
        else:
            return legalEntityAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityAgreementType(self): return self.legalEntityAgreementType
    def set_legalEntityAgreementType(self, legalEntityAgreementType): self.legalEntityAgreementType = legalEntityAgreementType
    def get_agreementVersion(self): return self.agreementVersion
    def set_agreementVersion(self, agreementVersion): self.agreementVersion = agreementVersion
    def get_userFullName(self): return self.userFullName
    def set_userFullName(self, userFullName): self.userFullName = userFullName
    def get_userSystemName(self): return self.userSystemName
    def set_userSystemName(self, userSystemName): self.userSystemName = userSystemName
    def get_userIPAddress(self): return self.userIPAddress
    def set_userIPAddress(self, userIPAddress): self.userIPAddress = userIPAddress
    def get_manuallyEntered(self): return self.manuallyEntered
    def set_manuallyEntered(self, manuallyEntered): self.manuallyEntered = manuallyEntered
    def get_acceptanceDateTime(self): return self.acceptanceDateTime
    def set_acceptanceDateTime(self, acceptanceDateTime): self.acceptanceDateTime = acceptanceDateTime
    def validate_legalEntityAgreementType(self, value):
        # Validate type legalEntityAgreementType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MERCHANT_AGREEMENT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on legalEntityAgreementType' % {"value" : value.encode("utf-8")} )
    def validate_agreementVersionType(self, value):
        # Validate type agreementVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on agreementVersionType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on agreementVersionType' % {"value" : value.encode("utf-8")} )
    def validate_userFullNameType(self, value):
        # Validate type userFullNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on userFullNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on userFullNameType' % {"value" : value.encode("utf-8")} )
    def validate_userSystemNameType(self, value):
        # Validate type userSystemNameType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on userSystemNameType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on userSystemNameType' % {"value" : value.encode("utf-8")} )
    def validate_userIPAddressType(self, value):
        # Validate type userIPAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on userIPAddressType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on userIPAddressType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_userIPAddressType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_userIPAddressType_patterns_, ))
    validate_userIPAddressType_patterns_ = [[u'^([a-zA-Z0-9.:])*$']]
    def hasContent_(self):
        if (
            self.legalEntityAgreementType is not None or
            self.agreementVersion is not None or
            self.userFullName is not None or
            self.userSystemName is not None or
            self.userIPAddress is not None or
            self.manuallyEntered is not None or
            self.acceptanceDateTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreement', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityAgreement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityAgreement'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityAgreementType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityAgreementType>%s</tns:legalEntityAgreementType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityAgreementType), input_name='legalEntityAgreementType')), eol_))
        if self.agreementVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:agreementVersion>%s</tns:agreementVersion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.agreementVersion), input_name='agreementVersion')), eol_))
        if self.userFullName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:userFullName>%s</tns:userFullName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.userFullName), input_name='userFullName')), eol_))
        if self.userSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:userSystemName>%s</tns:userSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.userSystemName), input_name='userSystemName')), eol_))
        if self.userIPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:userIPAddress>%s</tns:userIPAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.userIPAddress), input_name='userIPAddress')), eol_))
        if self.manuallyEntered is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:manuallyEntered>%s</tns:manuallyEntered>%s' % (self.gds_format_boolean(self.manuallyEntered, input_name='manuallyEntered'), eol_))
        if self.acceptanceDateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:acceptanceDateTime>%s</tns:acceptanceDateTime>%s' % (self.gds_format_datetime(self.acceptanceDateTime, input_name='acceptanceDateTime'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityAgreementType':
            legalEntityAgreementType_ = child_.text
            legalEntityAgreementType_ = self.gds_validate_string(legalEntityAgreementType_, node, 'legalEntityAgreementType')
            self.legalEntityAgreementType = legalEntityAgreementType_
            # validate type legalEntityAgreementType
            self.validate_legalEntityAgreementType(self.legalEntityAgreementType)
        elif nodeName_ == 'agreementVersion':
            agreementVersion_ = child_.text
            agreementVersion_ = self.gds_validate_string(agreementVersion_, node, 'agreementVersion')
            self.agreementVersion = agreementVersion_
            # validate type agreementVersionType
            self.validate_agreementVersionType(self.agreementVersion)
        elif nodeName_ == 'userFullName':
            userFullName_ = child_.text
            userFullName_ = self.gds_validate_string(userFullName_, node, 'userFullName')
            self.userFullName = userFullName_
            # validate type userFullNameType
            self.validate_userFullNameType(self.userFullName)
        elif nodeName_ == 'userSystemName':
            userSystemName_ = child_.text
            userSystemName_ = self.gds_validate_string(userSystemName_, node, 'userSystemName')
            self.userSystemName = userSystemName_
            # validate type userSystemNameType
            self.validate_userSystemNameType(self.userSystemName)
        elif nodeName_ == 'userIPAddress':
            userIPAddress_ = child_.text
            userIPAddress_ = self.gds_validate_string(userIPAddress_, node, 'userIPAddress')
            self.userIPAddress = userIPAddress_
            # validate type userIPAddressType
            self.validate_userIPAddressType(self.userIPAddress)
        elif nodeName_ == 'manuallyEntered':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'manuallyEntered')
            self.manuallyEntered = ival_
        elif nodeName_ == 'acceptanceDateTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.acceptanceDateTime = dval_
# end class legalEntityAgreement


class legalEntityAgreementCreateResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, duplicate=None):
        self.original_tagname_ = None
        super(legalEntityAgreementCreateResponse, self).__init__(transactionId, )
        self.duplicate = _cast(bool, duplicate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityAgreementCreateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityAgreementCreateResponse.subclass:
            return legalEntityAgreementCreateResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityAgreementCreateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duplicate(self): return self.duplicate
    def set_duplicate(self, duplicate): self.duplicate = duplicate
    def hasContent_(self):
        if (
            super(legalEntityAgreementCreateResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementCreateResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityAgreementCreateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityAgreementCreateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityAgreementCreateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityAgreementCreateResponse'):
        super(legalEntityAgreementCreateResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityAgreementCreateResponse')
        if self.duplicate is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            outfile.write(' duplicate="%s"' % self.gds_format_boolean(self.duplicate, input_name='duplicate'))
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementCreateResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityAgreementCreateResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duplicate', node)
        if value is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            if value in ('true', '1'):
                self.duplicate = True
            elif value in ('false', '0'):
                self.duplicate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(legalEntityAgreementCreateResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(legalEntityAgreementCreateResponse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class legalEntityAgreementCreateResponse


class legalEntityAgreementRetrievalResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityId=None, transactionId=None, agreements=None):
        self.original_tagname_ = None
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType75(self.legalEntityId)
        self.transactionId = transactionId
        self.agreements = agreements
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityAgreementRetrievalResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityAgreementRetrievalResponse.subclass:
            return legalEntityAgreementRetrievalResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityAgreementRetrievalResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_agreements(self): return self.agreements
    def set_agreements(self, agreements): self.agreements = agreements
    def validate_legalEntityIdType75(self, value):
        # Validate type legalEntityIdType75, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType75' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType75' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityId is not None or
            self.transactionId is not None or
            self.agreements is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementRetrievalResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityAgreementRetrievalResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityAgreementRetrievalResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityAgreementRetrievalResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityAgreementRetrievalResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityAgreementRetrievalResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_format_integer(self.transactionId, input_name='transactionId'), eol_))
        if self.agreements is not None:
            self.agreements.export(outfile, level, namespaceprefix_, name_='agreements', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType75
            self.validate_legalEntityIdType75(self.legalEntityId)
        elif nodeName_ == 'transactionId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'transactionId')
            self.transactionId = ival_
        elif nodeName_ == 'agreements':
            obj_ = agreementsType.factory()
            obj_.build(child_)
            self.agreements = obj_
            obj_.original_tagname_ = 'agreements'
# end class legalEntityAgreementRetrievalResponse


class legalEntityPrincipalDeleteResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, legalEntityId=None, principalId=None, responseDescription=None):
        self.original_tagname_ = None
        super(legalEntityPrincipalDeleteResponse, self).__init__(transactionId, )
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType76(self.legalEntityId)
        self.principalId = principalId
        self.responseDescription = responseDescription
        self.validate_responseDescriptionType77(self.responseDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipalDeleteResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipalDeleteResponse.subclass:
            return legalEntityPrincipalDeleteResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipalDeleteResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_responseDescription(self): return self.responseDescription
    def set_responseDescription(self, responseDescription): self.responseDescription = responseDescription
    def validate_legalEntityIdType76(self, value):
        # Validate type legalEntityIdType76, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType76' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType76' % {"value" : value.encode("utf-8")} )
    def validate_responseDescriptionType77(self, value):
        # Validate type responseDescriptionType77, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on responseDescriptionType77' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on responseDescriptionType77' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityId is not None or
            self.principalId is not None or
            self.responseDescription is not None or
            super(legalEntityPrincipalDeleteResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalDeleteResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipalDeleteResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalDeleteResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipalDeleteResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipalDeleteResponse'):
        super(legalEntityPrincipalDeleteResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalDeleteResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalDeleteResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityPrincipalDeleteResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.responseDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseDescription>%s</tns:responseDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.responseDescription), input_name='responseDescription')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(legalEntityPrincipalDeleteResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType76
            self.validate_legalEntityIdType76(self.legalEntityId)
        elif nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'responseDescription':
            responseDescription_ = child_.text
            responseDescription_ = self.gds_validate_string(responseDescription_, node, 'responseDescription')
            self.responseDescription = responseDescription_
            # validate type responseDescriptionType77
            self.validate_responseDescriptionType77(self.responseDescription)
        super(legalEntityPrincipalDeleteResponse, self).buildChildren(child_, node, nodeName_, True)
# end class legalEntityPrincipalDeleteResponse


class legalEntityPrincipalCreateResponseWithResponseFields(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, principalId=None, firstName=None, lastName=None, responseCode=None, responseDescription=None):
        self.original_tagname_ = None
        self.principalId = principalId
        self.firstName = firstName
        self.validate_firstNameType78(self.firstName)
        self.lastName = lastName
        self.validate_lastNameType79(self.lastName)
        self.responseCode = responseCode
        self.responseDescription = responseDescription
        self.validate_responseDescriptionType80(self.responseDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityPrincipalCreateResponseWithResponseFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityPrincipalCreateResponseWithResponseFields.subclass:
            return legalEntityPrincipalCreateResponseWithResponseFields.subclass(*args_, **kwargs_)
        else:
            return legalEntityPrincipalCreateResponseWithResponseFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_responseCode(self): return self.responseCode
    def set_responseCode(self, responseCode): self.responseCode = responseCode
    def get_responseDescription(self): return self.responseDescription
    def set_responseDescription(self, responseDescription): self.responseDescription = responseDescription
    def validate_firstNameType78(self, value):
        # Validate type firstNameType78, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on firstNameType78' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on firstNameType78' % {"value" : value.encode("utf-8")} )
    def validate_lastNameType79(self, value):
        # Validate type lastNameType79, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lastNameType79' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lastNameType79' % {"value" : value.encode("utf-8")} )
    def validate_responseDescriptionType80(self, value):
        # Validate type responseDescriptionType80, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on responseDescriptionType80' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on responseDescriptionType80' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.principalId is not None or
            self.firstName is not None or
            self.lastName is not None or
            self.responseCode is not None or
            self.responseDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponseWithResponseFields', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityPrincipalCreateResponseWithResponseFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityPrincipalCreateResponseWithResponseFields')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponseWithResponseFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponseWithResponseFields'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityPrincipalCreateResponseWithResponseFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.firstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:firstName>%s</tns:firstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.firstName), input_name='firstName')), eol_))
        if self.lastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:lastName>%s</tns:lastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.lastName), input_name='lastName')), eol_))
        if self.responseCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseCode>%s</tns:responseCode>%s' % (self.gds_format_integer(self.responseCode, input_name='responseCode'), eol_))
        if self.responseDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseDescription>%s</tns:responseDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.responseDescription), input_name='responseDescription')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'firstName':
            firstName_ = child_.text
            firstName_ = self.gds_validate_string(firstName_, node, 'firstName')
            self.firstName = firstName_
            # validate type firstNameType78
            self.validate_firstNameType78(self.firstName)
        elif nodeName_ == 'lastName':
            lastName_ = child_.text
            lastName_ = self.gds_validate_string(lastName_, node, 'lastName')
            self.lastName = lastName_
            # validate type lastNameType79
            self.validate_lastNameType79(self.lastName)
        elif nodeName_ == 'responseCode' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'responseCode')
            self.responseCode = ival_
        elif nodeName_ == 'responseDescription':
            responseDescription_ = child_.text
            responseDescription_ = self.gds_validate_string(responseDescription_, node, 'responseDescription')
            self.responseDescription = responseDescription_
            # validate type responseDescriptionType80
            self.validate_responseDescriptionType80(self.responseDescription)
# end class legalEntityPrincipalCreateResponseWithResponseFields


class principalCreateResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityId=None, principal=None, transactionId=None):
        self.original_tagname_ = None
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType81(self.legalEntityId)
        self.principal = principal
        self.transactionId = transactionId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalCreateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalCreateResponse.subclass:
            return principalCreateResponse.subclass(*args_, **kwargs_)
        else:
            return principalCreateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def validate_legalEntityIdType81(self, value):
        # Validate type legalEntityIdType81, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType81' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType81' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityId is not None or
            self.principal is not None or
            self.transactionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalCreateResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalCreateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalCreateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalCreateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalCreateResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalCreateResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_format_integer(self.transactionId, input_name='transactionId'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType81
            self.validate_legalEntityIdType81(self.legalEntityId)
        elif nodeName_ == 'principal':
            obj_ = legalEntityPrincipalCreateResponseWithResponseFields.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        elif nodeName_ == 'transactionId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'transactionId')
            self.transactionId = ival_
# end class principalCreateResponse


class principalDeleteResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transactionId=None, legalEntityId=None, principalId=None, responseDescription=None):
        self.original_tagname_ = None
        self.transactionId = transactionId
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType82(self.legalEntityId)
        self.principalId = principalId
        self.responseDescription = responseDescription
        self.validate_responseDescriptionType83(self.responseDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, principalDeleteResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if principalDeleteResponse.subclass:
            return principalDeleteResponse.subclass(*args_, **kwargs_)
        else:
            return principalDeleteResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_principalId(self): return self.principalId
    def set_principalId(self, principalId): self.principalId = principalId
    def get_responseDescription(self): return self.responseDescription
    def set_responseDescription(self, responseDescription): self.responseDescription = responseDescription
    def validate_legalEntityIdType82(self, value):
        # Validate type legalEntityIdType82, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType82' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType82' % {"value" : value.encode("utf-8")} )
    def validate_responseDescriptionType83(self, value):
        # Validate type responseDescriptionType83, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on responseDescriptionType83' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on responseDescriptionType83' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.transactionId is not None or
            self.legalEntityId is not None or
            self.principalId is not None or
            self.responseDescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='principalDeleteResponse', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('principalDeleteResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='principalDeleteResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='principalDeleteResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='principalDeleteResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='principalDeleteResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:transactionId>%s</tns:transactionId>%s' % (self.gds_format_integer(self.transactionId, input_name='transactionId'), eol_))
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.principalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:principalId>%s</tns:principalId>%s' % (self.gds_format_integer(self.principalId, input_name='principalId'), eol_))
        if self.responseDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseDescription>%s</tns:responseDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.responseDescription), input_name='responseDescription')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transactionId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'transactionId')
            self.transactionId = ival_
        elif nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType82
            self.validate_legalEntityIdType82(self.legalEntityId)
        elif nodeName_ == 'principalId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'principalId')
            self.principalId = ival_
        elif nodeName_ == 'responseDescription':
            responseDescription_ = child_.text
            responseDescription_ = self.gds_validate_string(responseDescription_, node, 'responseDescription')
            self.responseDescription = responseDescription_
            # validate type responseDescriptionType83
            self.validate_responseDescriptionType83(self.responseDescription)
# end class principalDeleteResponse


class riskIndicatorsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, riskIndicator=None):
        self.original_tagname_ = None
        if riskIndicator is None:
            self.riskIndicator = []
        else:
            self.riskIndicator = riskIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, riskIndicatorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if riskIndicatorsType.subclass:
            return riskIndicatorsType.subclass(*args_, **kwargs_)
        else:
            return riskIndicatorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_riskIndicator(self): return self.riskIndicator
    def set_riskIndicator(self, riskIndicator): self.riskIndicator = riskIndicator
    def add_riskIndicator(self, value): self.riskIndicator.append(value)
    def insert_riskIndicator_at(self, index, value): self.riskIndicator.insert(index, value)
    def replace_riskIndicator_at(self, index, value): self.riskIndicator[index] = value
    def hasContent_(self):
        if (
            self.riskIndicator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='riskIndicatorsType', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('riskIndicatorsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='riskIndicatorsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='riskIndicatorsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='riskIndicatorsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='riskIndicatorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for riskIndicator_ in self.riskIndicator:
            riskIndicator_.export(outfile, level, namespaceprefix_, name_='riskIndicator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'riskIndicator':
            obj_ = potentialRiskIndicator.factory()
            obj_.build(child_)
            self.riskIndicator.append(obj_)
            obj_.original_tagname_ = 'riskIndicator'
# end class riskIndicatorsType


class riskIndicatorsType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, riskIndicator=None):
        self.original_tagname_ = None
        if riskIndicator is None:
            self.riskIndicator = []
        else:
            self.riskIndicator = riskIndicator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, riskIndicatorsType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if riskIndicatorsType16.subclass:
            return riskIndicatorsType16.subclass(*args_, **kwargs_)
        else:
            return riskIndicatorsType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_riskIndicator(self): return self.riskIndicator
    def set_riskIndicator(self, riskIndicator): self.riskIndicator = riskIndicator
    def add_riskIndicator(self, value): self.riskIndicator.append(value)
    def insert_riskIndicator_at(self, index, value): self.riskIndicator.insert(index, value)
    def replace_riskIndicator_at(self, index, value): self.riskIndicator[index] = value
    def hasContent_(self):
        if (
            self.riskIndicator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='riskIndicatorsType16', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('riskIndicatorsType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='riskIndicatorsType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='riskIndicatorsType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='riskIndicatorsType16'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='riskIndicatorsType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for riskIndicator_ in self.riskIndicator:
            riskIndicator_.export(outfile, level, namespaceprefix_, name_='riskIndicator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'riskIndicator':
            obj_ = potentialRiskIndicator.factory()
            obj_.build(child_)
            self.riskIndicator.append(obj_)
            obj_.original_tagname_ = 'riskIndicator'
# end class riskIndicatorsType16


class paypageCredentialsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, paypageCredential=None):
        self.original_tagname_ = None
        if paypageCredential is None:
            self.paypageCredential = []
        else:
            self.paypageCredential = paypageCredential
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paypageCredentialsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paypageCredentialsType.subclass:
            return paypageCredentialsType.subclass(*args_, **kwargs_)
        else:
            return paypageCredentialsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paypageCredential(self): return self.paypageCredential
    def set_paypageCredential(self, paypageCredential): self.paypageCredential = paypageCredential
    def add_paypageCredential(self, value): self.paypageCredential.append(value)
    def insert_paypageCredential_at(self, index, value): self.paypageCredential.insert(index, value)
    def replace_paypageCredential_at(self, index, value): self.paypageCredential[index] = value
    def hasContent_(self):
        if (
            self.paypageCredential
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredentialsType', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paypageCredentialsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paypageCredentialsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='paypageCredentialsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='paypageCredentialsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredentialsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for paypageCredential_ in self.paypageCredential:
            paypageCredential_.export(outfile, level, namespaceprefix_, name_='paypageCredential', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paypageCredential':
            obj_ = paypageCredential.factory()
            obj_.build(child_)
            self.paypageCredential.append(obj_)
            obj_.original_tagname_ = 'paypageCredential'
# end class paypageCredentialsType


class paypageCredentialsType58(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, paypageCredential=None):
        self.original_tagname_ = None
        if paypageCredential is None:
            self.paypageCredential = []
        else:
            self.paypageCredential = paypageCredential
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paypageCredentialsType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paypageCredentialsType58.subclass:
            return paypageCredentialsType58.subclass(*args_, **kwargs_)
        else:
            return paypageCredentialsType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_paypageCredential(self): return self.paypageCredential
    def set_paypageCredential(self, paypageCredential): self.paypageCredential = paypageCredential
    def add_paypageCredential(self, value): self.paypageCredential.append(value)
    def insert_paypageCredential_at(self, index, value): self.paypageCredential.insert(index, value)
    def replace_paypageCredential_at(self, index, value): self.paypageCredential[index] = value
    def hasContent_(self):
        if (
            self.paypageCredential
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredentialsType58', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paypageCredentialsType58')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paypageCredentialsType58')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='paypageCredentialsType58', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='paypageCredentialsType58'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='paypageCredentialsType58', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for paypageCredential_ in self.paypageCredential:
            paypageCredential_.export(outfile, level, namespaceprefix_, name_='paypageCredential', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'paypageCredential':
            obj_ = paypageCredential.factory()
            obj_.build(child_)
            self.paypageCredential.append(obj_)
            obj_.original_tagname_ = 'paypageCredential'
# end class paypageCredentialsType58


class errorsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, error=None):
        self.original_tagname_ = None
        if error is None:
            self.error = []
        else:
            self.error = error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, errorsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if errorsType.subclass:
            return errorsType.subclass(*args_, **kwargs_)
        else:
            return errorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_error(self): return self.error
    def set_error(self, error): self.error = error
    def add_error(self, value): self.error.append(value)
    def insert_error_at(self, index, value): self.error.insert(index, value)
    def replace_error_at(self, index, value): self.error[index] = value
    def hasContent_(self):
        if (
            self.error
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='errorsType', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('errorsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='errorsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='errorsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='errorsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='errorsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for error_ in self.error:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:error>%s</tns:error>%s' % (self.gds_encode(self.gds_format_string(quote_xml(error_), input_name='error')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'error':
            error_ = child_.text
            error_ = self.gds_validate_string(error_, node, 'error')
            self.error.append(error_)
# end class errorsType


class approvedMccsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approvedMcc=None):
        self.original_tagname_ = None
        if approvedMcc is None:
            self.approvedMcc = []
        else:
            self.approvedMcc = approvedMcc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, approvedMccsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if approvedMccsType.subclass:
            return approvedMccsType.subclass(*args_, **kwargs_)
        else:
            return approvedMccsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approvedMcc(self): return self.approvedMcc
    def set_approvedMcc(self, approvedMcc): self.approvedMcc = approvedMcc
    def add_approvedMcc(self, value): self.approvedMcc.append(value)
    def insert_approvedMcc_at(self, index, value): self.approvedMcc.insert(index, value)
    def replace_approvedMcc_at(self, index, value): self.approvedMcc[index] = value
    def hasContent_(self):
        if (
            self.approvedMcc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='approvedMccsType', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('approvedMccsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='approvedMccsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='approvedMccsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='approvedMccsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='approvedMccsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for approvedMcc_ in self.approvedMcc:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:approvedMcc>%s</tns:approvedMcc>%s' % (self.gds_encode(self.gds_format_string(quote_xml(approvedMcc_), input_name='approvedMcc')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'approvedMcc':
            approvedMcc_ = child_.text
            approvedMcc_ = self.gds_validate_string(approvedMcc_, node, 'approvedMcc')
            self.approvedMcc.append(approvedMcc_)
# end class approvedMccsType


class agreementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, legalEntityAgreement=None):
        self.original_tagname_ = None
        if legalEntityAgreement is None:
            self.legalEntityAgreement = []
        else:
            self.legalEntityAgreement = legalEntityAgreement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, agreementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if agreementsType.subclass:
            return agreementsType.subclass(*args_, **kwargs_)
        else:
            return agreementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityAgreement(self): return self.legalEntityAgreement
    def set_legalEntityAgreement(self, legalEntityAgreement): self.legalEntityAgreement = legalEntityAgreement
    def add_legalEntityAgreement(self, value): self.legalEntityAgreement.append(value)
    def insert_legalEntityAgreement_at(self, index, value): self.legalEntityAgreement.insert(index, value)
    def replace_legalEntityAgreement_at(self, index, value): self.legalEntityAgreement[index] = value
    def hasContent_(self):
        if (
            self.legalEntityAgreement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='agreementsType', namespacedef_='xmlns:tns="http://payfac.vantivcnp.com/api/merchant/onboard"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('agreementsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agreementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='agreementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='agreementsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='agreementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for legalEntityAgreement_ in self.legalEntityAgreement:
            legalEntityAgreement_.export(outfile, level, namespaceprefix_, name_='legalEntityAgreement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityAgreement':
            obj_ = legalEntityAgreement.factory()
            obj_.build(child_)
            self.legalEntityAgreement.append(obj_)
            obj_.original_tagname_ = 'legalEntityAgreement'
# end class agreementsType


class legalEntityResponse(response):
    subclass = None
    superclass = response
    def __init__(self, transactionId=None, duplicate=None, legalEntityId=None, responseCode=None, responseDescription=None, originallegalEntityId=None, originallegalEntityStatus=None, backgroundCheckResults=None, extensiontype_=None):
        self.original_tagname_ = None
        super(legalEntityResponse, self).__init__(transactionId, extensiontype_, )
        self.duplicate = _cast(bool, duplicate)
        self.legalEntityId = legalEntityId
        self.validate_legalEntityIdType(self.legalEntityId)
        self.responseCode = responseCode
        self.responseDescription = responseDescription
        self.validate_responseDescriptionType(self.responseDescription)
        self.originallegalEntityId = originallegalEntityId
        self.validate_originallegalEntityIdType(self.originallegalEntityId)
        self.originallegalEntityStatus = originallegalEntityStatus
        self.validate_originallegalEntityStatusType(self.originallegalEntityStatus)
        self.backgroundCheckResults = backgroundCheckResults
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityResponse.subclass:
            return legalEntityResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_legalEntityId(self): return self.legalEntityId
    def set_legalEntityId(self, legalEntityId): self.legalEntityId = legalEntityId
    def get_responseCode(self): return self.responseCode
    def set_responseCode(self, responseCode): self.responseCode = responseCode
    def get_responseDescription(self): return self.responseDescription
    def set_responseDescription(self, responseDescription): self.responseDescription = responseDescription
    def get_originallegalEntityId(self): return self.originallegalEntityId
    def set_originallegalEntityId(self, originallegalEntityId): self.originallegalEntityId = originallegalEntityId
    def get_originallegalEntityStatus(self): return self.originallegalEntityStatus
    def set_originallegalEntityStatus(self, originallegalEntityStatus): self.originallegalEntityStatus = originallegalEntityStatus
    def get_backgroundCheckResults(self): return self.backgroundCheckResults
    def set_backgroundCheckResults(self, backgroundCheckResults): self.backgroundCheckResults = backgroundCheckResults
    def get_duplicate(self): return self.duplicate
    def set_duplicate(self, duplicate): self.duplicate = duplicate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_legalEntityIdType(self, value):
        # Validate type legalEntityIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on legalEntityIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on legalEntityIdType' % {"value" : value.encode("utf-8")} )
    def validate_responseDescriptionType(self, value):
        # Validate type responseDescriptionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on responseDescriptionType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on responseDescriptionType' % {"value" : value.encode("utf-8")} )
    def validate_originallegalEntityIdType(self, value):
        # Validate type originallegalEntityIdType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 19:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on originallegalEntityIdType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on originallegalEntityIdType' % {"value" : value.encode("utf-8")} )
    def validate_originallegalEntityStatusType(self, value):
        # Validate type originallegalEntityStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on originallegalEntityStatusType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on originallegalEntityStatusType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.legalEntityId is not None or
            self.responseCode is not None or
            self.responseDescription is not None or
            self.originallegalEntityId is not None or
            self.originallegalEntityStatus is not None or
            self.backgroundCheckResults is not None or
            super(legalEntityResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityResponse'):
        super(legalEntityResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityResponse')
        if self.duplicate is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            outfile.write(' duplicate="%s"' % self.gds_format_boolean(self.duplicate, input_name='duplicate'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.legalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:legalEntityId>%s</tns:legalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.legalEntityId), input_name='legalEntityId')), eol_))
        if self.responseCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseCode>%s</tns:responseCode>%s' % (self.gds_format_integer(self.responseCode, input_name='responseCode'), eol_))
        if self.responseDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:responseDescription>%s</tns:responseDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.responseDescription), input_name='responseDescription')), eol_))
        if self.originallegalEntityId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:originallegalEntityId>%s</tns:originallegalEntityId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.originallegalEntityId), input_name='originallegalEntityId')), eol_))
        if self.originallegalEntityStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:originallegalEntityStatus>%s</tns:originallegalEntityStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.originallegalEntityStatus), input_name='originallegalEntityStatus')), eol_))
        if self.backgroundCheckResults is not None:
            self.backgroundCheckResults.export(outfile, level, namespaceprefix_='tns:', name_='backgroundCheckResults', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duplicate', node)
        if value is not None and 'duplicate' not in already_processed:
            already_processed.add('duplicate')
            if value in ('true', '1'):
                self.duplicate = True
            elif value in ('false', '0'):
                self.duplicate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(legalEntityResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'legalEntityId':
            legalEntityId_ = child_.text
            legalEntityId_ = self.gds_validate_string(legalEntityId_, node, 'legalEntityId')
            self.legalEntityId = legalEntityId_
            # validate type legalEntityIdType
            self.validate_legalEntityIdType(self.legalEntityId)
        elif nodeName_ == 'responseCode' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'responseCode')
            self.responseCode = ival_
        elif nodeName_ == 'responseDescription':
            responseDescription_ = child_.text
            responseDescription_ = self.gds_validate_string(responseDescription_, node, 'responseDescription')
            self.responseDescription = responseDescription_
            # validate type responseDescriptionType
            self.validate_responseDescriptionType(self.responseDescription)
        elif nodeName_ == 'originallegalEntityId':
            originallegalEntityId_ = child_.text
            originallegalEntityId_ = self.gds_validate_string(originallegalEntityId_, node, 'originallegalEntityId')
            self.originallegalEntityId = originallegalEntityId_
            # validate type originallegalEntityIdType
            self.validate_originallegalEntityIdType(self.originallegalEntityId)
        elif nodeName_ == 'originallegalEntityStatus':
            originallegalEntityStatus_ = child_.text
            originallegalEntityStatus_ = self.gds_validate_string(originallegalEntityStatus_, node, 'originallegalEntityStatus')
            self.originallegalEntityStatus = originallegalEntityStatus_
            # validate type originallegalEntityStatusType
            self.validate_originallegalEntityStatusType(self.originallegalEntityStatus)
        elif nodeName_ == 'backgroundCheckResults':
            obj_ = backgroundCheckResults.factory()
            obj_.build(child_)
            self.backgroundCheckResults = obj_
            obj_.original_tagname_ = 'backgroundCheckResults'
        super(legalEntityResponse, self).buildChildren(child_, node, nodeName_, True)
# end class legalEntityResponse


class legalEntityCreateResponse(legalEntityResponse):
    subclass = None
    superclass = legalEntityResponse
    def __init__(self, transactionId=None, duplicate=None, legalEntityId=None, responseCode=None, responseDescription=None, originallegalEntityId=None, originallegalEntityStatus=None, backgroundCheckResults=None, principal=None):
        self.original_tagname_ = None
        super(legalEntityCreateResponse, self).__init__(transactionId, duplicate, legalEntityId, responseCode, responseDescription, originallegalEntityId, originallegalEntityStatus, backgroundCheckResults, )
        self.principal = principal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, legalEntityCreateResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if legalEntityCreateResponse.subclass:
            return legalEntityCreateResponse.subclass(*args_, **kwargs_)
        else:
            return legalEntityCreateResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def hasContent_(self):
        if (
            self.principal is not None or
            super(legalEntityCreateResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityCreateResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('legalEntityCreateResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityCreateResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='tns:', name_='legalEntityCreateResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='tns:', name_='legalEntityCreateResponse'):
        super(legalEntityCreateResponse, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='legalEntityCreateResponse')
    def exportChildren(self, outfile, level, namespaceprefix_='tns:', name_='legalEntityCreateResponse', fromsubclass_=False, pretty_print=True):
        super(legalEntityCreateResponse, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.principal is not None:
            self.principal.export(outfile, level, namespaceprefix_, name_='principal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(legalEntityCreateResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'principal':
            obj_ = legalEntityPrincipalCreateResponse.factory()
            obj_.build(child_)
            self.principal = obj_
            obj_.original_tagname_ = 'principal'
        super(legalEntityCreateResponse, self).buildChildren(child_, node, nodeName_, True)
# end class legalEntityCreateResponse


GDSClassesMapping = {
    'approvedMccResponse': approvedMccResponse,
    'backgroundCheckResults': backgroundCheckResults,
    'errorResponse': errorResponse,
    'legalEntityAgreementCreateRequest': legalEntityAgreementCreateRequest,
    'legalEntityAgreementCreateResponse': legalEntityAgreementCreateResponse,
    'legalEntityAgreementRetrievalResponse': legalEntityAgreementRetrievalResponse,
    'legalEntityCreateRequest': legalEntityCreateRequest,
    'legalEntityCreateResponse': legalEntityCreateResponse,
    'legalEntityPrincipalCreateRequest': legalEntityPrincipalCreateRequest,
    'legalEntityPrincipalCreateResponse': legalEntityPrincipalCreateResponse,
    'legalEntityPrincipalCreateResponseWithResponseFields': legalEntityPrincipalCreateResponseWithResponseFields,
    'legalEntityPrincipalDeleteResponse': legalEntityPrincipalDeleteResponse,
    'legalEntityResponse': legalEntityResponse,
    'legalEntityRetrievalResponse': legalEntityRetrievalResponse,
    'legalEntityUpdateRequest': legalEntityUpdateRequest,
    'principalCreateResponse': principalCreateResponse,
    'principalDeleteResponse': principalDeleteResponse,
    'response': response,
    'subMerchantAmexAcquiredFeature': subMerchantAmexAcquiredFeature,
    'subMerchantCreateRequest': subMerchantCreateRequest,
    'subMerchantCreateResponse': subMerchantCreateResponse,
    'subMerchantECheckFeature': subMerchantECheckFeature,
    'subMerchantFraudFeature': subMerchantFraudFeature,
    'subMerchantRetrievalResponse': subMerchantRetrievalResponse,
    'subMerchantUpdateRequest': subMerchantUpdateRequest,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'approvedMccResponse'
        rootClass = approvedMccResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:http://payfac.vantivcnp.com/api/merchant/onboard',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'approvedMccResponse'
        rootClass = approvedMccResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'approvedMccResponse'
        rootClass = approvedMccResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:http://payfac.vantivcnp.com/api/merchant/onboard')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'approvedMccResponse'
        rootClass = approvedMccResponse
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from generatedClass import *\n\n')
        sys.stdout.write('import generatedClass as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "address",
    "addressUpdatable",
    "agreementsType",
    "approvedMccResponse",
    "approvedMccsType",
    "backgroundCheckResults",
    "bankruptcyResult",
    "businessNameAddressPhoneAssociation",
    "businessResult",
    "businessScore",
    "businessToPrincipalAssociation",
    "businessVerificationIndicators",
    "businessVerificationResult",
    "errorResponse",
    "errorsType",
    "legalEntityAgreement",
    "legalEntityAgreementCreateRequest",
    "legalEntityAgreementCreateResponse",
    "legalEntityAgreementRetrievalResponse",
    "legalEntityBackgroundCheckFields",
    "legalEntityCreateRequest",
    "legalEntityCreateResponse",
    "legalEntityPrincipal",
    "legalEntityPrincipalCreateRequest",
    "legalEntityPrincipalCreateResponse",
    "legalEntityPrincipalCreateResponseWithResponseFields",
    "legalEntityPrincipalDeleteResponse",
    "legalEntityPrincipalUpdatable",
    "legalEntityResponse",
    "legalEntityRetrievalResponse",
    "legalEntityUpdateRequest",
    "lienResult",
    "nameAddressSsnAssociation",
    "nameAddressTaxIdAssociation",
    "paypageCredential",
    "paypageCredentialsType",
    "paypageCredentialsType58",
    "potentialRiskIndicator",
    "principalAddress",
    "principalBackgroundCheckFields",
    "principalCreateResponse",
    "principalDeleteResponse",
    "principalNameAddressPhoneAssociation",
    "principalResult",
    "principalScore",
    "principalVerificationIndicators",
    "principalVerificationResult",
    "response",
    "riskIndicatorsType",
    "riskIndicatorsType16",
    "subMerchantAmexAcquiredFeature",
    "subMerchantCreateRequest",
    "subMerchantCreateResponse",
    "subMerchantCredentials",
    "subMerchantECheckFeature",
    "subMerchantFraudFeature",
    "subMerchantFunding",
    "subMerchantPrimaryContact",
    "subMerchantPrimaryContactUpdatable",
    "subMerchantRetrievalResponse",
    "subMerchantUpdateRequest"
]
